/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.2210 from the
 * contents of Vector.xs. Do not edit this file, edit Vector.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "Vector.xs"


/*****************************************************************************/
/*                                                                           */
/*    Copyright (c) 1995 - 2012 by Steffen Beyer.                            */
/*    All rights reserved.                                                   */
/*                                                                           */
/*    This package is free software; you can redistribute it                 */
/*    and/or modify it under the same terms as Perl itself.                  */
/*                                                                           */
/*****************************************************************************/


#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"


#include "patchlevel.h"
#if ((PATCHLEVEL < 4) || ((PATCHLEVEL == 4) && (SUBVERSION < 5)))
/* PL_na was introduced in perl5.004_05 */
#ifndef PL_na
    #define PL_na na
#endif
#endif
#if (PATCHLEVEL < 4)
/* GIMME_V was introduced in perl5.004 */
#ifndef GIMME_V
    #define GIMME_V GIMME
#endif
#endif


#include "BitVector.h"


typedef     SV *BitVector_Object;
typedef     SV *BitVector_Handle;
typedef N_word *BitVector_Address;
typedef     SV *BitVector_Scalar;


static char *BitVector_Class        = "Bit::Vector"; /* NOT "const" for older Perl versions */

const  char *BitVector_OBJECT_ERROR = "item is not a \"Bit::Vector\" object";
const  char *BitVector_SCALAR_ERROR = "item is not a scalar";
const  char *BitVector_STRING_ERROR = "item is not a string";
const  char *BitVector_MIN_ERROR    = "minimum index out of range";
const  char *BitVector_MAX_ERROR    = "maximum index out of range";
const  char *BitVector_START_ERROR  = "start index out of range";
const  char *BitVector_OFFSET_ERROR = "offset out of range";
const  char *BitVector_CHUNK_ERROR  = "chunk size out of range";
const  char *BitVector_SET_ERROR    = "set size mismatch";
const  char *BitVector_MATRIX_ERROR = "matrix size mismatch";
const  char *BitVector_SHAPE_ERROR  = "not a square matrix";
const  char *BitVector_MEMORY_ERROR = BV_ERRCODE_NULL;
const  char *BitVector_INDEX_ERROR  = BV_ERRCODE_INDX;
const  char *BitVector_ORDER_ERROR  = BV_ERRCODE_ORDR;
const  char *BitVector_SIZE_ERROR   = BV_ERRCODE_SIZE;


#define BIT_VECTOR_STASH gv_stashpv(BitVector_Class,1)


#define BIT_VECTOR_OBJECT(ref,hdl,adr) \
    ( ref && \
    SvROK(ref) && \
    (hdl = (BitVector_Handle)SvRV(ref)) && \
    SvOBJECT(hdl) && \
    SvREADONLY(hdl) && \
    (SvTYPE(hdl) == SVt_PVMG) && \
    (SvSTASH(hdl) == BIT_VECTOR_STASH) && \
    (adr = (BitVector_Address)SvIV(hdl)) )

#define BIT_VECTOR_FAKE_OBJECT(ref,hdl) \
    ( ref && \
    SvROK(ref) && \
    (hdl = (BitVector_Handle)SvRV(ref)) && \
    SvOBJECT(hdl) && \
    !SvREADONLY(hdl) && \
    (SvTYPE(hdl) == SVt_PVMG) && \
    (SvSTASH(hdl) == BIT_VECTOR_STASH) )

#define BIT_VECTOR_SCALAR(ref,typ,var) \
    ( ref && !(SvROK(ref)) && ((var = (typ)SvIV(ref)) | 1) )

#define BIT_VECTOR_STRING(ref,var) \
    ( ref && !(SvROK(ref)) && (var = (charptr)SvPV(ref,PL_na)) )

#define BIT_VECTOR_BUFFER(ref,var,len) \
    ( ref && !(SvROK(ref)) && SvPOK(ref) && \
    (var = (charptr)SvPV(ref,PL_na)) && \
    ((len = (N_int)SvCUR(ref)) | 1) )


#define BIT_VECTOR_ERROR(message) \
    croak("Bit::Vector::%s(): %s", GvNAME(CvGV(cv)), message)


#define BIT_VECTOR_OBJECT_ERROR \
    BIT_VECTOR_ERROR( BitVector_OBJECT_ERROR )

#define BIT_VECTOR_SCALAR_ERROR \
    BIT_VECTOR_ERROR( BitVector_SCALAR_ERROR )

#define BIT_VECTOR_STRING_ERROR \
    BIT_VECTOR_ERROR( BitVector_STRING_ERROR )

#define BIT_VECTOR_MIN_ERROR \
    BIT_VECTOR_ERROR( BitVector_MIN_ERROR )

#define BIT_VECTOR_MAX_ERROR \
    BIT_VECTOR_ERROR( BitVector_MAX_ERROR )

#define BIT_VECTOR_START_ERROR \
    BIT_VECTOR_ERROR( BitVector_START_ERROR )

#define BIT_VECTOR_OFFSET_ERROR \
    BIT_VECTOR_ERROR( BitVector_OFFSET_ERROR )

#define BIT_VECTOR_CHUNK_ERROR \
    BIT_VECTOR_ERROR( BitVector_CHUNK_ERROR )

#define BIT_VECTOR_SET_ERROR \
    BIT_VECTOR_ERROR( BitVector_SET_ERROR )

#define BIT_VECTOR_MATRIX_ERROR \
    BIT_VECTOR_ERROR( BitVector_MATRIX_ERROR )

#define BIT_VECTOR_SHAPE_ERROR \
    BIT_VECTOR_ERROR( BitVector_SHAPE_ERROR )

#define BIT_VECTOR_MEMORY_ERROR \
    BIT_VECTOR_ERROR( BitVector_MEMORY_ERROR )

#define BIT_VECTOR_INDEX_ERROR \
    BIT_VECTOR_ERROR( BitVector_INDEX_ERROR )

#define BIT_VECTOR_ORDER_ERROR \
    BIT_VECTOR_ERROR( BitVector_ORDER_ERROR )

#define BIT_VECTOR_SIZE_ERROR \
    BIT_VECTOR_ERROR( BitVector_SIZE_ERROR )


#define BIT_VECTOR_EXCEPTION(code) \
    BIT_VECTOR_ERROR( BitVector_Error(code) )


#line 160 "Vector.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)	S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage		S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 212 "Vector.c"

XS(XS_Bit__Vector_Version); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Version)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 171 "Vector.xs"
{
    charptr string;

    if ((items >= 0) and (items <= 1))
    {
        string = BitVector_Version();
        if (string != NULL)
        {
            EXTEND(sp,1);
            PUSHs(sv_2mortal(newSVpv((char *)string,0)));
        }
        else BIT_VECTOR_MEMORY_ERROR;
    }
    else croak("Usage: Bit::Vector->Version()");
}
#line 242 "Vector.c"
	PUTBACK;
	return;
    }
}


XS(XS_Bit__Vector_Word_Bits); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Word_Bits)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    {
	N_int	RETVAL;
	dXSTARG;
#line 191 "Vector.xs"
{
    if ((items >= 0) and (items <= 1))
    {
        RETVAL = BitVector_Word_Bits();
    }
    else croak("Usage: Bit::Vector->Word_Bits()");
}
#line 269 "Vector.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bit__Vector_Long_Bits); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Long_Bits)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    {
	N_int	RETVAL;
	dXSTARG;
#line 205 "Vector.xs"
{
    if ((items >= 0) and (items <= 1))
    {
        RETVAL = BitVector_Long_Bits();
    }
    else croak("Usage: Bit::Vector->Long_Bits()");
}
#line 296 "Vector.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bit__Vector_Create); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Create)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 221 "Vector.xs"
{
    BitVector_Scalar  arg1;
    BitVector_Scalar  arg2;
    BitVector_Address address;
    BitVector_Handle  handle;
    BitVector_Object  reference;
    bv_listptr list;
    bv_listptr slot;
    N_int bits;
    N_int count;

    if ((items >= 2) and (items <= 3))
    {
        arg1 = ST(1);
        if ( BIT_VECTOR_SCALAR(arg1,N_int,bits) )
        {
            if (items > 2)
            {
                arg2 = ST(2);
                if ( BIT_VECTOR_SCALAR(arg2,N_int,count) )
                {
                    if (count > 0)
                    {
                        if ((list = BitVector_Create_List(bits,true,count)) != NULL)
                        {
                            EXTEND(sp,(int)count);
                            slot = list;
                            while (count-- > 0)
                            {
                                address = *slot++;
                                handle = newSViv((IV)address);
                                reference = sv_bless(sv_2mortal(newRV(handle)), BIT_VECTOR_STASH);
                                SvREFCNT_dec(handle);
                                SvREADONLY_on(handle);
                                PUSHs(reference);
                            }
                            BitVector_Destroy_List(list,0);
                        }
                        else BIT_VECTOR_MEMORY_ERROR;
                    }
                }
                else BIT_VECTOR_SCALAR_ERROR;
            }
            else
            {
                if ((address = BitVector_Create(bits,true)) != NULL)
                {
                    handle = newSViv((IV)address);
                    reference = sv_bless(sv_2mortal(newRV(handle)), BIT_VECTOR_STASH);
                    SvREFCNT_dec(handle);
                    SvREADONLY_on(handle);
                    PUSHs(reference);
                }
                else BIT_VECTOR_MEMORY_ERROR;
            }
        }
        else BIT_VECTOR_SCALAR_ERROR;
    }
    else croak("Usage: %s(class,bits[,count])", GvNAME(CvGV(cv)));
}
#line 377 "Vector.c"
	PUTBACK;
	return;
    }
}


XS(XS_Bit__Vector_new_Hex); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_new_Hex)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "class, bits, string");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	BitVector_Object	class = ST(0);
	BitVector_Scalar	bits = ST(1);
	BitVector_Scalar	string = ST(2);
#line 289 "Vector.xs"
{
    BitVector_Address address;
    BitVector_Handle  handle;
    BitVector_Object  reference;
    charptr           pointer;
    BV_ErrCode        code;
    N_int             size;

    if ( BIT_VECTOR_SCALAR(bits,N_int,size) )
    {
        if ( BIT_VECTOR_STRING(string,pointer) )
        {
            if ((address = BitVector_Create(size,false)) != NULL)
            {
                if ((code = BitVector_from_Hex(address,pointer)))
                {
                    BitVector_Destroy(address);
                    BIT_VECTOR_EXCEPTION(code);
                }
                else
                {
                    handle = newSViv((IV)address);
                    reference = sv_bless(sv_2mortal(newRV(handle)), BIT_VECTOR_STASH);
                    SvREFCNT_dec(handle);
                    SvREADONLY_on(handle);
                    PUSHs(reference);
                }
            }
            else BIT_VECTOR_MEMORY_ERROR;
        }
        else BIT_VECTOR_STRING_ERROR;
    }
    else BIT_VECTOR_SCALAR_ERROR;
}
#line 435 "Vector.c"
	PUTBACK;
	return;
    }
}


XS(XS_Bit__Vector_new_Bin); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_new_Bin)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "class, bits, string");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	BitVector_Object	class = ST(0);
	BitVector_Scalar	bits = ST(1);
	BitVector_Scalar	string = ST(2);
#line 331 "Vector.xs"
{
    BitVector_Address address;
    BitVector_Handle  handle;
    BitVector_Object  reference;
    charptr           pointer;
    BV_ErrCode        code;
    N_int             size;

    if ( BIT_VECTOR_SCALAR(bits,N_int,size) )
    {
        if ( BIT_VECTOR_STRING(string,pointer) )
        {
            if ((address = BitVector_Create(size,false)) != NULL)
            {
                if ((code = BitVector_from_Bin(address,pointer)))
                {
                    BitVector_Destroy(address);
                    BIT_VECTOR_EXCEPTION(code);
                }
                else
                {
                    handle = newSViv((IV)address);
                    reference = sv_bless(sv_2mortal(newRV(handle)), BIT_VECTOR_STASH);
                    SvREFCNT_dec(handle);
                    SvREADONLY_on(handle);
                    PUSHs(reference);
                }
            }
            else BIT_VECTOR_MEMORY_ERROR;
        }
        else BIT_VECTOR_STRING_ERROR;
    }
    else BIT_VECTOR_SCALAR_ERROR;
}
#line 493 "Vector.c"
	PUTBACK;
	return;
    }
}


XS(XS_Bit__Vector_new_Dec); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_new_Dec)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "class, bits, string");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	BitVector_Object	class = ST(0);
	BitVector_Scalar	bits = ST(1);
	BitVector_Scalar	string = ST(2);
#line 373 "Vector.xs"
{
    BitVector_Address address;
    BitVector_Handle  handle;
    BitVector_Object  reference;
    charptr           pointer;
    BV_ErrCode        code;
    N_int             size;

    if ( BIT_VECTOR_SCALAR(bits,N_int,size) )
    {
        if ( BIT_VECTOR_STRING(string,pointer) )
        {
            if ((address = BitVector_Create(size,false)) != NULL)
            {
                if ((code = BitVector_from_Dec(address,pointer)))
                {
                    BitVector_Destroy(address);
                    BIT_VECTOR_EXCEPTION(code);
                }
                else
                {
                    handle = newSViv((IV)address);
                    reference = sv_bless(sv_2mortal(newRV(handle)), BIT_VECTOR_STASH);
                    SvREFCNT_dec(handle);
                    SvREADONLY_on(handle);
                    PUSHs(reference);
                }
            }
            else BIT_VECTOR_MEMORY_ERROR;
        }
        else BIT_VECTOR_STRING_ERROR;
    }
    else BIT_VECTOR_SCALAR_ERROR;
}
#line 551 "Vector.c"
	PUTBACK;
	return;
    }
}


XS(XS_Bit__Vector_new_Enum); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_new_Enum)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "class, bits, string");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	BitVector_Object	class = ST(0);
	BitVector_Scalar	bits = ST(1);
	BitVector_Scalar	string = ST(2);
#line 415 "Vector.xs"
{
    BitVector_Address address;
    BitVector_Handle  handle;
    BitVector_Object  reference;
    charptr           pointer;
    BV_ErrCode        code;
    N_int             size;

    if ( BIT_VECTOR_SCALAR(bits,N_int,size) )
    {
        if ( BIT_VECTOR_STRING(string,pointer) )
        {
            if ((address = BitVector_Create(size,false)) != NULL)
            {
                if ((code = BitVector_from_Enum(address,pointer)))
                {
                    BitVector_Destroy(address);
                    BIT_VECTOR_EXCEPTION(code);
                }
                else
                {
                    handle = newSViv((IV)address);
                    reference = sv_bless(sv_2mortal(newRV(handle)), BIT_VECTOR_STASH);
                    SvREFCNT_dec(handle);
                    SvREADONLY_on(handle);
                    PUSHs(reference);
                }
            }
            else BIT_VECTOR_MEMORY_ERROR;
        }
        else BIT_VECTOR_STRING_ERROR;
    }
    else BIT_VECTOR_SCALAR_ERROR;
}
#line 609 "Vector.c"
	PUTBACK;
	return;
    }
}


XS(XS_Bit__Vector_Shadow); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Shadow)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "reference");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	BitVector_Object	reference = ST(0);
#line 455 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        if ((address = BitVector_Shadow(address)) != NULL)
        {
            handle = newSViv((IV)address);
            reference = sv_bless(sv_2mortal(newRV(handle)), BIT_VECTOR_STASH);
            SvREFCNT_dec(handle);
            SvREADONLY_on(handle);
            PUSHs(reference);
        }
        else BIT_VECTOR_MEMORY_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 649 "Vector.c"
	PUTBACK;
	return;
    }
}


XS(XS_Bit__Vector_Clone); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Clone)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "reference");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	BitVector_Object	reference = ST(0);
#line 479 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        if ((address = BitVector_Clone(address)) != NULL)
        {
            handle = newSViv((IV)address);
            reference = sv_bless(sv_2mortal(newRV(handle)), BIT_VECTOR_STASH);
            SvREFCNT_dec(handle);
            SvREADONLY_on(handle);
            PUSHs(reference);
        }
        else BIT_VECTOR_MEMORY_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 689 "Vector.c"
	PUTBACK;
	return;
    }
}


XS(XS_Bit__Vector_Concat); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Concat)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "Xref, Yref");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	BitVector_Object	Xref = ST(0);
	BitVector_Object	Yref = ST(1);
#line 504 "Vector.xs"
{
    BitVector_Handle  Xhdl;
    BitVector_Address Xadr;
    BitVector_Handle  Yhdl;
    BitVector_Address Yadr;
    BitVector_Object  reference;
    BitVector_Handle  handle;
    BitVector_Address address;

    if ( BIT_VECTOR_OBJECT(Xref,Xhdl,Xadr) &&
         BIT_VECTOR_OBJECT(Yref,Yhdl,Yadr) )
    {
        if ((address = BitVector_Concat(Xadr,Yadr)) != NULL)
        {
            handle = newSViv((IV)address);
            reference = sv_bless(sv_2mortal(newRV(handle)), BIT_VECTOR_STASH);
            SvREFCNT_dec(handle);
            SvREADONLY_on(handle);
            PUSHs(reference);
        }
        else BIT_VECTOR_MEMORY_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 736 "Vector.c"
	PUTBACK;
	return;
    }
}


XS(XS_Bit__Vector_Concat_List); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Concat_List)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 533 "Vector.xs"
{
    BitVector_Object  Xref;
    BitVector_Handle  Xhdl;
    BitVector_Address Xadr;
    BitVector_Object  reference;
    BitVector_Handle  handle;
    BitVector_Address address;
    N_int offset;
    N_int bits;
    I32 index;

    bits = 0;
    index = items;
    while (index-- > 0)
    {
        Xref = ST(index);
        if ( BIT_VECTOR_OBJECT(Xref,Xhdl,Xadr) )
        {
            bits += BV_BITS_(Xadr);
        }
        else if ((index != 0) or SvROK(Xref))
          BIT_VECTOR_OBJECT_ERROR;
    }
    if ((address = BitVector_Create(bits,false)) != NULL)
    {
        offset = 0;
        index = items;
        while (index-- > 0)
        {
            Xref = ST(index);
            if ( BIT_VECTOR_OBJECT(Xref,Xhdl,Xadr) )
            {
                if ((bits = BV_BITS_(Xadr)) > 0)
                {
                    BitVector_Interval_Copy(address,Xadr,offset,0,bits);
                    offset += bits;
                }
            }
            else if ((index != 0) or SvROK(Xref)) BIT_VECTOR_OBJECT_ERROR;
        }
        handle = newSViv((IV)address);
        reference = sv_bless(sv_2mortal(newRV(handle)), BIT_VECTOR_STASH);
        SvREFCNT_dec(handle);
        SvREADONLY_on(handle);
        PUSHs(reference);
    }
    else BIT_VECTOR_MEMORY_ERROR;
}
#line 804 "Vector.c"
	PUTBACK;
	return;
    }
}


XS(XS_Bit__Vector_Size); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Size)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "reference");
    {
	BitVector_Object	reference = ST(0);
	N_int	RETVAL;
	dXSTARG;
#line 587 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        RETVAL = BV_BITS_(address);
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 836 "Vector.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bit__Vector_Resize); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Resize)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "reference, bits");
    {
	BitVector_Object	reference = ST(0);
	BitVector_Scalar	bits = ST(1);
#line 606 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;
    N_int size;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        if ( BIT_VECTOR_SCALAR(bits,N_int,size) )
        {
            address = BitVector_Resize(address,size);
            SvREADONLY_off(handle);
            sv_setiv(handle,(IV)address);
            SvREADONLY_on(handle);
            if (address == NULL) BIT_VECTOR_MEMORY_ERROR;
        }
        else BIT_VECTOR_SCALAR_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 876 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_Unfake); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Unfake)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "reference, bits");
    {
	BitVector_Object	reference = ST(0);
	BitVector_Scalar	bits = ST(1);
#line 632 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;
    N_int size;

    if ( BIT_VECTOR_FAKE_OBJECT(reference,handle) )
    {
        if ( BIT_VECTOR_SCALAR(bits,N_int,size) )
        {
            address = BitVector_Create(size,true);
            sv_setiv(handle,(IV)address);
            SvREADONLY_on(handle);
            if (address == NULL) BIT_VECTOR_MEMORY_ERROR;
        }
        else BIT_VECTOR_SCALAR_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 914 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "reference");
    {
	BitVector_Object	reference = ST(0);
#line 656 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        BitVector_Destroy(address);
        SvREADONLY_off(handle);
        sv_setiv(handle,(IV)NULL);
        SvREADONLY_on(handle);
    }
    /* else BIT_VECTOR_OBJECT_ERROR; */
}
#line 946 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_Copy); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Copy)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "Xref, Yref");
    {
	BitVector_Object	Xref = ST(0);
	BitVector_Object	Yref = ST(1);
#line 676 "Vector.xs"
{
    BitVector_Handle  Xhdl;
    BitVector_Address Xadr;
    BitVector_Handle  Yhdl;
    BitVector_Address Yadr;

    if ( BIT_VECTOR_OBJECT(Xref,Xhdl,Xadr) &&
         BIT_VECTOR_OBJECT(Yref,Yhdl,Yadr) )
    {
        BitVector_Copy(Xadr,Yadr);
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 979 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_Empty); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Empty)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "reference");
    {
	BitVector_Object	reference = ST(0);
#line 695 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        BitVector_Empty(address);
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 1008 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_Fill); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Fill)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "reference");
    {
	BitVector_Object	reference = ST(0);
#line 711 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        BitVector_Fill(address);
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 1037 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_Flip); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Flip)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "reference");
    {
	BitVector_Object	reference = ST(0);
#line 727 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        BitVector_Flip(address);
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 1066 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_Primes); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Primes)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "reference");
    {
	BitVector_Object	reference = ST(0);
#line 743 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        BitVector_Primes(address);
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 1095 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_Reverse); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Reverse)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "Xref, Yref");
    {
	BitVector_Object	Xref = ST(0);
	BitVector_Object	Yref = ST(1);
#line 760 "Vector.xs"
{
    BitVector_Handle  Xhdl;
    BitVector_Address Xadr;
    BitVector_Handle  Yhdl;
    BitVector_Address Yadr;

    if ( BIT_VECTOR_OBJECT(Xref,Xhdl,Xadr) &&
         BIT_VECTOR_OBJECT(Yref,Yhdl,Yadr) )
    {
        if (BV_BITS_(Xadr) == BV_BITS_(Yadr))
        {
            BitVector_Reverse(Xadr,Yadr);
        }
        else BIT_VECTOR_SIZE_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 1132 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_Interval_Empty); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Interval_Empty)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items != 3)
       croak_xs_usage(cv,  "reference, min, max");
    {
	BitVector_Object	reference = ST(0);
	BitVector_Scalar	min = ST(1);
	BitVector_Scalar	max = ST(2);
#line 787 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;
    N_int lower;
    N_int upper;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        if ( BIT_VECTOR_SCALAR(min,N_int,lower) &&
             BIT_VECTOR_SCALAR(max,N_int,upper) )
        {
            if      (lower >= BV_BITS_(address)) BIT_VECTOR_MIN_ERROR;
            else if (upper >= BV_BITS_(address)) BIT_VECTOR_MAX_ERROR;
            else if (lower >  upper)             BIT_VECTOR_ORDER_ERROR;
            else                       BitVector_Interval_Empty(address,lower,upper);
        }
        else BIT_VECTOR_SCALAR_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 1174 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_Interval_Fill); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Interval_Fill)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items != 3)
       croak_xs_usage(cv,  "reference, min, max");
    {
	BitVector_Object	reference = ST(0);
	BitVector_Scalar	min = ST(1);
	BitVector_Scalar	max = ST(2);
#line 817 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;
    N_int lower;
    N_int upper;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        if ( BIT_VECTOR_SCALAR(min,N_int,lower) &&
             BIT_VECTOR_SCALAR(max,N_int,upper) )
        {
            if      (lower >= BV_BITS_(address)) BIT_VECTOR_MIN_ERROR;
            else if (upper >= BV_BITS_(address)) BIT_VECTOR_MAX_ERROR;
            else if (lower >  upper)             BIT_VECTOR_ORDER_ERROR;
            else                       BitVector_Interval_Fill(address,lower,upper);
        }
        else BIT_VECTOR_SCALAR_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 1216 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_Interval_Flip); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Interval_Flip)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items != 3)
       croak_xs_usage(cv,  "reference, min, max");
    {
	BitVector_Object	reference = ST(0);
	BitVector_Scalar	min = ST(1);
	BitVector_Scalar	max = ST(2);
#line 847 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;
    N_int lower;
    N_int upper;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        if ( BIT_VECTOR_SCALAR(min,N_int,lower) &&
             BIT_VECTOR_SCALAR(max,N_int,upper) )
        {
            if      (lower >= BV_BITS_(address)) BIT_VECTOR_MIN_ERROR;
            else if (upper >= BV_BITS_(address)) BIT_VECTOR_MAX_ERROR;
            else if (lower >  upper)             BIT_VECTOR_ORDER_ERROR;
            else                       BitVector_Interval_Flip(address,lower,upper);
        }
        else BIT_VECTOR_SCALAR_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 1258 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_Interval_Reverse); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Interval_Reverse)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "reference, min, max");
    {
	BitVector_Object	reference = ST(0);
	BitVector_Scalar	min = ST(1);
	BitVector_Scalar	max = ST(2);
#line 875 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;
    N_int lower;
    N_int upper;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        if ( BIT_VECTOR_SCALAR(min,N_int,lower) &&
             BIT_VECTOR_SCALAR(max,N_int,upper) )
        {
            if      (lower >= BV_BITS_(address)) BIT_VECTOR_MIN_ERROR;
            else if (upper >= BV_BITS_(address)) BIT_VECTOR_MAX_ERROR;
            else if (lower >  upper)             BIT_VECTOR_ORDER_ERROR;
            else                       BitVector_Interval_Reverse(address,lower,upper);
        }
        else BIT_VECTOR_SCALAR_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 1299 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_Interval_Scan_inc); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Interval_Scan_inc)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "reference, start");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	BitVector_Object	reference = ST(0);
	BitVector_Scalar	start = ST(1);
#line 902 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;
    N_int first;
    N_int min;
    N_int max;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        if ( BIT_VECTOR_SCALAR(start,N_int,first) )
        {
            if (first < BV_BITS_(address))
            {
                if ( BitVector_interval_scan_inc(address,first,&min,&max) )
                {
                    EXTEND(sp,2);
                    PUSHs(sv_2mortal(newSViv((IV)min)));
                    PUSHs(sv_2mortal(newSViv((IV)max)));
                }
                /* else return empty list */
            }
            else BIT_VECTOR_START_ERROR;
        }
        else BIT_VECTOR_SCALAR_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 1348 "Vector.c"
	PUTBACK;
	return;
    }
}


XS(XS_Bit__Vector_Interval_Scan_dec); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Interval_Scan_dec)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "reference, start");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	BitVector_Object	reference = ST(0);
	BitVector_Scalar	start = ST(1);
#line 936 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;
    N_int first;
    N_int min;
    N_int max;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        if ( BIT_VECTOR_SCALAR(start,N_int,first) )
        {
            if (first < BV_BITS_(address))
            {
                if ( BitVector_interval_scan_dec(address,first,&min,&max) )
                {
                    EXTEND(sp,2);
                    PUSHs(sv_2mortal(newSViv((IV)min)));
                    PUSHs(sv_2mortal(newSViv((IV)max)));
                }
                /* else return empty list */
            }
            else BIT_VECTOR_START_ERROR;
        }
        else BIT_VECTOR_SCALAR_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 1398 "Vector.c"
	PUTBACK;
	return;
    }
}


XS(XS_Bit__Vector_Interval_Copy); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Interval_Copy)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 5)
       croak_xs_usage(cv,  "Xref, Yref, Xoffset, Yoffset, length");
    {
	BitVector_Object	Xref = ST(0);
	BitVector_Object	Yref = ST(1);
	BitVector_Scalar	Xoffset = ST(2);
	BitVector_Scalar	Yoffset = ST(3);
	BitVector_Scalar	length = ST(4);
#line 973 "Vector.xs"
{
    BitVector_Handle  Xhdl;
    BitVector_Address Xadr;
    BitVector_Handle  Yhdl;
    BitVector_Address Yadr;
    N_int Xoff;
    N_int Yoff;
    N_int len;

    if ( BIT_VECTOR_OBJECT(Xref,Xhdl,Xadr) &&
         BIT_VECTOR_OBJECT(Yref,Yhdl,Yadr) )
    {
        if ( BIT_VECTOR_SCALAR(Xoffset,N_int,Xoff) &&
             BIT_VECTOR_SCALAR(Yoffset,N_int,Yoff) &&
             BIT_VECTOR_SCALAR(length, N_int,len) )
        {
            if ((Xoff < BV_BITS_(Xadr)) and (Yoff < BV_BITS_(Yadr)))
            {
                if (len > 0) BitVector_Interval_Copy(Xadr,Yadr,Xoff,Yoff,len);
            }
            else BIT_VECTOR_OFFSET_ERROR;
        }
        else BIT_VECTOR_SCALAR_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 1448 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_Interval_Substitute); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Interval_Substitute)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 6)
       croak_xs_usage(cv,  "Xref, Yref, Xoffset, Xlength, Yoffset, Ylength");
    {
	BitVector_Object	Xref = ST(0);
	BitVector_Object	Yref = ST(1);
	BitVector_Scalar	Xoffset = ST(2);
	BitVector_Scalar	Xlength = ST(3);
	BitVector_Scalar	Yoffset = ST(4);
	BitVector_Scalar	Ylength = ST(5);
#line 1010 "Vector.xs"
{
    BitVector_Handle  Xhdl;
    BitVector_Address Xadr;
    BitVector_Handle  Yhdl;
    BitVector_Address Yadr;
    N_int Xoff;
    N_int Xlen;
    N_int Yoff;
    N_int Ylen;

    if ( BIT_VECTOR_OBJECT(Xref,Xhdl,Xadr) &&
         BIT_VECTOR_OBJECT(Yref,Yhdl,Yadr) )
    {
        if ( BIT_VECTOR_SCALAR(Xoffset,N_int,Xoff) &&
             BIT_VECTOR_SCALAR(Xlength,N_int,Xlen) &&
             BIT_VECTOR_SCALAR(Yoffset,N_int,Yoff) &&
             BIT_VECTOR_SCALAR(Ylength,N_int,Ylen) )
        {
            if ((Xoff <= BV_BITS_(Xadr)) and (Yoff <= BV_BITS_(Yadr)))
            {
                Xadr = BitVector_Interval_Substitute(Xadr,Yadr,Xoff,Xlen,Yoff,Ylen);
                SvREADONLY_off(Xhdl);
                sv_setiv(Xhdl,(IV)Xadr);
                SvREADONLY_on(Xhdl);
                if (Xadr == NULL) BIT_VECTOR_MEMORY_ERROR;
            }
            else BIT_VECTOR_OFFSET_ERROR;
        }
        else BIT_VECTOR_SCALAR_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 1504 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_is_empty); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_is_empty)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "reference");
    {
	BitVector_Object	reference = ST(0);
	boolean	RETVAL;
	dXSTARG;
#line 1048 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        RETVAL = BitVector_is_empty(address);
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 1535 "Vector.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bit__Vector_is_full); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_is_full)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "reference");
    {
	BitVector_Object	reference = ST(0);
	boolean	RETVAL;
	dXSTARG;
#line 1066 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        RETVAL = BitVector_is_full(address);
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 1567 "Vector.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bit__Vector_equal); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_equal)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "Xref, Yref");
    {
	BitVector_Object	Xref = ST(0);
	BitVector_Object	Yref = ST(1);
	boolean	RETVAL;
	dXSTARG;
#line 1085 "Vector.xs"
{
    BitVector_Handle  Xhdl;
    BitVector_Address Xadr;
    BitVector_Handle  Yhdl;
    BitVector_Address Yadr;

    if ( BIT_VECTOR_OBJECT(Xref,Xhdl,Xadr) &&
         BIT_VECTOR_OBJECT(Yref,Yhdl,Yadr) )
    {
        if (BV_BITS_(Xadr) == BV_BITS_(Yadr))
        {
            RETVAL = BitVector_equal(Xadr,Yadr);
        }
        else BIT_VECTOR_SIZE_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 1607 "Vector.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bit__Vector_Lexicompare); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Lexicompare)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "Xref, Yref");
    {
	BitVector_Object	Xref = ST(0);
	BitVector_Object	Yref = ST(1);
	Z_int	RETVAL;
	dXSTARG;
#line 1111 "Vector.xs"
{
    BitVector_Handle  Xhdl;
    BitVector_Address Xadr;
    BitVector_Handle  Yhdl;
    BitVector_Address Yadr;

    if ( BIT_VECTOR_OBJECT(Xref,Xhdl,Xadr) &&
         BIT_VECTOR_OBJECT(Yref,Yhdl,Yadr) )
    {
        if (BV_BITS_(Xadr) == BV_BITS_(Yadr))
        {
            RETVAL = BitVector_Lexicompare(Xadr,Yadr);
        }
        else BIT_VECTOR_SIZE_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 1647 "Vector.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bit__Vector_Compare); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Compare)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "Xref, Yref");
    {
	BitVector_Object	Xref = ST(0);
	BitVector_Object	Yref = ST(1);
	Z_int	RETVAL;
	dXSTARG;
#line 1137 "Vector.xs"
{
    BitVector_Handle  Xhdl;
    BitVector_Address Xadr;
    BitVector_Handle  Yhdl;
    BitVector_Address Yadr;

    if ( BIT_VECTOR_OBJECT(Xref,Xhdl,Xadr) &&
         BIT_VECTOR_OBJECT(Yref,Yhdl,Yadr) )
    {
        if (BV_BITS_(Xadr) == BV_BITS_(Yadr))
        {
            RETVAL = BitVector_Compare(Xadr,Yadr);
        }
        else BIT_VECTOR_SIZE_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 1687 "Vector.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bit__Vector_to_Hex); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_to_Hex)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "reference");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	BitVector_Object	reference = ST(0);
#line 1164 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;
    charptr string;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        string = BitVector_to_Hex(address);
        if (string != NULL)
        {
            EXTEND(sp,1);
            PUSHs(sv_2mortal(newSVpv((char *)string,0)));
            BitVector_Dispose(string);
        }
        else BIT_VECTOR_MEMORY_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 1728 "Vector.c"
	PUTBACK;
	return;
    }
}


XS(XS_Bit__Vector_from_Hex); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_from_Hex)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "reference, string");
    {
	BitVector_Object	reference = ST(0);
	BitVector_Scalar	string = ST(1);
#line 1191 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;
    charptr           pointer;
    BV_ErrCode        code;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        if ( BIT_VECTOR_STRING(string,pointer) )
        {
            if ((code = BitVector_from_Hex(address,pointer)))
                BIT_VECTOR_EXCEPTION(code);
        }
        else BIT_VECTOR_STRING_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 1767 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_to_Bin); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_to_Bin)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "reference");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	BitVector_Object	reference = ST(0);
#line 1214 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;
    charptr string;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        string = BitVector_to_Bin(address);
        if (string != NULL)
        {
            EXTEND(sp,1);
            PUSHs(sv_2mortal(newSVpv((char *)string,0)));
            BitVector_Dispose(string);
        }
        else BIT_VECTOR_MEMORY_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 1806 "Vector.c"
	PUTBACK;
	return;
    }
}


XS(XS_Bit__Vector_from_Bin); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_from_Bin)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "reference, string");
    {
	BitVector_Object	reference = ST(0);
	BitVector_Scalar	string = ST(1);
#line 1239 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;
    charptr           pointer;
    BV_ErrCode        code;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        if ( BIT_VECTOR_STRING(string,pointer) )
        {
            if ((code = BitVector_from_Bin(address,pointer)))
                BIT_VECTOR_EXCEPTION(code);
        }
        else BIT_VECTOR_STRING_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 1844 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_to_Dec); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_to_Dec)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "reference");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	BitVector_Object	reference = ST(0);
#line 1262 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;
    charptr string;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        string = BitVector_to_Dec(address);
        if (string != NULL)
        {
            EXTEND(sp,1);
            PUSHs(sv_2mortal(newSVpv((char *)string,0)));
            BitVector_Dispose(string);
        }
        else BIT_VECTOR_MEMORY_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 1883 "Vector.c"
	PUTBACK;
	return;
    }
}


XS(XS_Bit__Vector_from_Dec); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_from_Dec)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "reference, string");
    {
	BitVector_Object	reference = ST(0);
	BitVector_Scalar	string = ST(1);
#line 1287 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;
    charptr           pointer;
    BV_ErrCode        code;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        if ( BIT_VECTOR_STRING(string,pointer) )
        {
            if ((code = BitVector_from_Dec(address,pointer)))
                BIT_VECTOR_EXCEPTION(code);
        }
        else BIT_VECTOR_STRING_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 1921 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_to_Enum); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_to_Enum)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "reference");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	BitVector_Object	reference = ST(0);
#line 1312 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;
    charptr string;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        string = BitVector_to_Enum(address);
        if (string != NULL)
        {
            EXTEND(sp,1);
            PUSHs(sv_2mortal(newSVpv((char *)string,0)));
            BitVector_Dispose(string);
        }
        else BIT_VECTOR_MEMORY_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 1961 "Vector.c"
	PUTBACK;
	return;
    }
}


XS(XS_Bit__Vector_from_Enum); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_from_Enum)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "reference, string");
    {
	BitVector_Object	reference = ST(0);
	BitVector_Scalar	string = ST(1);
#line 1339 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;
    charptr           pointer;
    BV_ErrCode        code;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        if ( BIT_VECTOR_STRING(string,pointer) )
        {
            if ((code = BitVector_from_Enum(address,pointer)))
                BIT_VECTOR_EXCEPTION(code);
        }
        else BIT_VECTOR_STRING_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 2000 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_Bit_Off); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Bit_Off)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "reference, index");
    {
	BitVector_Object	reference = ST(0);
	BitVector_Scalar	index = ST(1);
#line 1363 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;
    N_int idx;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        if ( BIT_VECTOR_SCALAR(index,N_int,idx) )
        {
            if (idx < BV_BITS_(address))
            {
                BitVector_Bit_Off(address,idx);
            }
            else BIT_VECTOR_INDEX_ERROR;
        }
        else BIT_VECTOR_SCALAR_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 2039 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_Bit_On); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Bit_On)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "reference, index");
    {
	BitVector_Object	reference = ST(0);
	BitVector_Scalar	index = ST(1);
#line 1389 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;
    N_int idx;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        if ( BIT_VECTOR_SCALAR(index,N_int,idx) )
        {
            if (idx < BV_BITS_(address))
            {
                BitVector_Bit_On(address,idx);
            }
            else BIT_VECTOR_INDEX_ERROR;
        }
        else BIT_VECTOR_SCALAR_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 2078 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_bit_flip); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_bit_flip)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "reference, index");
    {
	BitVector_Object	reference = ST(0);
	BitVector_Scalar	index = ST(1);
	boolean	RETVAL;
	dXSTARG;
#line 1417 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;
    N_int idx;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        if ( BIT_VECTOR_SCALAR(index,N_int,idx) )
        {
            if (idx < BV_BITS_(address))
            {
                RETVAL = BitVector_bit_flip(address,idx);
            }
            else BIT_VECTOR_INDEX_ERROR;
        }
        else BIT_VECTOR_SCALAR_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 2120 "Vector.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bit__Vector_bit_test); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_bit_test)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "reference, index");
    {
	BitVector_Object	reference = ST(0);
	BitVector_Scalar	index = ST(1);
	boolean	RETVAL;
	dXSTARG;
#line 1448 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;
    N_int idx;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        if ( BIT_VECTOR_SCALAR(index,N_int,idx) )
        {
            if (idx < BV_BITS_(address))
            {
                RETVAL = BitVector_bit_test(address,idx);
            }
            else BIT_VECTOR_INDEX_ERROR;
        }
        else BIT_VECTOR_SCALAR_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 2163 "Vector.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bit__Vector_Bit_Copy); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Bit_Copy)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "reference, index, bit");
    {
	BitVector_Object	reference = ST(0);
	BitVector_Scalar	index = ST(1);
	BitVector_Scalar	bit = ST(2);
#line 1477 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;
    N_int idx;
    boolean b;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        if ( BIT_VECTOR_SCALAR(index,N_int,idx) &&
             BIT_VECTOR_SCALAR(bit,boolean,b) )
        {
            if (idx < BV_BITS_(address))
            {
                BitVector_Bit_Copy(address,idx,b);
            }
            else BIT_VECTOR_INDEX_ERROR;
        }
        else BIT_VECTOR_SCALAR_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 2206 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_LSB); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_LSB)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "reference, bit");
    {
	BitVector_Object	reference = ST(0);
	BitVector_Scalar	bit = ST(1);
#line 1505 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;
    boolean b;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        if ( BIT_VECTOR_SCALAR(bit,boolean,b) )
        {
            BitVector_LSB(address,b);
        }
        else BIT_VECTOR_SCALAR_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 2241 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_MSB); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_MSB)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "reference, bit");
    {
	BitVector_Object	reference = ST(0);
	BitVector_Scalar	bit = ST(1);
#line 1527 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;
    boolean b;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        if ( BIT_VECTOR_SCALAR(bit,boolean,b) )
        {
            BitVector_MSB(address,b);
        }
        else BIT_VECTOR_SCALAR_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 2276 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_lsb); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_lsb)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "reference");
    {
	BitVector_Object	reference = ST(0);
	boolean	RETVAL;
	dXSTARG;
#line 1548 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        RETVAL = BitVector_lsb_(address);
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 2307 "Vector.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bit__Vector_msb); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_msb)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "reference");
    {
	BitVector_Object	reference = ST(0);
	boolean	RETVAL;
	dXSTARG;
#line 1566 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        RETVAL = BitVector_msb_(address);
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 2339 "Vector.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bit__Vector_rotate_left); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_rotate_left)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "reference");
    {
	BitVector_Object	reference = ST(0);
	boolean	RETVAL;
	dXSTARG;
#line 1584 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        RETVAL = BitVector_rotate_left(address);
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 2371 "Vector.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bit__Vector_rotate_right); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_rotate_right)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "reference");
    {
	BitVector_Object	reference = ST(0);
	boolean	RETVAL;
	dXSTARG;
#line 1602 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        RETVAL = BitVector_rotate_right(address);
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 2403 "Vector.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bit__Vector_shift_left); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_shift_left)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "reference, carry");
    {
	BitVector_Object	reference = ST(0);
	BitVector_Scalar	carry = ST(1);
	boolean	RETVAL;
	dXSTARG;
#line 1621 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;
    boolean c;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        if ( BIT_VECTOR_SCALAR(carry,boolean,c) )
        {
            RETVAL = BitVector_shift_left(address,c);
        }
        else BIT_VECTOR_SCALAR_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 2441 "Vector.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bit__Vector_shift_right); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_shift_right)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "reference, carry");
    {
	BitVector_Object	reference = ST(0);
	BitVector_Scalar	carry = ST(1);
	boolean	RETVAL;
	dXSTARG;
#line 1645 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;
    boolean c;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        if ( BIT_VECTOR_SCALAR(carry,boolean,c) )
        {
            RETVAL = BitVector_shift_right(address,c);
        }
        else BIT_VECTOR_SCALAR_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 2479 "Vector.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bit__Vector_Move_Left); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Move_Left)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "reference, bits");
    {
	BitVector_Object	reference = ST(0);
	BitVector_Scalar	bits = ST(1);
#line 1669 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;
    N_int cnt;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        if ( BIT_VECTOR_SCALAR(bits,N_int,cnt) )
        {
            BitVector_Move_Left(address,cnt);
        }
        else BIT_VECTOR_SCALAR_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 2515 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_Move_Right); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Move_Right)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "reference, bits");
    {
	BitVector_Object	reference = ST(0);
	BitVector_Scalar	bits = ST(1);
#line 1691 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;
    N_int cnt;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        if ( BIT_VECTOR_SCALAR(bits,N_int,cnt) )
        {
            BitVector_Move_Right(address,cnt);
        }
        else BIT_VECTOR_SCALAR_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 2550 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_Insert); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Insert)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "reference, offset, count");
    {
	BitVector_Object	reference = ST(0);
	BitVector_Scalar	offset = ST(1);
	BitVector_Scalar	count = ST(2);
#line 1714 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;
    N_int off;
    N_int cnt;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        if ( BIT_VECTOR_SCALAR(offset,N_int,off) &&
             BIT_VECTOR_SCALAR(count,N_int,cnt) )
        {
            if (off < BV_BITS_(address))
            {
                BitVector_Insert(address,off,cnt,true);
            }
            else BIT_VECTOR_OFFSET_ERROR;
        }
        else BIT_VECTOR_SCALAR_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 2592 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_Delete); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Delete)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "reference, offset, count");
    {
	BitVector_Object	reference = ST(0);
	BitVector_Scalar	offset = ST(1);
	BitVector_Scalar	count = ST(2);
#line 1743 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;
    N_int off;
    N_int cnt;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        if ( BIT_VECTOR_SCALAR(offset,N_int,off) &&
             BIT_VECTOR_SCALAR(count,N_int,cnt) )
        {
            if (off < BV_BITS_(address))
            {
                BitVector_Delete(address,off,cnt,true);
            }
            else BIT_VECTOR_OFFSET_ERROR;
        }
        else BIT_VECTOR_SCALAR_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 2634 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_increment); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_increment)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "reference");
    {
	BitVector_Object	reference = ST(0);
	boolean	RETVAL;
	dXSTARG;
#line 1770 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        RETVAL = BitVector_increment(address);
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 2665 "Vector.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bit__Vector_decrement); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_decrement)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "reference");
    {
	BitVector_Object	reference = ST(0);
	boolean	RETVAL;
	dXSTARG;
#line 1788 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        RETVAL = BitVector_decrement(address);
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 2697 "Vector.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bit__Vector_add); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_add)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "Xref, Yref, Zref, carry");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	BitVector_Object	Xref = ST(0);
	BitVector_Object	Yref = ST(1);
	BitVector_Object	Zref = ST(2);
	BitVector_Scalar	carry = ST(3);
#line 1809 "Vector.xs"
{
    BitVector_Handle  Xhdl;
    BitVector_Address Xadr;
    BitVector_Handle  Yhdl;
    BitVector_Address Yadr;
    BitVector_Handle  Zhdl;
    BitVector_Address Zadr;
    boolean c;
    boolean v;

    if ( BIT_VECTOR_OBJECT(Xref,Xhdl,Xadr) &&
         BIT_VECTOR_OBJECT(Yref,Yhdl,Yadr) &&
         BIT_VECTOR_OBJECT(Zref,Zhdl,Zadr) )
    {
        if ( BIT_VECTOR_SCALAR(carry,boolean,c) )
        {
            if ((BV_BITS_(Xadr) == BV_BITS_(Yadr)) and (BV_BITS_(Xadr) == BV_BITS_(Zadr)))
            {
                v = BitVector_compute(Xadr,Yadr,Zadr,false,&c);
                if (GIMME_V == G_ARRAY)
                {
                    EXTEND(sp,2);
                    PUSHs(sv_2mortal(newSViv((IV)c)));
                    PUSHs(sv_2mortal(newSViv((IV)v)));
                }
                else
                {
                    EXTEND(sp,1);
                    PUSHs(sv_2mortal(newSViv((IV)c)));
                }
            }
            else BIT_VECTOR_SIZE_ERROR;
        }
        else BIT_VECTOR_SCALAR_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 2759 "Vector.c"
	PUTBACK;
	return;
    }
}


XS(XS_Bit__Vector_subtract); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_subtract)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items != 4)
       croak_xs_usage(cv,  "Xref, Yref, Zref, carry");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	BitVector_Object	Xref = ST(0);
	BitVector_Object	Yref = ST(1);
	BitVector_Object	Zref = ST(2);
	BitVector_Scalar	carry = ST(3);
#line 1857 "Vector.xs"
{
    BitVector_Handle  Xhdl;
    BitVector_Address Xadr;
    BitVector_Handle  Yhdl;
    BitVector_Address Yadr;
    BitVector_Handle  Zhdl;
    BitVector_Address Zadr;
    boolean c;
    boolean v;

    if ( BIT_VECTOR_OBJECT(Xref,Xhdl,Xadr) &&
         BIT_VECTOR_OBJECT(Yref,Yhdl,Yadr) &&
         BIT_VECTOR_OBJECT(Zref,Zhdl,Zadr) )
    {
        if ( BIT_VECTOR_SCALAR(carry,boolean,c) )
        {
            if ((BV_BITS_(Xadr) == BV_BITS_(Yadr)) and (BV_BITS_(Xadr) == BV_BITS_(Zadr)))
            {
                v = BitVector_compute(Xadr,Yadr,Zadr,true,&c);
                if (GIMME_V == G_ARRAY)
                {
                    EXTEND(sp,2);
                    PUSHs(sv_2mortal(newSViv((IV)c)));
                    PUSHs(sv_2mortal(newSViv((IV)v)));
                }
                else
                {
                    EXTEND(sp,1);
                    PUSHs(sv_2mortal(newSViv((IV)c)));
                }
            }
            else BIT_VECTOR_SIZE_ERROR;
        }
        else BIT_VECTOR_SCALAR_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 2822 "Vector.c"
	PUTBACK;
	return;
    }
}


XS(XS_Bit__Vector_inc); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_inc)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "Xref, Yref");
    {
	BitVector_Object	Xref = ST(0);
	BitVector_Object	Yref = ST(1);
	boolean	RETVAL;
	dXSTARG;
#line 1901 "Vector.xs"
{
    BitVector_Handle  Xhdl;
    BitVector_Address Xadr;
    BitVector_Handle  Yhdl;
    BitVector_Address Yadr;
    boolean c = true;

    if ( BIT_VECTOR_OBJECT(Xref,Xhdl,Xadr) &&
         BIT_VECTOR_OBJECT(Yref,Yhdl,Yadr) )
    {
        if (BV_BITS_(Xadr) == BV_BITS_(Yadr))
        {
            RETVAL = BitVector_compute(Xadr,Yadr,NULL,false,&c);
        }
        else BIT_VECTOR_SIZE_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 2863 "Vector.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bit__Vector_dec); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_dec)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "Xref, Yref");
    {
	BitVector_Object	Xref = ST(0);
	BitVector_Object	Yref = ST(1);
	boolean	RETVAL;
	dXSTARG;
#line 1928 "Vector.xs"
{
    BitVector_Handle  Xhdl;
    BitVector_Address Xadr;
    BitVector_Handle  Yhdl;
    BitVector_Address Yadr;
    boolean c = true;

    if ( BIT_VECTOR_OBJECT(Xref,Xhdl,Xadr) &&
         BIT_VECTOR_OBJECT(Yref,Yhdl,Yadr) )
    {
        if (BV_BITS_(Xadr) == BV_BITS_(Yadr))
        {
            RETVAL = BitVector_compute(Xadr,Yadr,NULL,true,&c);
        }
        else BIT_VECTOR_SIZE_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 2904 "Vector.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bit__Vector_Negate); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Negate)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "Xref, Yref");
    {
	BitVector_Object	Xref = ST(0);
	BitVector_Object	Yref = ST(1);
#line 1957 "Vector.xs"
{
    BitVector_Handle  Xhdl;
    BitVector_Address Xadr;
    BitVector_Handle  Yhdl;
    BitVector_Address Yadr;

    if ( BIT_VECTOR_OBJECT(Xref,Xhdl,Xadr) &&
         BIT_VECTOR_OBJECT(Yref,Yhdl,Yadr) )
    {
        if (BV_BITS_(Xadr) == BV_BITS_(Yadr))
        {
            BitVector_Negate(Xadr,Yadr);
        }
        else BIT_VECTOR_SIZE_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 2943 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_Absolute); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Absolute)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "Xref, Yref");
    {
	BitVector_Object	Xref = ST(0);
	BitVector_Object	Yref = ST(1);
#line 1983 "Vector.xs"
{
    BitVector_Handle  Xhdl;
    BitVector_Address Xadr;
    BitVector_Handle  Yhdl;
    BitVector_Address Yadr;

    if ( BIT_VECTOR_OBJECT(Xref,Xhdl,Xadr) &&
         BIT_VECTOR_OBJECT(Yref,Yhdl,Yadr) )
    {
        if (BV_BITS_(Xadr) == BV_BITS_(Yadr))
        {
            BitVector_Absolute(Xadr,Yadr);
        }
        else BIT_VECTOR_SIZE_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 2981 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_Sign); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Sign)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "reference");
    {
	BitVector_Object	reference = ST(0);
	Z_int	RETVAL;
	dXSTARG;
#line 2006 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        RETVAL = BitVector_Sign(address);
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 3012 "Vector.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bit__Vector_Multiply); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Multiply)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "Xref, Yref, Zref");
    {
	BitVector_Object	Xref = ST(0);
	BitVector_Object	Yref = ST(1);
	BitVector_Object	Zref = ST(2);
#line 2026 "Vector.xs"
{
    BitVector_Handle  Xhdl;
    BitVector_Address Xadr;
    BitVector_Handle  Yhdl;
    BitVector_Address Yadr;
    BitVector_Handle  Zhdl;
    BitVector_Address Zadr;
    BV_ErrCode        code;

    if ( BIT_VECTOR_OBJECT(Xref,Xhdl,Xadr) &&
         BIT_VECTOR_OBJECT(Yref,Yhdl,Yadr) &&
         BIT_VECTOR_OBJECT(Zref,Zhdl,Zadr) )
    {
        if ((BV_BITS_(Xadr) >= BV_BITS_(Yadr)) and (BV_BITS_(Yadr) == BV_BITS_(Zadr)))
        {
            if ((code = BitVector_Multiply(Xadr,Yadr,Zadr)))
                BIT_VECTOR_EXCEPTION(code);
        }
        else BIT_VECTOR_SIZE_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 3056 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_Divide); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Divide)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "Qref, Xref, Yref, Rref");
    {
	BitVector_Object	Qref = ST(0);
	BitVector_Object	Xref = ST(1);
	BitVector_Object	Yref = ST(2);
	BitVector_Object	Rref = ST(3);
#line 2057 "Vector.xs"
{
    BitVector_Handle  Qhdl;
    BitVector_Address Qadr;
    BitVector_Handle  Xhdl;
    BitVector_Address Xadr;
    BitVector_Handle  Yhdl;
    BitVector_Address Yadr;
    BitVector_Handle  Rhdl;
    BitVector_Address Radr;
    BV_ErrCode        code;

    if ( BIT_VECTOR_OBJECT(Qref,Qhdl,Qadr) &&
         BIT_VECTOR_OBJECT(Xref,Xhdl,Xadr) &&
         BIT_VECTOR_OBJECT(Yref,Yhdl,Yadr) &&
         BIT_VECTOR_OBJECT(Rref,Rhdl,Radr) )
    {
        if ((code = BitVector_Divide(Qadr,Xadr,Yadr,Radr)))
            BIT_VECTOR_EXCEPTION(code);
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 3099 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_GCD); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_GCD)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    {
#line 2083 "Vector.xs"
{
    BitVector_Object  Uref;
    BitVector_Handle  Uhdl;
    BitVector_Address Uadr;
    BitVector_Object  Vref;
    BitVector_Handle  Vhdl;
    BitVector_Address Vadr;
    BitVector_Object  Wref;
    BitVector_Handle  Whdl;
    BitVector_Address Wadr;
    BitVector_Object  Xref;
    BitVector_Handle  Xhdl;
    BitVector_Address Xadr;
    BitVector_Object  Yref;
    BitVector_Handle  Yhdl;
    BitVector_Address Yadr;
    BV_ErrCode        code;

    if      (items == 3)
    {
        Uref = ST(0);
        Xref = ST(1);
        Yref = ST(2);
        if ( BIT_VECTOR_OBJECT(Uref,Uhdl,Uadr) &&
             BIT_VECTOR_OBJECT(Xref,Xhdl,Xadr) &&
             BIT_VECTOR_OBJECT(Yref,Yhdl,Yadr) )
        {
            if ((code = BitVector_GCD(Uadr,Xadr,Yadr)))
                BIT_VECTOR_EXCEPTION(code);
        }
        else BIT_VECTOR_OBJECT_ERROR;
    }
    else if (items == 5)
    {
        Uref = ST(0);
        Vref = ST(1);
        Wref = ST(2);
        Xref = ST(3);
        Yref = ST(4);
        if ( BIT_VECTOR_OBJECT(Uref,Uhdl,Uadr) &&
             BIT_VECTOR_OBJECT(Vref,Vhdl,Vadr) &&
             BIT_VECTOR_OBJECT(Wref,Whdl,Wadr) &&
             BIT_VECTOR_OBJECT(Xref,Xhdl,Xadr) &&
             BIT_VECTOR_OBJECT(Yref,Yhdl,Yadr) )
        {
            if ((code = BitVector_GCD2(Uadr,Vadr,Wadr,Xadr,Yadr)))
                BIT_VECTOR_EXCEPTION(code);
        }
        else BIT_VECTOR_OBJECT_ERROR;
    }
    else croak("Usage: %s(Uref[,Vref,Wref],Xref,Yref)", GvNAME(CvGV(cv)));
}
#line 3168 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_Power); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Power)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "Xref, Yref, Zref");
    {
	BitVector_Object	Xref = ST(0);
	BitVector_Object	Yref = ST(1);
	BitVector_Object	Zref = ST(2);
#line 2143 "Vector.xs"
{
    BitVector_Handle  Xhdl;
    BitVector_Address Xadr;
    BitVector_Handle  Yhdl;
    BitVector_Address Yadr;
    BitVector_Handle  Zhdl;
    BitVector_Address Zadr;
    BV_ErrCode        code;

    if ( BIT_VECTOR_OBJECT(Xref,Xhdl,Xadr) &&
         BIT_VECTOR_OBJECT(Yref,Yhdl,Yadr) &&
         BIT_VECTOR_OBJECT(Zref,Zhdl,Zadr) )
    {
        if ((code = BitVector_Power(Xadr,Yadr,Zadr)))
            BIT_VECTOR_EXCEPTION(code);
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 3207 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_Block_Store); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Block_Store)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "reference, buffer");
    {
	BitVector_Object	reference = ST(0);
	BitVector_Scalar	buffer = ST(1);
#line 2168 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;
    charptr string;
    N_int length;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        if ( BIT_VECTOR_BUFFER(buffer,string,length) )
        {
            BitVector_Block_Store(address,string,length);
        }
        else BIT_VECTOR_STRING_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 3243 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_Block_Read); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Block_Read)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "reference");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	BitVector_Object	reference = ST(0);
#line 2190 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;
    charptr string;
    N_int length;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        string = BitVector_Block_Read(address,&length);
        if (string != NULL)
        {
            EXTEND(sp,1);
            PUSHs(sv_2mortal(newSVpv((char *)string,length)));
            BitVector_Dispose(string);
        }
        else BIT_VECTOR_MEMORY_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 3283 "Vector.c"
	PUTBACK;
	return;
    }
}


XS(XS_Bit__Vector_Word_Size); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Word_Size)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "reference");
    {
	BitVector_Object	reference = ST(0);
	N_int	RETVAL;
	dXSTARG;
#line 2215 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        RETVAL = BV_SIZE_(address);
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 3315 "Vector.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bit__Vector_Word_Store); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Word_Store)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "reference, offset, value");
    {
	BitVector_Object	reference = ST(0);
	BitVector_Scalar	offset = ST(1);
	BitVector_Scalar	value = ST(2);
#line 2235 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;
    N_int off;
    N_int val;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        if ( BIT_VECTOR_SCALAR(offset,N_int,off) &&
             BIT_VECTOR_SCALAR(value,N_int,val) )
        {
            if (off < BV_SIZE_(address))
            {
                BitVector_Word_Store(address,off,val);
            }
            else BIT_VECTOR_OFFSET_ERROR;
        }
        else BIT_VECTOR_SCALAR_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 3358 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_Word_Read); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Word_Read)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "reference, offset");
    {
	BitVector_Object	reference = ST(0);
	BitVector_Scalar	offset = ST(1);
	N_int	RETVAL;
	dXSTARG;
#line 2263 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;
    N_int off;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        if ( BIT_VECTOR_SCALAR(offset,N_int,off) )
        {
            if (off < BV_SIZE_(address))
            {
                RETVAL = BitVector_Word_Read(address,off);
            }
            else BIT_VECTOR_OFFSET_ERROR;
        }
        else BIT_VECTOR_SCALAR_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 3399 "Vector.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bit__Vector_Word_List_Store); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Word_List_Store)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "reference, ...");
    {
	BitVector_Object	reference = ST(0);
#line 2290 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;
    BitVector_Scalar  scalar;
    N_int offset;
    N_int value;
    N_int size;
    I32 index;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        size = BV_SIZE_(address);
        for ( offset = 0, index = 1;
            ((offset < size) and (index < items)); offset++, index++ )
        {
            scalar = ST(index);
            if ( BIT_VECTOR_SCALAR(scalar,N_int,value) )
            {
                BitVector_Word_Store(address,offset,value);
            }
            else BIT_VECTOR_SCALAR_ERROR;
        }
        for ( ; (offset < size); offset++ )
        {
            BitVector_Word_Store(address,offset,0);
        }
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 3448 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_Word_List_Read); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Word_List_Read)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "reference");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	BitVector_Object	reference = ST(0);
#line 2325 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;
    N_int offset;
    N_int value;
    N_int size;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        size = BV_SIZE_(address);
        EXTEND(sp,(int)size);
        for ( offset = 0; (offset < size); offset++ )
        {
            value = BitVector_Word_Read(address,offset);
            PUSHs(sv_2mortal(newSViv((IV)value)));
        }
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 3488 "Vector.c"
	PUTBACK;
	return;
    }
}


XS(XS_Bit__Vector_Word_Insert); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Word_Insert)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "reference, offset, count");
    {
	BitVector_Object	reference = ST(0);
	BitVector_Scalar	offset = ST(1);
	BitVector_Scalar	count = ST(2);
#line 2352 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;
    N_int off;
    N_int cnt;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        if ( BIT_VECTOR_SCALAR(offset,N_int,off) &&
             BIT_VECTOR_SCALAR(count,N_int,cnt) )
        {
            if (off < BV_SIZE_(address))
            {
                BitVector_Word_Insert(address,off,cnt,true);
            }
            else BIT_VECTOR_OFFSET_ERROR;
        }
        else BIT_VECTOR_SCALAR_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 3531 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_Word_Delete); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Word_Delete)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "reference, offset, count");
    {
	BitVector_Object	reference = ST(0);
	BitVector_Scalar	offset = ST(1);
	BitVector_Scalar	count = ST(2);
#line 2381 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;
    N_int off;
    N_int cnt;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        if ( BIT_VECTOR_SCALAR(offset,N_int,off) &&
             BIT_VECTOR_SCALAR(count,N_int,cnt) )
        {
            if (off < BV_SIZE_(address))
            {
                BitVector_Word_Delete(address,off,cnt,true);
            }
            else BIT_VECTOR_OFFSET_ERROR;
        }
        else BIT_VECTOR_SCALAR_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 3573 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_Chunk_Store); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Chunk_Store)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "reference, chunksize, offset, value");
    {
	BitVector_Object	reference = ST(0);
	BitVector_Scalar	chunksize = ST(1);
	BitVector_Scalar	offset = ST(2);
	BitVector_Scalar	value = ST(3);
#line 2411 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;
    N_int bits;
    N_int off;
    N_long val;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        if ( BIT_VECTOR_SCALAR(chunksize,N_int,bits) &&
             BIT_VECTOR_SCALAR(offset,N_int,off) &&
             BIT_VECTOR_SCALAR(value,N_long,val) )
        {
            if ((bits > 0) and (bits <= BitVector_Long_Bits()))
            {
                if (off < BV_BITS_(address))
                {
                    BitVector_Chunk_Store(address,bits,off,val);
                }
                else BIT_VECTOR_OFFSET_ERROR;
            }
            else BIT_VECTOR_CHUNK_ERROR;
        }
        else BIT_VECTOR_SCALAR_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 3622 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_Chunk_Read); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Chunk_Read)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "reference, chunksize, offset");
    {
	BitVector_Object	reference = ST(0);
	BitVector_Scalar	chunksize = ST(1);
	BitVector_Scalar	offset = ST(2);
	N_long	RETVAL;
	dXSTARG;
#line 2446 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;
    N_int bits;
    N_int off;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        if ( BIT_VECTOR_SCALAR(chunksize,N_int,bits) &&
             BIT_VECTOR_SCALAR(offset,N_int,off) )
        {
            if ((bits > 0) and (bits <= BitVector_Long_Bits()))
            {
                if (off < BV_BITS_(address))
                {
                    RETVAL = BitVector_Chunk_Read(address,bits,off);
                }
                else BIT_VECTOR_OFFSET_ERROR;
            }
            else BIT_VECTOR_CHUNK_ERROR;
        }
        else BIT_VECTOR_SCALAR_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 3670 "Vector.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bit__Vector_Chunk_List_Store); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Chunk_List_Store)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "reference, chunksize, ...");
    {
	BitVector_Object	reference = ST(0);
	BitVector_Scalar	chunksize = ST(1);
#line 2480 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;
    BitVector_Scalar  scalar;
    N_int chunkspan;
    N_long chunkmask;
    N_long mask;
    N_long chunk;
    N_long value;
    N_int chunkbits;
    N_int wordbits;
    N_int wordsize;
    N_int offset;
    N_int size;
    N_int bits;
    I32 index;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        if ( BIT_VECTOR_SCALAR(chunksize,N_int,chunkspan) )
        {
            if ((chunkspan > 0) and (chunkspan <= BitVector_Long_Bits()))
            {
                wordsize = BitVector_Word_Bits();
                size = BV_SIZE_(address);
                chunkmask = ~((~0L << (chunkspan-1)) << 1); /* C bug work-around */
                chunk = 0L;
                value = 0L;
                index = 2;
                offset = 0;
                wordbits = 0;
                chunkbits = 0;
                while (offset < size)
                {
                    if ((chunkbits == 0) and (index < items))
                    {
                        scalar = ST(index);
                        if ( BIT_VECTOR_SCALAR(scalar,N_long,chunk) )
                        {
                            chunk &= chunkmask;
                            chunkbits = chunkspan;
                            index++;
                        }
                        else BIT_VECTOR_SCALAR_ERROR;
                    }
                    bits = wordsize - wordbits;
                    if (chunkbits <= bits)
                    {
                        chunk <<= wordbits;
                        value |= chunk;
                        wordbits += chunkbits;
                        chunk = 0L;
                        chunkbits = 0;
                    }
                    else
                    {
                        mask = ~(~0L << bits);
                        mask &= chunk;
                        mask <<= wordbits;
                        value |= mask;
                        wordbits += bits;
                        chunk >>= bits;
                        chunkbits -= bits;
                    }
                    if ((wordbits >= wordsize) or (index >= items))
                    {
                        BitVector_Word_Store(address,offset,(N_int)value);
                        value = 0L;
                        wordbits = 0;
                        offset++;
                    }
                }
            }
            else BIT_VECTOR_CHUNK_ERROR;
        }
        else BIT_VECTOR_SCALAR_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 3770 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_Chunk_List_Read); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Chunk_List_Read)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "reference, chunksize");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	BitVector_Object	reference = ST(0);
	BitVector_Scalar	chunksize = ST(1);
#line 2566 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;
    N_int chunkspan;
    N_long chunk;
    N_long value;
    N_long mask;
    N_int chunkbits;
    N_int wordbits;
    N_int wordsize;
    N_int length;
    N_int index;
    N_int offset;
    N_int size;
    N_int bits;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        if ( BIT_VECTOR_SCALAR(chunksize,N_int,chunkspan) )
        {
            if ((chunkspan > 0) and (chunkspan <= BitVector_Long_Bits()))
            {
                wordsize = BitVector_Word_Bits();
                bits = BV_BITS_(address);
                size = BV_SIZE_(address);
                length = (N_int) (bits / chunkspan);
                if ((length * chunkspan) < bits) length++;
                EXTEND(sp,(int)length);
                chunk = 0L;
                value = 0L;
                index = 0;
                offset = 0;
                wordbits = 0;
                chunkbits = 0;
                while (index < length)
                {
                    if ((wordbits == 0) and (offset < size))
                    {
                        value = (N_long) BitVector_Word_Read(address,offset);
                        wordbits = wordsize;
                        offset++;
                    }
                    bits = chunkspan - chunkbits;
                    if (wordbits <= bits)
                    {
                        value <<= chunkbits;
                        chunk |= value;
                        chunkbits += wordbits;
                        value = 0L;
                        wordbits = 0;
                    }
                    else
                    {
                        mask = ~(~0L << bits);
                        mask &= value;
                        mask <<= chunkbits;
                        chunk |= mask;
                        chunkbits += bits;
                        value >>= bits;
                        wordbits -= bits;
                    }
                    if ((chunkbits >= chunkspan) or
                        ((offset >= size) and (chunkbits > 0)))
                    {
                        PUSHs(sv_2mortal(newSViv((IV)chunk)));
                        chunk = 0L;
                        chunkbits = 0;
                        index++;
                    }
                }
            }
            else BIT_VECTOR_CHUNK_ERROR;
        }
        else BIT_VECTOR_SCALAR_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 3869 "Vector.c"
	PUTBACK;
	return;
    }
}


XS(XS_Bit__Vector_Index_List_Remove); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Index_List_Remove)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "reference, ...");
    {
	BitVector_Object	reference = ST(0);
#line 2649 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;
    BitVector_Scalar  scalar;
    N_int value;
    N_int bits;
    I32 index;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        bits = BV_BITS_(address);
        for ( index = 1; index < items; index++ )
        {
            scalar = ST(index);
            if ( BIT_VECTOR_SCALAR(scalar,N_int,value) )
            {
                if (value < bits)
                {
                    BitVector_Bit_Off(address,value);
                }
                else BIT_VECTOR_INDEX_ERROR;
            }
            else BIT_VECTOR_SCALAR_ERROR;
        }
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 3916 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_Index_List_Store); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Index_List_Store)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "reference, ...");
    {
	BitVector_Object	reference = ST(0);
#line 2682 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;
    BitVector_Scalar  scalar;
    N_int value;
    N_int bits;
    I32 index;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        bits = BV_BITS_(address);
        for ( index = 1; index < items; index++ )
        {
            scalar = ST(index);
            if ( BIT_VECTOR_SCALAR(scalar,N_int,value) )
            {
                if (value < bits)
                {
                    BitVector_Bit_On(address,value);
                }
                else BIT_VECTOR_INDEX_ERROR;
            }
            else BIT_VECTOR_SCALAR_ERROR;
        }
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 3962 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_Index_List_Read); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Index_List_Read)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "reference");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	BitVector_Object	reference = ST(0);
#line 2715 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;
    N_int size;
    N_int bits;
    N_int norm;
    N_int base;
    N_int word;
    N_int index;
    N_int value;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        size = BV_SIZE_(address);
        bits = BitVector_Word_Bits();
        norm = Set_Norm(address);
        if (norm > 0)
        {
            EXTEND(sp,(int)norm);
            for ( base = word = 0; word < size; word++, base += bits )
            {
                index = base;
                value = BitVector_Word_Read(address,word);
                while (value)
                {
                    if (value AND 0x0001)
                      PUSHs(sv_2mortal(newSViv((IV)index)));
                    value >>= 1;
                    index++;
                }
            }
        }
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 4018 "Vector.c"
	PUTBACK;
	return;
    }
}


XS(XS_Bit__Vector_Union); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Union)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items != 3)
       croak_xs_usage(cv,  "Xref, Yref, Zref");
    {
	BitVector_Object	Xref = ST(0);
	BitVector_Object	Yref = ST(1);
	BitVector_Object	Zref = ST(2);
#line 2763 "Vector.xs"
{
    BitVector_Handle  Xhdl;
    BitVector_Address Xadr;
    BitVector_Handle  Yhdl;
    BitVector_Address Yadr;
    BitVector_Handle  Zhdl;
    BitVector_Address Zadr;

    if ( BIT_VECTOR_OBJECT(Xref,Xhdl,Xadr) &&
         BIT_VECTOR_OBJECT(Yref,Yhdl,Yadr) &&
         BIT_VECTOR_OBJECT(Zref,Zhdl,Zadr) )
    {
        if ((BV_BITS_(Xadr) == BV_BITS_(Yadr)) and (BV_BITS_(Xadr) == BV_BITS_(Zadr)))
        {
            Set_Union(Xadr,Yadr,Zadr);
        }
        else BIT_VECTOR_SET_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 4061 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_Intersection); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Intersection)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items != 3)
       croak_xs_usage(cv,  "Xref, Yref, Zref");
    {
	BitVector_Object	Xref = ST(0);
	BitVector_Object	Yref = ST(1);
	BitVector_Object	Zref = ST(2);
#line 2793 "Vector.xs"
{
    BitVector_Handle  Xhdl;
    BitVector_Address Xadr;
    BitVector_Handle  Yhdl;
    BitVector_Address Yadr;
    BitVector_Handle  Zhdl;
    BitVector_Address Zadr;

    if ( BIT_VECTOR_OBJECT(Xref,Xhdl,Xadr) &&
         BIT_VECTOR_OBJECT(Yref,Yhdl,Yadr) &&
         BIT_VECTOR_OBJECT(Zref,Zhdl,Zadr) )
    {
        if ((BV_BITS_(Xadr) == BV_BITS_(Yadr)) and (BV_BITS_(Xadr) == BV_BITS_(Zadr)))
        {
            Set_Intersection(Xadr,Yadr,Zadr);
        }
        else BIT_VECTOR_SET_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 4103 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_Difference); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Difference)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items != 3)
       croak_xs_usage(cv,  "Xref, Yref, Zref");
    {
	BitVector_Object	Xref = ST(0);
	BitVector_Object	Yref = ST(1);
	BitVector_Object	Zref = ST(2);
#line 2823 "Vector.xs"
{
    BitVector_Handle  Xhdl;
    BitVector_Address Xadr;
    BitVector_Handle  Yhdl;
    BitVector_Address Yadr;
    BitVector_Handle  Zhdl;
    BitVector_Address Zadr;

    if ( BIT_VECTOR_OBJECT(Xref,Xhdl,Xadr) &&
         BIT_VECTOR_OBJECT(Yref,Yhdl,Yadr) &&
         BIT_VECTOR_OBJECT(Zref,Zhdl,Zadr) )
    {
        if ((BV_BITS_(Xadr) == BV_BITS_(Yadr)) and (BV_BITS_(Xadr) == BV_BITS_(Zadr)))
        {
            Set_Difference(Xadr,Yadr,Zadr);
        }
        else BIT_VECTOR_SET_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 4145 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_ExclusiveOr); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_ExclusiveOr)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items != 3)
       croak_xs_usage(cv,  "Xref, Yref, Zref");
    {
	BitVector_Object	Xref = ST(0);
	BitVector_Object	Yref = ST(1);
	BitVector_Object	Zref = ST(2);
#line 2853 "Vector.xs"
{
    BitVector_Handle  Xhdl;
    BitVector_Address Xadr;
    BitVector_Handle  Yhdl;
    BitVector_Address Yadr;
    BitVector_Handle  Zhdl;
    BitVector_Address Zadr;

    if ( BIT_VECTOR_OBJECT(Xref,Xhdl,Xadr) &&
         BIT_VECTOR_OBJECT(Yref,Yhdl,Yadr) &&
         BIT_VECTOR_OBJECT(Zref,Zhdl,Zadr) )
    {
        if ((BV_BITS_(Xadr) == BV_BITS_(Yadr)) and (BV_BITS_(Xadr) == BV_BITS_(Zadr)))
        {
            Set_ExclusiveOr(Xadr,Yadr,Zadr);
        }
        else BIT_VECTOR_SET_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 4187 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_Complement); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Complement)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "Xref, Yref");
    {
	BitVector_Object	Xref = ST(0);
	BitVector_Object	Yref = ST(1);
#line 2882 "Vector.xs"
{
    BitVector_Handle  Xhdl;
    BitVector_Address Xadr;
    BitVector_Handle  Yhdl;
    BitVector_Address Yadr;

    if ( BIT_VECTOR_OBJECT(Xref,Xhdl,Xadr) &&
         BIT_VECTOR_OBJECT(Yref,Yhdl,Yadr) )
    {
        if (BV_BITS_(Xadr) == BV_BITS_(Yadr))
        {
            Set_Complement(Xadr,Yadr);
        }
        else BIT_VECTOR_SET_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 4225 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_subset); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_subset)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "Xref, Yref");
    {
	BitVector_Object	Xref = ST(0);
	BitVector_Object	Yref = ST(1);
	boolean	RETVAL;
	dXSTARG;
#line 2908 "Vector.xs"
{
    BitVector_Handle  Xhdl;
    BitVector_Address Xadr;
    BitVector_Handle  Yhdl;
    BitVector_Address Yadr;

    if ( BIT_VECTOR_OBJECT(Xref,Xhdl,Xadr) &&
         BIT_VECTOR_OBJECT(Yref,Yhdl,Yadr) )
    {
        if (BV_BITS_(Xadr) == BV_BITS_(Yadr))
        {
            RETVAL = Set_subset(Xadr,Yadr);
        }
        else BIT_VECTOR_SET_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 4265 "Vector.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bit__Vector_Norm); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Norm)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "reference");
    {
	BitVector_Object	reference = ST(0);
	N_int	RETVAL;
	dXSTARG;
#line 2933 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        RETVAL = Set_Norm(address);
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 4297 "Vector.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bit__Vector_Norm2); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Norm2)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "reference");
    {
	BitVector_Object	reference = ST(0);
	N_int	RETVAL;
	dXSTARG;
#line 2951 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        RETVAL = Set_Norm2(address);
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 4329 "Vector.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bit__Vector_Norm3); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Norm3)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "reference");
    {
	BitVector_Object	reference = ST(0);
	N_int	RETVAL;
	dXSTARG;
#line 2969 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        RETVAL = Set_Norm3(address);
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 4361 "Vector.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bit__Vector_Min); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Min)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "reference");
    {
	BitVector_Object	reference = ST(0);
	Z_long	RETVAL;
	dXSTARG;
#line 2987 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        RETVAL = Set_Min(address);
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 4393 "Vector.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bit__Vector_Max); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Max)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "reference");
    {
	BitVector_Object	reference = ST(0);
	Z_long	RETVAL;
	dXSTARG;
#line 3005 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        RETVAL = Set_Max(address);
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 4425 "Vector.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bit__Vector_Multiplication); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Multiplication)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 9)
       croak_xs_usage(cv,  "Xref, Xrows, Xcols, Yref, Yrows, Ycols, Zref, Zrows, Zcols");
    {
	BitVector_Object	Xref = ST(0);
	BitVector_Scalar	Xrows = ST(1);
	BitVector_Scalar	Xcols = ST(2);
	BitVector_Object	Yref = ST(3);
	BitVector_Scalar	Yrows = ST(4);
	BitVector_Scalar	Ycols = ST(5);
	BitVector_Object	Zref = ST(6);
	BitVector_Scalar	Zrows = ST(7);
	BitVector_Scalar	Zcols = ST(8);
#line 3034 "Vector.xs"
{
    BitVector_Handle  Xhdl;
    BitVector_Address Xadr;
    BitVector_Handle  Yhdl;
    BitVector_Address Yadr;
    BitVector_Handle  Zhdl;
    BitVector_Address Zadr;
    N_int rowsX;
    N_int colsX;
    N_int rowsY;
    N_int colsY;
    N_int rowsZ;
    N_int colsZ;

    if ( BIT_VECTOR_OBJECT(Xref,Xhdl,Xadr) &&
         BIT_VECTOR_OBJECT(Yref,Yhdl,Yadr) &&
         BIT_VECTOR_OBJECT(Zref,Zhdl,Zadr) )
    {
        if ( BIT_VECTOR_SCALAR(Xrows,N_int,rowsX) &&
             BIT_VECTOR_SCALAR(Xcols,N_int,colsX) &&
             BIT_VECTOR_SCALAR(Yrows,N_int,rowsY) &&
             BIT_VECTOR_SCALAR(Ycols,N_int,colsY) &&
             BIT_VECTOR_SCALAR(Zrows,N_int,rowsZ) &&
             BIT_VECTOR_SCALAR(Zcols,N_int,colsZ) )
        {
            if ((colsY == rowsZ) and (rowsX == rowsY) and (colsX == colsZ) and
                (BV_BITS_(Xadr) == rowsX*colsX) and
                (BV_BITS_(Yadr) == rowsY*colsY) and
                (BV_BITS_(Zadr) == rowsZ*colsZ))
            {
                Matrix_Multiplication(Xadr,rowsX,colsX,
                                      Yadr,rowsY,colsY,
                                      Zadr,rowsZ,colsZ);
            }
            else BIT_VECTOR_MATRIX_ERROR;
        }
        else BIT_VECTOR_SCALAR_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 4493 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_Product); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Product)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 9)
       croak_xs_usage(cv,  "Xref, Xrows, Xcols, Yref, Yrows, Ycols, Zref, Zrows, Zcols");
    {
	BitVector_Object	Xref = ST(0);
	BitVector_Scalar	Xrows = ST(1);
	BitVector_Scalar	Xcols = ST(2);
	BitVector_Object	Yref = ST(3);
	BitVector_Scalar	Yrows = ST(4);
	BitVector_Scalar	Ycols = ST(5);
	BitVector_Object	Zref = ST(6);
	BitVector_Scalar	Zrows = ST(7);
	BitVector_Scalar	Zcols = ST(8);
#line 3088 "Vector.xs"
{
    BitVector_Handle  Xhdl;
    BitVector_Address Xadr;
    BitVector_Handle  Yhdl;
    BitVector_Address Yadr;
    BitVector_Handle  Zhdl;
    BitVector_Address Zadr;
    N_int rowsX;
    N_int colsX;
    N_int rowsY;
    N_int colsY;
    N_int rowsZ;
    N_int colsZ;

    if ( BIT_VECTOR_OBJECT(Xref,Xhdl,Xadr) &&
         BIT_VECTOR_OBJECT(Yref,Yhdl,Yadr) &&
         BIT_VECTOR_OBJECT(Zref,Zhdl,Zadr) )
    {
        if ( BIT_VECTOR_SCALAR(Xrows,N_int,rowsX) &&
             BIT_VECTOR_SCALAR(Xcols,N_int,colsX) &&
             BIT_VECTOR_SCALAR(Yrows,N_int,rowsY) &&
             BIT_VECTOR_SCALAR(Ycols,N_int,colsY) &&
             BIT_VECTOR_SCALAR(Zrows,N_int,rowsZ) &&
             BIT_VECTOR_SCALAR(Zcols,N_int,colsZ) )
        {
            if ((colsY == rowsZ) and (rowsX == rowsY) and (colsX == colsZ) and
                (BV_BITS_(Xadr) == rowsX*colsX) and
                (BV_BITS_(Yadr) == rowsY*colsY) and
                (BV_BITS_(Zadr) == rowsZ*colsZ))
            {
                Matrix_Product(Xadr,rowsX,colsX,
                               Yadr,rowsY,colsY,
                               Zadr,rowsZ,colsZ);
            }
            else BIT_VECTOR_MATRIX_ERROR;
        }
        else BIT_VECTOR_SCALAR_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 4560 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_Closure); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Closure)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "reference, rows, cols");
    {
	BitVector_Object	reference = ST(0);
	BitVector_Scalar	rows = ST(1);
	BitVector_Scalar	cols = ST(2);
#line 3136 "Vector.xs"
{
    BitVector_Handle  handle;
    BitVector_Address address;
    N_int r;
    N_int c;

    if ( BIT_VECTOR_OBJECT(reference,handle,address) )
    {
        if ( BIT_VECTOR_SCALAR(rows,N_int,r) &&
             BIT_VECTOR_SCALAR(cols,N_int,c) )
        {
            if (BV_BITS_(address) == r*c)
            {
                if (r == c)
                {
                    Matrix_Closure(address,r,c);
                }
                else BIT_VECTOR_SHAPE_ERROR;
            }
            else BIT_VECTOR_MATRIX_ERROR;
        }
        else BIT_VECTOR_SCALAR_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 4606 "Vector.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bit__Vector_Transpose); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bit__Vector_Transpose)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 6)
       croak_xs_usage(cv,  "Xref, Xrows, Xcols, Yref, Yrows, Ycols");
    {
	BitVector_Object	Xref = ST(0);
	BitVector_Scalar	Xrows = ST(1);
	BitVector_Scalar	Xcols = ST(2);
	BitVector_Object	Yref = ST(3);
	BitVector_Scalar	Yrows = ST(4);
	BitVector_Scalar	Ycols = ST(5);
#line 3172 "Vector.xs"
{
    BitVector_Handle  Xhdl;
    BitVector_Address Xadr;
    BitVector_Handle  Yhdl;
    BitVector_Address Yadr;
    N_int rowsX;
    N_int colsX;
    N_int rowsY;
    N_int colsY;

    if ( BIT_VECTOR_OBJECT(Xref,Xhdl,Xadr) &&
         BIT_VECTOR_OBJECT(Yref,Yhdl,Yadr) )
    {
        if ( BIT_VECTOR_SCALAR(Xrows,N_int,rowsX) &&
             BIT_VECTOR_SCALAR(Xcols,N_int,colsX) &&
             BIT_VECTOR_SCALAR(Yrows,N_int,rowsY) &&
             BIT_VECTOR_SCALAR(Ycols,N_int,colsY) )
        {
            if ((rowsX == colsY) and (colsX == rowsY) and
                (BV_BITS_(Xadr) == rowsX*colsX) and
                (BV_BITS_(Yadr) == rowsY*colsY))
            {
                if ((Xadr != Yadr) or (rowsY == colsY))
                {
                    Matrix_Transpose(Xadr,rowsX,colsX,
                                     Yadr,rowsY,colsY);
                }
                else BIT_VECTOR_SHAPE_ERROR;
            }
            else BIT_VECTOR_MATRIX_ERROR;
        }
        else BIT_VECTOR_SCALAR_ERROR;
    }
    else BIT_VECTOR_OBJECT_ERROR;
}
#line 4665 "Vector.c"
    }
    XSRETURN_EMPTY;
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_Bit__Vector); /* prototype to pass -Wmissing-prototypes */
XS(boot_Bit__Vector)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#endif
    XS_VERSION_BOOTCHECK ;

    {
        CV * cv ;

        newXS("Bit::Vector::Version", XS_Bit__Vector_Version, file);
        newXS("Bit::Vector::Word_Bits", XS_Bit__Vector_Word_Bits, file);
        newXS("Bit::Vector::Long_Bits", XS_Bit__Vector_Long_Bits, file);
        cv = newXS("Bit::Vector::new", XS_Bit__Vector_Create, file);
        XSANY.any_i32 = 1 ;
        cv = newXS("Bit::Vector::Create", XS_Bit__Vector_Create, file);
        XSANY.any_i32 = 0 ;
        newXS("Bit::Vector::new_Hex", XS_Bit__Vector_new_Hex, file);
        newXS("Bit::Vector::new_Bin", XS_Bit__Vector_new_Bin, file);
        newXS("Bit::Vector::new_Dec", XS_Bit__Vector_new_Dec, file);
        newXS("Bit::Vector::new_Enum", XS_Bit__Vector_new_Enum, file);
        newXS("Bit::Vector::Shadow", XS_Bit__Vector_Shadow, file);
        newXS("Bit::Vector::Clone", XS_Bit__Vector_Clone, file);
        newXS("Bit::Vector::Concat", XS_Bit__Vector_Concat, file);
        newXS("Bit::Vector::Concat_List", XS_Bit__Vector_Concat_List, file);
        newXS("Bit::Vector::Size", XS_Bit__Vector_Size, file);
        newXS("Bit::Vector::Resize", XS_Bit__Vector_Resize, file);
        newXS("Bit::Vector::Unfake", XS_Bit__Vector_Unfake, file);
        newXS("Bit::Vector::DESTROY", XS_Bit__Vector_DESTROY, file);
        newXS("Bit::Vector::Copy", XS_Bit__Vector_Copy, file);
        newXS("Bit::Vector::Empty", XS_Bit__Vector_Empty, file);
        newXS("Bit::Vector::Fill", XS_Bit__Vector_Fill, file);
        newXS("Bit::Vector::Flip", XS_Bit__Vector_Flip, file);
        newXS("Bit::Vector::Primes", XS_Bit__Vector_Primes, file);
        newXS("Bit::Vector::Reverse", XS_Bit__Vector_Reverse, file);
        cv = newXS("Bit::Vector::Interval_Empty", XS_Bit__Vector_Interval_Empty, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("Bit::Vector::Empty_Interval", XS_Bit__Vector_Interval_Empty, file);
        XSANY.any_i32 = 2 ;
        cv = newXS("Bit::Vector::Fill_Interval", XS_Bit__Vector_Interval_Fill, file);
        XSANY.any_i32 = 2 ;
        cv = newXS("Bit::Vector::Interval_Fill", XS_Bit__Vector_Interval_Fill, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("Bit::Vector::Interval_Flip", XS_Bit__Vector_Interval_Flip, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("Bit::Vector::Flip_Interval", XS_Bit__Vector_Interval_Flip, file);
        XSANY.any_i32 = 2 ;
        newXS("Bit::Vector::Interval_Reverse", XS_Bit__Vector_Interval_Reverse, file);
        newXS("Bit::Vector::Interval_Scan_inc", XS_Bit__Vector_Interval_Scan_inc, file);
        newXS("Bit::Vector::Interval_Scan_dec", XS_Bit__Vector_Interval_Scan_dec, file);
        newXS("Bit::Vector::Interval_Copy", XS_Bit__Vector_Interval_Copy, file);
        newXS("Bit::Vector::Interval_Substitute", XS_Bit__Vector_Interval_Substitute, file);
        newXS("Bit::Vector::is_empty", XS_Bit__Vector_is_empty, file);
        newXS("Bit::Vector::is_full", XS_Bit__Vector_is_full, file);
        newXS("Bit::Vector::equal", XS_Bit__Vector_equal, file);
        newXS("Bit::Vector::Lexicompare", XS_Bit__Vector_Lexicompare, file);
        newXS("Bit::Vector::Compare", XS_Bit__Vector_Compare, file);
        cv = newXS("Bit::Vector::to_Hex", XS_Bit__Vector_to_Hex, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("Bit::Vector::to_String", XS_Bit__Vector_to_Hex, file);
        XSANY.any_i32 = 2 ;
        cv = newXS("Bit::Vector::from_Hex", XS_Bit__Vector_from_Hex, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("Bit::Vector::from_string", XS_Bit__Vector_from_Hex, file);
        XSANY.any_i32 = 2 ;
        newXS("Bit::Vector::to_Bin", XS_Bit__Vector_to_Bin, file);
        newXS("Bit::Vector::from_Bin", XS_Bit__Vector_from_Bin, file);
        newXS("Bit::Vector::to_Dec", XS_Bit__Vector_to_Dec, file);
        newXS("Bit::Vector::from_Dec", XS_Bit__Vector_from_Dec, file);
        cv = newXS("Bit::Vector::to_Enum", XS_Bit__Vector_to_Enum, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("Bit::Vector::to_ASCII", XS_Bit__Vector_to_Enum, file);
        XSANY.any_i32 = 2 ;
        cv = newXS("Bit::Vector::from_Enum", XS_Bit__Vector_from_Enum, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("Bit::Vector::from_ASCII", XS_Bit__Vector_from_Enum, file);
        XSANY.any_i32 = 2 ;
        newXS("Bit::Vector::Bit_Off", XS_Bit__Vector_Bit_Off, file);
        newXS("Bit::Vector::Bit_On", XS_Bit__Vector_Bit_On, file);
        cv = newXS("Bit::Vector::flip", XS_Bit__Vector_bit_flip, file);
        XSANY.any_i32 = 2 ;
        cv = newXS("Bit::Vector::bit_flip", XS_Bit__Vector_bit_flip, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("Bit::Vector::bit_test", XS_Bit__Vector_bit_test, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("Bit::Vector::in", XS_Bit__Vector_bit_test, file);
        XSANY.any_i32 = 2 ;
        cv = newXS("Bit::Vector::contains", XS_Bit__Vector_bit_test, file);
        XSANY.any_i32 = 1 ;
        newXS("Bit::Vector::Bit_Copy", XS_Bit__Vector_Bit_Copy, file);
        newXS("Bit::Vector::LSB", XS_Bit__Vector_LSB, file);
        newXS("Bit::Vector::MSB", XS_Bit__Vector_MSB, file);
        newXS("Bit::Vector::lsb", XS_Bit__Vector_lsb, file);
        newXS("Bit::Vector::msb", XS_Bit__Vector_msb, file);
        newXS("Bit::Vector::rotate_left", XS_Bit__Vector_rotate_left, file);
        newXS("Bit::Vector::rotate_right", XS_Bit__Vector_rotate_right, file);
        newXS("Bit::Vector::shift_left", XS_Bit__Vector_shift_left, file);
        newXS("Bit::Vector::shift_right", XS_Bit__Vector_shift_right, file);
        newXS("Bit::Vector::Move_Left", XS_Bit__Vector_Move_Left, file);
        newXS("Bit::Vector::Move_Right", XS_Bit__Vector_Move_Right, file);
        newXS("Bit::Vector::Insert", XS_Bit__Vector_Insert, file);
        newXS("Bit::Vector::Delete", XS_Bit__Vector_Delete, file);
        newXS("Bit::Vector::increment", XS_Bit__Vector_increment, file);
        newXS("Bit::Vector::decrement", XS_Bit__Vector_decrement, file);
        newXS("Bit::Vector::add", XS_Bit__Vector_add, file);
        cv = newXS("Bit::Vector::sub", XS_Bit__Vector_subtract, file);
        XSANY.any_i32 = 2 ;
        cv = newXS("Bit::Vector::subtract", XS_Bit__Vector_subtract, file);
        XSANY.any_i32 = 0 ;
        newXS("Bit::Vector::inc", XS_Bit__Vector_inc, file);
        newXS("Bit::Vector::dec", XS_Bit__Vector_dec, file);
        cv = newXS("Bit::Vector::Negate", XS_Bit__Vector_Negate, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("Bit::Vector::Neg", XS_Bit__Vector_Negate, file);
        XSANY.any_i32 = 1 ;
        cv = newXS("Bit::Vector::Absolute", XS_Bit__Vector_Absolute, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("Bit::Vector::Abs", XS_Bit__Vector_Absolute, file);
        XSANY.any_i32 = 1 ;
        newXS("Bit::Vector::Sign", XS_Bit__Vector_Sign, file);
        newXS("Bit::Vector::Multiply", XS_Bit__Vector_Multiply, file);
        newXS("Bit::Vector::Divide", XS_Bit__Vector_Divide, file);
        newXS("Bit::Vector::GCD", XS_Bit__Vector_GCD, file);
        newXS("Bit::Vector::Power", XS_Bit__Vector_Power, file);
        newXS("Bit::Vector::Block_Store", XS_Bit__Vector_Block_Store, file);
        newXS("Bit::Vector::Block_Read", XS_Bit__Vector_Block_Read, file);
        newXS("Bit::Vector::Word_Size", XS_Bit__Vector_Word_Size, file);
        newXS("Bit::Vector::Word_Store", XS_Bit__Vector_Word_Store, file);
        newXS("Bit::Vector::Word_Read", XS_Bit__Vector_Word_Read, file);
        newXS("Bit::Vector::Word_List_Store", XS_Bit__Vector_Word_List_Store, file);
        newXS("Bit::Vector::Word_List_Read", XS_Bit__Vector_Word_List_Read, file);
        newXS("Bit::Vector::Word_Insert", XS_Bit__Vector_Word_Insert, file);
        newXS("Bit::Vector::Word_Delete", XS_Bit__Vector_Word_Delete, file);
        newXS("Bit::Vector::Chunk_Store", XS_Bit__Vector_Chunk_Store, file);
        newXS("Bit::Vector::Chunk_Read", XS_Bit__Vector_Chunk_Read, file);
        newXS("Bit::Vector::Chunk_List_Store", XS_Bit__Vector_Chunk_List_Store, file);
        newXS("Bit::Vector::Chunk_List_Read", XS_Bit__Vector_Chunk_List_Read, file);
        newXS("Bit::Vector::Index_List_Remove", XS_Bit__Vector_Index_List_Remove, file);
        newXS("Bit::Vector::Index_List_Store", XS_Bit__Vector_Index_List_Store, file);
        newXS("Bit::Vector::Index_List_Read", XS_Bit__Vector_Index_List_Read, file);
        cv = newXS("Bit::Vector::Union", XS_Bit__Vector_Union, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("Bit::Vector::Or", XS_Bit__Vector_Union, file);
        XSANY.any_i32 = 1 ;
        cv = newXS("Bit::Vector::And", XS_Bit__Vector_Intersection, file);
        XSANY.any_i32 = 1 ;
        cv = newXS("Bit::Vector::Intersection", XS_Bit__Vector_Intersection, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("Bit::Vector::AndNot", XS_Bit__Vector_Difference, file);
        XSANY.any_i32 = 1 ;
        cv = newXS("Bit::Vector::Difference", XS_Bit__Vector_Difference, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("Bit::Vector::Xor", XS_Bit__Vector_ExclusiveOr, file);
        XSANY.any_i32 = 1 ;
        cv = newXS("Bit::Vector::ExclusiveOr", XS_Bit__Vector_ExclusiveOr, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("Bit::Vector::Complement", XS_Bit__Vector_Complement, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("Bit::Vector::Not", XS_Bit__Vector_Complement, file);
        XSANY.any_i32 = 1 ;
        cv = newXS("Bit::Vector::inclusion", XS_Bit__Vector_subset, file);
        XSANY.any_i32 = 2 ;
        cv = newXS("Bit::Vector::subset", XS_Bit__Vector_subset, file);
        XSANY.any_i32 = 0 ;
        newXS("Bit::Vector::Norm", XS_Bit__Vector_Norm, file);
        newXS("Bit::Vector::Norm2", XS_Bit__Vector_Norm2, file);
        newXS("Bit::Vector::Norm3", XS_Bit__Vector_Norm3, file);
        newXS("Bit::Vector::Min", XS_Bit__Vector_Min, file);
        newXS("Bit::Vector::Max", XS_Bit__Vector_Max, file);
        newXS("Bit::Vector::Multiplication", XS_Bit__Vector_Multiplication, file);
        newXS("Bit::Vector::Product", XS_Bit__Vector_Product, file);
        newXS("Bit::Vector::Closure", XS_Bit__Vector_Closure, file);
        newXS("Bit::Vector::Transpose", XS_Bit__Vector_Transpose, file);
    }

    /* Initialisation Section */

#line 157 "Vector.xs"
{
    BV_ErrCode rc;

    if ((rc = BitVector_Boot()))
    {
        BIT_VECTOR_EXCEPTION(rc);
        exit((int)rc);
    }
}

#line 4875 "Vector.c"

    /* End of Initialisation Section */

#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

