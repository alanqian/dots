.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Math::GSL::Interp 3pm"
.TH Math::GSL::Interp 3pm "2012-08-17" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::GSL::Interp \- Interpolation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Math::GSL::Interp qw/:all/;
\&    my $x_array = [ 0.0, 1.0, 2.0, 3.0, 4.0 ];
\&
\&    # check that we get the last interval if x == last value 
\&    $index_result = gsl_interp_bsearch($x_array, 4.0, 0, 4);
\&    print "The last interval is $index_result \en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.ie n .IP """gsl_interp_accel_alloc()""" 1
.el .IP "\f(CWgsl_interp_accel_alloc()\fR" 1
.IX Item "gsl_interp_accel_alloc()"
This function returns a pointer to an accelerator object, which is a kind of
iterator for interpolation lookups. It tracks the state of lookups, thus
allowing for application of various acceleration strategies.
.ie n .IP """gsl_interp_accel_find($a, $x_array, $size, $x)""" 1
.el .IP "\f(CWgsl_interp_accel_find($a, $x_array, $size, $x)\fR" 1
.IX Item "gsl_interp_accel_find($a, $x_array, $size, $x)"
This function performs a lookup action on the data array \f(CW$x_array\fR of size
\&\f(CW$size\fR, using the given accelerator \f(CW$a\fR. This is how lookups are performed during
evaluation of an interpolation. The function returns an index i such that
\&\f(CW$x_array\fR[i] <= \f(CW$x\fR < \f(CW$x_array\fR[i+1].
.ie n .IP """gsl_interp_accel_reset""" 1
.el .IP "\f(CWgsl_interp_accel_reset\fR" 1
.IX Item "gsl_interp_accel_reset"
.PD 0
.ie n .IP """gsl_interp_accel_free($a)""" 1
.el .IP "\f(CWgsl_interp_accel_free($a)\fR" 1
.IX Item "gsl_interp_accel_free($a)"
.PD
This function frees the accelerator object \f(CW$a\fR.
.ie n .IP """gsl_interp_alloc($T, $alloc)""" 1
.el .IP "\f(CWgsl_interp_alloc($T, $alloc)\fR" 1
.IX Item "gsl_interp_alloc($T, $alloc)"
This function returns a newly allocated interpolation object of type \f(CW$T\fR for
\&\f(CW$size\fR data-points. \f(CW$T\fR must be one of the constants below.
.ie n .IP """gsl_interp_init($interp, $xa, $ya, $size)""" 1
.el .IP "\f(CWgsl_interp_init($interp, $xa, $ya, $size)\fR" 1
.IX Item "gsl_interp_init($interp, $xa, $ya, $size)"
This function initializes the interpolation object interp for the data (xa,ya)
where xa and ya are arrays of size size. The interpolation object (gsl_interp)
does not save the data arrays xa and ya and only stores the static state
computed from the data. The xa data array is always assumed to be strictly
ordered, with increasing x values; the behavior for other arrangements is not
defined.
.ie n .IP """gsl_interp_name($interp)""" 1
.el .IP "\f(CWgsl_interp_name($interp)\fR" 1
.IX Item "gsl_interp_name($interp)"
This function returns the name of the interpolation type used by \f(CW$interp\fR.
.ie n .IP """gsl_interp_min_size($interp)""" 1
.el .IP "\f(CWgsl_interp_min_size($interp)\fR" 1
.IX Item "gsl_interp_min_size($interp)"
This function returns the minimum number of points required by the
interpolation type of \f(CW$interp\fR. For example, Akima spline interpolation requires
a minimum of 5 points.
.ie n .IP """gsl_interp_eval_e($interp, $xa, $ya, $x, $acc)""" 1
.el .IP "\f(CWgsl_interp_eval_e($interp, $xa, $ya, $x, $acc)\fR" 1
.IX Item "gsl_interp_eval_e($interp, $xa, $ya, $x, $acc)"
This functions returns the interpolated value of y for a given point \f(CW$x\fR, using
the interpolation object \f(CW$interp\fR, data arrays \f(CW$xa\fR and \f(CW$ya\fR and the accelerator
\&\f(CW$acc\fR. The function returns 0 if the operation succeeded, 1 otherwise and the y
value.
.ie n .IP """gsl_interp_eval($interp, $xa, $ya, $x, $acc)""" 1
.el .IP "\f(CWgsl_interp_eval($interp, $xa, $ya, $x, $acc)\fR" 1
.IX Item "gsl_interp_eval($interp, $xa, $ya, $x, $acc)"
This functions returns the interpolated value of y for a given point \f(CW$x\fR, using
the interpolation object \f(CW$interp\fR, data arrays \f(CW$xa\fR and \f(CW$ya\fR and the accelerator
\&\f(CW$acc\fR.
.ie n .IP """gsl_interp_eval_deriv_e($interp, $xa, $ya, $x, $acc)""" 1
.el .IP "\f(CWgsl_interp_eval_deriv_e($interp, $xa, $ya, $x, $acc)\fR" 1
.IX Item "gsl_interp_eval_deriv_e($interp, $xa, $ya, $x, $acc)"
This function computes the derivative value of y for a given point \f(CW$x\fR, using
the interpolation object \f(CW$interp\fR, data arrays \f(CW$xa\fR and \f(CW$ya\fR and the accelerator
\&\f(CW$acc\fR. The function returns 0 if the operation succeeded, 1 otherwise and the d
value.
.ie n .IP """gsl_interp_eval_deriv($interp, $xa, $ya, $x, $acc)""" 1
.el .IP "\f(CWgsl_interp_eval_deriv($interp, $xa, $ya, $x, $acc)\fR" 1
.IX Item "gsl_interp_eval_deriv($interp, $xa, $ya, $x, $acc)"
This function returns the derivative d of an interpolated function for a given
point \f(CW$x\fR, using the interpolation object interp, data arrays \f(CW$xa\fR and \f(CW$ya\fR and
the accelerator \f(CW$acc\fR.
.ie n .IP """gsl_interp_eval_deriv2_e($interp, $xa, $ya, $x, $acc)""" 1
.el .IP "\f(CWgsl_interp_eval_deriv2_e($interp, $xa, $ya, $x, $acc)\fR" 1
.IX Item "gsl_interp_eval_deriv2_e($interp, $xa, $ya, $x, $acc)"
This function computes the second derivative d2 of an interpolated function for
a given point \f(CW$x\fR, using the interpolation object \f(CW$interp\fR, data arrays \f(CW$xa\fR and
\&\f(CW$ya\fR and the accelerator \f(CW$acc\fR. The function returns 0 if the operation
succeeded, 1 otherwise and the d2 value.
.ie n .IP """gsl_interp_eval_deriv2($interp, $xa, $ya, $x, $acc)""" 1
.el .IP "\f(CWgsl_interp_eval_deriv2($interp, $xa, $ya, $x, $acc)\fR" 1
.IX Item "gsl_interp_eval_deriv2($interp, $xa, $ya, $x, $acc)"
This function returns the second derivative d2 of an interpolated function
for a given point \f(CW$x\fR, using the interpolation object \f(CW$interp\fR, data arrays \f(CW$xa\fR
and \f(CW$ya\fR and the accelerator \f(CW$acc\fR.
.ie n .IP """gsl_interp_eval_integ_e($interp, $xa, $ya, $a, $b, $acc)""" 1
.el .IP "\f(CWgsl_interp_eval_integ_e($interp, $xa, $ya, $a, $b, $acc)\fR" 1
.IX Item "gsl_interp_eval_integ_e($interp, $xa, $ya, $a, $b, $acc)"
This function computes the numerical integral result of an interpolated
function over the range [$a, \f(CW$b\fR], using the interpolation object \f(CW$interp\fR, data
arrays \f(CW$xa\fR and \f(CW$ya\fR and the accelerator \f(CW$acc\fR. The function returns 0 if the
operation succeeded, 1 otherwise and the result value.
.ie n .IP """gsl_interp_eval_integ($interp, $xa, $ya, $a, $b, $acc)""" 1
.el .IP "\f(CWgsl_interp_eval_integ($interp, $xa, $ya, $a, $b, $acc)\fR" 1
.IX Item "gsl_interp_eval_integ($interp, $xa, $ya, $a, $b, $acc)"
This function returns the numerical integral result of an interpolated function
over the range [$a, \f(CW$b\fR], using the interpolation object \f(CW$interp\fR, data arrays
\&\f(CW$xa\fR and \f(CW$ya\fR and the accelerator \f(CW$acc\fR.
.ie n .IP """gsl_interp_free($interp)"" \- This function frees the interpolation object $interp." 1
.el .IP "\f(CWgsl_interp_free($interp)\fR \- This function frees the interpolation object \f(CW$interp\fR." 1
.IX Item "gsl_interp_free($interp) - This function frees the interpolation object $interp."
.PD 0
.ie n .IP """gsl_interp_bsearch($x_array, $x, $index_lo, $index_hi)""" 1
.el .IP "\f(CWgsl_interp_bsearch($x_array, $x, $index_lo, $index_hi)\fR" 1
.IX Item "gsl_interp_bsearch($x_array, $x, $index_lo, $index_hi)"
.PD
This function returns the index i of the array \f(CW$x_array\fR such that \f(CW$x_array\fR[i]
<= x < \f(CW$x_array\fR[i+1]. The index is searched for in the range
[$index_lo,$index_hi].
.PP
This module also includes the following constants :
.ie n .IP "$gsl_interp_linear" 1
.el .IP "\f(CW$gsl_interp_linear\fR" 1
.IX Item "$gsl_interp_linear"
Linear interpolation
.ie n .IP "$gsl_interp_polynomial" 1
.el .IP "\f(CW$gsl_interp_polynomial\fR" 1
.IX Item "$gsl_interp_polynomial"
Polynomial interpolation. This method should only be used for interpolating
small numbers of points because polynomial interpolation introduces large
oscillations, even for well-behaved datasets. The number of terms in the
interpolating polynomial is equal to the number of points.
.ie n .IP "$gsl_interp_cspline" 1
.el .IP "\f(CW$gsl_interp_cspline\fR" 1
.IX Item "$gsl_interp_cspline"
Cubic spline with natural boundary conditions. The resulting curve is piecewise
cubic on each interval, with matching first and second derivatives at the
supplied data-points. The second derivative is chosen to be zero at the first
point and last point.
.ie n .IP "$gsl_interp_cspline_periodic" 1
.el .IP "\f(CW$gsl_interp_cspline_periodic\fR" 1
.IX Item "$gsl_interp_cspline_periodic"
Cubic spline with periodic boundary conditions. The resulting curve is
piecewise cubic on each interval, with matching first and second derivatives at
the supplied data-points. The derivatives at the first and last points are also
matched. Note that the last point in the data must have the same y\-value as the
first point, otherwise the resulting periodic interpolation will have a
discontinuity at the boundary.
.ie n .IP "$gsl_interp_akima" 1
.el .IP "\f(CW$gsl_interp_akima\fR" 1
.IX Item "$gsl_interp_akima"
Non-rounded Akima spline with natural boundary conditions. This method uses the
non-rounded corner algorithm of Wodicka.
.ie n .IP "$gsl_interp_akima_periodic" 1
.el .IP "\f(CW$gsl_interp_akima_periodic\fR" 1
.IX Item "$gsl_interp_akima_periodic"
Non-rounded Akima spline with periodic boundary conditions. This method uses
the non-rounded corner algorithm of Wodicka.
.SH "AUTHORS"
.IX Header "AUTHORS"
Jonathan \*(L"Duke\*(R" Leto <jonathan@leto.net> and Thierry Moisan <thierry.moisan@gmail.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2008\-2011 Jonathan \*(L"Duke\*(R" Leto and Thierry Moisan
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
