.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Math::GSL::Matrix 3pm"
.TH Math::GSL::Matrix 3pm "2012-08-17" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::GSL::Matrix \- Mathematical functions concerning Matrices
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 8
\&    use Math::GSL::Matrix qw/:all/;
\&    my $matrix1 = Math::GSL::Matrix\->new(5,5);  # OO interface
\&    my $matrix2 = $matrix1 + 4;                 # You can add or substract values or matrices to OO matrices
\&    my $matrix3 = $matrix1 \- 4;
\&    my $matrix4 = $matrix2 + $matrix1;
\&    my $matrix5 = $matrix2 . $matrix1;          # This is a scalar product, it simply multiply each element
\&                                                # with the element of $matrix1 that have the same position
\&                                                # See Math::GSL::BLAS if you want scalar product
\&
\&    my $matrix6 = $matrix2 . 8;                 # Multiply every elements of $matrix2 by 8
\&    my $matrix7 = $matrix2 * $matrix1;          # scalar product of two matrices
\&    if($matrix1 == $matrix4) ...
\&    if($matrix1 != $matrix3) ...
\&    my $matrix8 = gsl_matrix_alloc(5,5);        # standard interface
.Ve
.SH "Objected Oriented Interface to GSL Math::GSL::Matrix"
.IX Header "Objected Oriented Interface to GSL Math::GSL::Matrix"
.SS "Math::GSL::Matrix\->\fInew()\fP"
.IX Subsection "Math::GSL::Matrix->new()"
Creates a new Matrix of the given size.
.PP
.Vb 1
\&    my $matrix = Math::GSL::Matrix\->new(10,10);
.Ve
.SS "\fIraw()\fP"
.IX Subsection "raw()"
Get the underlying \s-1GSL\s0 matrix object created by \s-1SWIG\s0, useful for using gsl_matrix_* functions which do not have an \s-1OO\s0 counterpart.
.PP
.Vb 3
\&    my $matrix     = Math::GSL::Matrix\->new(3,3);
\&    my $gsl_matrix = $matrix\->raw;
\&    my $stuff      = gsl_matrix_get($gsl_matrix, 1, 2);
.Ve
.SS "\fIidentity()\fP"
.IX Subsection "identity()"
Set a matrix to the identity matrix, i.e. one on the diagonal and zero elsewhere.
.PP
.Vb 1
\&    my $I = $matrix\->identity;
.Ve
.SS "\fIzero()\fP"
.IX Subsection "zero()"
Set a matrix to the zero matrix.
.PP
.Vb 1
\&    $matrix\->zero;
.Ve
.SS "\fIcopy()\fP"
.IX Subsection "copy()"
Returns a copy of the matrix, which has the same size and values but resides at a different location in memory.
.PP
.Vb 2
\&    my $matrix = Math::GSL::Matrix\->new(5,5);
\&    my $copy   = $matrix\->copy;
.Ve
.SS "\fIrows()\fP"
.IX Subsection "rows()"
Returns the number of rows in the matrix.
.PP
.Vb 1
\&    my $rows = $matrix\->rows;
.Ve
.SS "\fIcols()\fP"
.IX Subsection "cols()"
Returns the number of columns in the matrix.
.PP
.Vb 1
\&    my $cols = $matrix\->cols;
.Ve
.SS "\fIas_list()\fP"
.IX Subsection "as_list()"
Get the contents of a Math::GSL::Matrix object as a Perl list.
.PP
.Vb 3
\&    my $matrix = Math::GSL::Matrix\->new(3,3);
\&    ...
\&    my @matrix = $matrix\->as_list;
.Ve
.SS "\fIis_square()\fP"
.IX Subsection "is_square()"
Returns true if a matrix is square, i.e. it has the same number of rows as columns, false otherwise.
.SS "\fIdet()\fP"
.IX Subsection "det()"
Returns the determinant of a matrix (computed by \s-1LU\s0 decomposition) or dies if called on a non-square matrix.
.PP
.Vb 1
\&    my $det = $matrix\->det();
.Ve
.SS "\fIlndet()\fP"
.IX Subsection "lndet()"
Returns the natural log of the absolute value of the determinant of a matrix (computed by \s-1LU\s0 decomposition) or dies if called on a non-square matrix.
.PP
.Vb 1
\&    my $lndet = $matrix\->lndet();
.Ve
.SS "\fIinverse()\fP"
.IX Subsection "inverse()"
Returns the inverse of a matrix or dies when called on a non-square matrix.
.PP
.Vb 1
\&    my $inverse = $matrix\->inverse;
.Ve
.SS "\fIeigenvalues()\fP"
.IX Subsection "eigenvalues()"
.SS "\fIas_vector()\fP"
.IX Subsection "as_vector()"
Returns a 1xN or Nx1 matrix as a Math::GSL::Vector object. Dies if called on a matrix that is not a single row or column. Useful for turning the output of \f(CW\*(C`col()\*(C'\fR or \f(CW\*(C`row()\*(C'\fR into a vector, like so:
.PP
.Vb 2
\&    my $vector1 = $matrix\->col(0)\->as_vector;
\&    my $vector2 = $matrix\->row(1)\->as_vector;
.Ve
.SS "\fIas_list()\fP"
.IX Subsection "as_list()"
Returns a matrix as a flattened Perl list.
.PP
.Vb 1
\&    my @values = $matrix\->as_list;
.Ve
.SS "\fIrow()\fP"
.IX Subsection "row()"
Returns a row matrix of the row you enter.
.PP
.Vb 3
\&    my $matrix = Math::GSL::Matrix\->new(3,3);
\&    ...
\&    my $matrix_row = $matrix\->row(0);
.Ve
.SS "\fIcol()\fP"
.IX Subsection "col()"
Returns a col matrix of the column you enter.
.PP
.Vb 3
\&    my $matrix = Math::GSL::Matrix\->new(3,3);
\&    ...
\&    my $matrix_col = $matrix\->col(0);
.Ve
.SS "\fIset_row()\fP"
.IX Subsection "set_row()"
Sets a the values of a row with the elements of an array.
.PP
.Vb 2
\&    my $matrix = Math::GSL::Matrix\->new(3,3);
\&    $matrix\->set_row(0, [8, 6, 2]);
.Ve
.PP
You can also set multiple rows at once with chained calls:
.PP
.Vb 4
\&    my $matrix = Math::GSL::Matrix\->new(3,3);
\&    $matrix\->set_row(0, [8, 6, 2])
\&           \->set_row(1, [2, 4, 1]);
\&    ...
.Ve
.SS "\fIset_col()\fP"
.IX Subsection "set_col()"
Sets a the values of a column with the elements of an array.
.PP
.Vb 2
\&    my $matrix = Math::GSL::Matrix\->new(3,3);
\&    $matrix\->set_col(0, [8, 6, 2]);
.Ve
.PP
You can also set multiple columns at once with chained calls:
    my \f(CW$matrix\fR = Math::GSL::Matrix\->new(3,3);
    \f(CW$matrix\fR\->set_col(0, [8, 6, 2])
           \->set_col(1, [2, 4, 1]);
    ...
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Here is a list of all the functions included in this module :
.ie n .IP """gsl_matrix_alloc($i, $j)"" \- Return a gsl_matrix of $i rows and $j columns" 1
.el .IP "\f(CWgsl_matrix_alloc($i, $j)\fR \- Return a gsl_matrix of \f(CW$i\fR rows and \f(CW$j\fR columns" 1
.IX Item "gsl_matrix_alloc($i, $j) - Return a gsl_matrix of $i rows and $j columns"
.PD 0
.ie n .IP """gsl_matrix_calloc($i, $j)"" \- Return a gsl_matrix of $i rows and $j columns and initialize all of the elements of the matrix to zero" 1
.el .IP "\f(CWgsl_matrix_calloc($i, $j)\fR \- Return a gsl_matrix of \f(CW$i\fR rows and \f(CW$j\fR columns and initialize all of the elements of the matrix to zero" 1
.IX Item "gsl_matrix_calloc($i, $j) - Return a gsl_matrix of $i rows and $j columns and initialize all of the elements of the matrix to zero"
.ie n .IP """gsl_matrix_alloc_from_block"" \-" 1
.el .IP "\f(CWgsl_matrix_alloc_from_block\fR \-" 1
.IX Item "gsl_matrix_alloc_from_block -"
.ie n .IP """gsl_matrix_free"" \-" 1
.el .IP "\f(CWgsl_matrix_free\fR \-" 1
.IX Item "gsl_matrix_free -"
.ie n .IP """gsl_matrix_alloc_from_matrix "" \-" 1
.el .IP "\f(CWgsl_matrix_alloc_from_matrix \fR \-" 1
.IX Item "gsl_matrix_alloc_from_matrix  -"
.ie n .IP """gsl_vector_alloc_row_from_matrix"" \-" 1
.el .IP "\f(CWgsl_vector_alloc_row_from_matrix\fR \-" 1
.IX Item "gsl_vector_alloc_row_from_matrix -"
.ie n .IP """gsl_vector_alloc_col_from_matrix "" \-" 1
.el .IP "\f(CWgsl_vector_alloc_col_from_matrix \fR \-" 1
.IX Item "gsl_vector_alloc_col_from_matrix  -"
.ie n .IP """gsl_matrix_submatrix($m, $k1, $k2, $n1, $n2)"" \- Return a matrix view of the matrix $m. The upper-left element of the submatrix is the element ($k1,$k2) of the original matrix. The submatrix has $n1 rows and $n2 columns." 1
.el .IP "\f(CWgsl_matrix_submatrix($m, $k1, $k2, $n1, $n2)\fR \- Return a matrix view of the matrix \f(CW$m\fR. The upper-left element of the submatrix is the element ($k1,$k2) of the original matrix. The submatrix has \f(CW$n1\fR rows and \f(CW$n2\fR columns." 1
.IX Item "gsl_matrix_submatrix($m, $k1, $k2, $n1, $n2) - Return a matrix view of the matrix $m. The upper-left element of the submatrix is the element ($k1,$k2) of the original matrix. The submatrix has $n1 rows and $n2 columns."
.ie n .IP """gsl_matrix_row($m , $i)"" \- Return a vector view of the $i\-th row of the matrix $m" 1
.el .IP "\f(CWgsl_matrix_row($m , $i)\fR \- Return a vector view of the \f(CW$i\fR\-th row of the matrix \f(CW$m\fR" 1
.IX Item "gsl_matrix_row($m , $i) - Return a vector view of the $i-th row of the matrix $m"
.ie n .IP """gsl_matrix_column($m, $j)"" \- Return a vector view of the $j\-th column of the matrix $m" 1
.el .IP "\f(CWgsl_matrix_column($m, $j)\fR \- Return a vector view of the \f(CW$j\fR\-th column of the matrix \f(CW$m\fR" 1
.IX Item "gsl_matrix_column($m, $j) - Return a vector view of the $j-th column of the matrix $m"
.ie n .IP """gsl_matrix_diagonal($m)"" \- Return a vector view of the diagonal of the vector. The matrix doesn't have to be square." 1
.el .IP "\f(CWgsl_matrix_diagonal($m)\fR \- Return a vector view of the diagonal of the vector. The matrix doesn't have to be square." 1
.IX Item "gsl_matrix_diagonal($m) - Return a vector view of the diagonal of the vector. The matrix doesn't have to be square."
.ie n .IP """gsl_matrix_subdiagonal($m, $k)"" \- Return a vector view of the $k\-th subdiagonal of the matrix $m. The diagonal of the matrix corresponds to k=0." 1
.el .IP "\f(CWgsl_matrix_subdiagonal($m, $k)\fR \- Return a vector view of the \f(CW$k\fR\-th subdiagonal of the matrix \f(CW$m\fR. The diagonal of the matrix corresponds to k=0." 1
.IX Item "gsl_matrix_subdiagonal($m, $k) - Return a vector view of the $k-th subdiagonal of the matrix $m. The diagonal of the matrix corresponds to k=0."
.ie n .IP """gsl_matrix_superdiagonal($m, $k)"" \- Return a vector view of the $k\-th superdiagonal of the matrix $m. The matrix doesn't have to be square." 1
.el .IP "\f(CWgsl_matrix_superdiagonal($m, $k)\fR \- Return a vector view of the \f(CW$k\fR\-th superdiagonal of the matrix \f(CW$m\fR. The matrix doesn't have to be square." 1
.IX Item "gsl_matrix_superdiagonal($m, $k) - Return a vector view of the $k-th superdiagonal of the matrix $m. The matrix doesn't have to be square."
.ie n .IP """gsl_matrix_subrow($m, $i, $offset, $n)"" \- Return a vector view of the $i\-th row of the matrix $m beginning at offset elements and containing n elements." 1
.el .IP "\f(CWgsl_matrix_subrow($m, $i, $offset, $n)\fR \- Return a vector view of the \f(CW$i\fR\-th row of the matrix \f(CW$m\fR beginning at offset elements and containing n elements." 1
.IX Item "gsl_matrix_subrow($m, $i, $offset, $n) - Return a vector view of the $i-th row of the matrix $m beginning at offset elements and containing n elements."
.ie n .IP """gsl_matrix_subcolumn($m, $j, $offset, $n)"" \- Return a vector view of the $j\-th column of the matrix $m beginning at offset elements and containing n elements." 1
.el .IP "\f(CWgsl_matrix_subcolumn($m, $j, $offset, $n)\fR \- Return a vector view of the \f(CW$j\fR\-th column of the matrix \f(CW$m\fR beginning at offset elements and containing n elements." 1
.IX Item "gsl_matrix_subcolumn($m, $j, $offset, $n) - Return a vector view of the $j-th column of the matrix $m beginning at offset elements and containing n elements."
.ie n .IP """gsl_matrix_view_array($base, $n1, $n2)"" \- This function returns a matrix view of the array reference $base. The matrix has $n1 rows and $n2 columns. The physical number of columns in memory is also given by $n2. Mathematically, the (i,j)\-th element of the new matrix is given by, m'(i,j) = $base\->[i*$n2 + j] where the index i runs from 0 to $n1\-1 and the index j runs from 0 to $n2\-1. The new matrix is only a view of the array reference $base. When the view goes out of scope the original array reference $base will continue to exist. The original memory can only be deallocated by freeing the original array. Of course, the original array should not be deallocated while the view is still in use." 1
.el .IP "\f(CWgsl_matrix_view_array($base, $n1, $n2)\fR \- This function returns a matrix view of the array reference \f(CW$base\fR. The matrix has \f(CW$n1\fR rows and \f(CW$n2\fR columns. The physical number of columns in memory is also given by \f(CW$n2\fR. Mathematically, the (i,j)\-th element of the new matrix is given by, m'(i,j) = \f(CW$base\fR\->[i*$n2 + j] where the index i runs from 0 to \f(CW$n1\fR\-1 and the index j runs from 0 to \f(CW$n2\fR\-1. The new matrix is only a view of the array reference \f(CW$base\fR. When the view goes out of scope the original array reference \f(CW$base\fR will continue to exist. The original memory can only be deallocated by freeing the original array. Of course, the original array should not be deallocated while the view is still in use." 1
.IX Item "gsl_matrix_view_array($base, $n1, $n2) - This function returns a matrix view of the array reference $base. The matrix has $n1 rows and $n2 columns. The physical number of columns in memory is also given by $n2. Mathematically, the (i,j)-th element of the new matrix is given by, m'(i,j) = $base->[i*$n2 + j] where the index i runs from 0 to $n1-1 and the index j runs from 0 to $n2-1. The new matrix is only a view of the array reference $base. When the view goes out of scope the original array reference $base will continue to exist. The original memory can only be deallocated by freeing the original array. Of course, the original array should not be deallocated while the view is still in use."
.ie n .IP """gsl_matrix_view_array_with_tda($base, $n1, $n2, $tda)"" \- This function returns a matrix view of the array reference $base with a physical number of columns $tda which may differ from the corresponding dimension of the matrix. The matrix has $n1 rows and $n2 columns, and the physical number of columns in memory is given by $tda. Mathematically, the (i,j)\-th element of the new matrix is given by, m'(i,j) = $base\->[i*$tda + j] where the index i runs from 0 to $n1\-1 and the index j runs from 0 to $n2\-1. The new matrix is only a view of the array reference $base. When the view goes out of scope the original array reference $base will continue to exist. The original memory can only be deallocated by freeing the original array. Of course, the original array should not be deallocated while the view is still in use." 1
.el .IP "\f(CWgsl_matrix_view_array_with_tda($base, $n1, $n2, $tda)\fR \- This function returns a matrix view of the array reference \f(CW$base\fR with a physical number of columns \f(CW$tda\fR which may differ from the corresponding dimension of the matrix. The matrix has \f(CW$n1\fR rows and \f(CW$n2\fR columns, and the physical number of columns in memory is given by \f(CW$tda\fR. Mathematically, the (i,j)\-th element of the new matrix is given by, m'(i,j) = \f(CW$base\fR\->[i*$tda + j] where the index i runs from 0 to \f(CW$n1\fR\-1 and the index j runs from 0 to \f(CW$n2\fR\-1. The new matrix is only a view of the array reference \f(CW$base\fR. When the view goes out of scope the original array reference \f(CW$base\fR will continue to exist. The original memory can only be deallocated by freeing the original array. Of course, the original array should not be deallocated while the view is still in use." 1
.IX Item "gsl_matrix_view_array_with_tda($base, $n1, $n2, $tda) - This function returns a matrix view of the array reference $base with a physical number of columns $tda which may differ from the corresponding dimension of the matrix. The matrix has $n1 rows and $n2 columns, and the physical number of columns in memory is given by $tda. Mathematically, the (i,j)-th element of the new matrix is given by, m'(i,j) = $base->[i*$tda + j] where the index i runs from 0 to $n1-1 and the index j runs from 0 to $n2-1. The new matrix is only a view of the array reference $base. When the view goes out of scope the original array reference $base will continue to exist. The original memory can only be deallocated by freeing the original array. Of course, the original array should not be deallocated while the view is still in use."
.ie n .IP """gsl_matrix_view_vector"" \-" 1
.el .IP "\f(CWgsl_matrix_view_vector\fR \-" 1
.IX Item "gsl_matrix_view_vector -"
.ie n .IP """gsl_matrix_view_vector_with_tda"" \-" 1
.el .IP "\f(CWgsl_matrix_view_vector_with_tda\fR \-" 1
.IX Item "gsl_matrix_view_vector_with_tda -"
.ie n .IP """gsl_matrix_const_submatrix"" \-" 1
.el .IP "\f(CWgsl_matrix_const_submatrix\fR \-" 1
.IX Item "gsl_matrix_const_submatrix -"
.ie n .IP """gsl_matrix_get($m, $i, $j)"" \- Return the (i,j)\-th element of the matrix $m" 1
.el .IP "\f(CWgsl_matrix_get($m, $i, $j)\fR \- Return the (i,j)\-th element of the matrix \f(CW$m\fR" 1
.IX Item "gsl_matrix_get($m, $i, $j) - Return the (i,j)-th element of the matrix $m"
.ie n .IP """gsl_matrix_set($m, $i, $j, $x)"" \- Set the value of the (i,j)\-th element of the matrix $m to $x" 1
.el .IP "\f(CWgsl_matrix_set($m, $i, $j, $x)\fR \- Set the value of the (i,j)\-th element of the matrix \f(CW$m\fR to \f(CW$x\fR" 1
.IX Item "gsl_matrix_set($m, $i, $j, $x) - Set the value of the (i,j)-th element of the matrix $m to $x"
.ie n .IP """gsl_matrix_ptr"" \-" 1
.el .IP "\f(CWgsl_matrix_ptr\fR \-" 1
.IX Item "gsl_matrix_ptr -"
.ie n .IP """gsl_matrix_const_ptr"" \-" 1
.el .IP "\f(CWgsl_matrix_const_ptr\fR \-" 1
.IX Item "gsl_matrix_const_ptr -"
.ie n .IP """gsl_matrix_set_zero($m)"" \- Set all the elements of the matrix $m to zero" 1
.el .IP "\f(CWgsl_matrix_set_zero($m)\fR \- Set all the elements of the matrix \f(CW$m\fR to zero" 1
.IX Item "gsl_matrix_set_zero($m) - Set all the elements of the matrix $m to zero"
.ie n .IP """gsl_matrix_set_identity($m)"" \- Set the elements of the matrix $m to the corresponding elements of the identity matrix" 1
.el .IP "\f(CWgsl_matrix_set_identity($m)\fR \- Set the elements of the matrix \f(CW$m\fR to the corresponding elements of the identity matrix" 1
.IX Item "gsl_matrix_set_identity($m) - Set the elements of the matrix $m to the corresponding elements of the identity matrix"
.ie n .IP """gsl_matrix_set_all($m, $x)"" \- Set all the elements of the matrix $m to the value $x" 1
.el .IP "\f(CWgsl_matrix_set_all($m, $x)\fR \- Set all the elements of the matrix \f(CW$m\fR to the value \f(CW$x\fR" 1
.IX Item "gsl_matrix_set_all($m, $x) - Set all the elements of the matrix $m to the value $x"
.ie n .IP """gsl_matrix_fread($fh, $m)"" \- Read a file which has been written with gsl_matrix_fwrite from the stream $fh opened with the gsl_fopen function from the Math::GSL module and stores the data inside the matrix $m" 1
.el .IP "\f(CWgsl_matrix_fread($fh, $m)\fR \- Read a file which has been written with gsl_matrix_fwrite from the stream \f(CW$fh\fR opened with the gsl_fopen function from the Math::GSL module and stores the data inside the matrix \f(CW$m\fR" 1
.IX Item "gsl_matrix_fread($fh, $m) - Read a file which has been written with gsl_matrix_fwrite from the stream $fh opened with the gsl_fopen function from the Math::GSL module and stores the data inside the matrix $m"
.ie n .IP """gsl_matrix_fwrite($fh, $m)"" \- Write the elements of the matrix $m in binary format to a stream $fh opened with the gsl_fopen function from the Math::GSL module" 1
.el .IP "\f(CWgsl_matrix_fwrite($fh, $m)\fR \- Write the elements of the matrix \f(CW$m\fR in binary format to a stream \f(CW$fh\fR opened with the gsl_fopen function from the Math::GSL module" 1
.IX Item "gsl_matrix_fwrite($fh, $m) - Write the elements of the matrix $m in binary format to a stream $fh opened with the gsl_fopen function from the Math::GSL module"
.ie n .IP """gsl_matrix_fscanf($fh, $m)"" \- Read a file which has been written with gsl_matrix_fprintf from the stream $fh opened with the gsl_fopenfunction from the Math::GSL module and stores the data inside the matrix $m" 1
.el .IP "\f(CWgsl_matrix_fscanf($fh, $m)\fR \- Read a file which has been written with gsl_matrix_fprintf from the stream \f(CW$fh\fR opened with the gsl_fopenfunction from the Math::GSL module and stores the data inside the matrix \f(CW$m\fR" 1
.IX Item "gsl_matrix_fscanf($fh, $m) - Read a file which has been written with gsl_matrix_fprintf from the stream $fh opened with the gsl_fopenfunction from the Math::GSL module and stores the data inside the matrix $m"
.ie n .IP """gsl_matrix_fprintf($fh, $m, $format)"" \- Write the elements of the matrix $m in the format $format (for example ""%f"" is the format for double) to a stream $fh opened with the gsl_fopen function from the Math::GSL module" 1
.el .IP "\f(CWgsl_matrix_fprintf($fh, $m, $format)\fR \- Write the elements of the matrix \f(CW$m\fR in the format \f(CW$format\fR (for example ``%f'' is the format for double) to a stream \f(CW$fh\fR opened with the gsl_fopen function from the Math::GSL module" 1
.IX Item "gsl_matrix_fprintf($fh, $m, $format) - Write the elements of the matrix $m in the format $format (for example %f is the format for double) to a stream $fh opened with the gsl_fopen function from the Math::GSL module"
.ie n .IP """gsl_matrix_memcpy($dest, $src)"" \- Copy the elements of the matrix $src to the matrix $dest. The two matrices must have the same size." 1
.el .IP "\f(CWgsl_matrix_memcpy($dest, $src)\fR \- Copy the elements of the matrix \f(CW$src\fR to the matrix \f(CW$dest\fR. The two matrices must have the same size." 1
.IX Item "gsl_matrix_memcpy($dest, $src) - Copy the elements of the matrix $src to the matrix $dest. The two matrices must have the same size."
.ie n .IP """gsl_matrix_swap($m1, $m2)"" \- Exchange the elements of the matrices $m1 and $m2 by copying. The two matrices must have the same size." 1
.el .IP "\f(CWgsl_matrix_swap($m1, $m2)\fR \- Exchange the elements of the matrices \f(CW$m1\fR and \f(CW$m2\fR by copying. The two matrices must have the same size." 1
.IX Item "gsl_matrix_swap($m1, $m2) - Exchange the elements of the matrices $m1 and $m2 by copying. The two matrices must have the same size."
.ie n .IP """gsl_matrix_swap_rows($m, $i, $j)"" \- Exchange the $i\-th and $j\-th row of the matrix $m. The function returns 0 if the operation suceeded, 1 otherwise." 1
.el .IP "\f(CWgsl_matrix_swap_rows($m, $i, $j)\fR \- Exchange the \f(CW$i\fR\-th and \f(CW$j\fR\-th row of the matrix \f(CW$m\fR. The function returns 0 if the operation suceeded, 1 otherwise." 1
.IX Item "gsl_matrix_swap_rows($m, $i, $j) - Exchange the $i-th and $j-th row of the matrix $m. The function returns 0 if the operation suceeded, 1 otherwise."
.ie n .IP """gsl_matrix_swap_columns($m, $i, $j)"" \- Exchange the $i\-th and $j\-th column of the matrix $m. The function returns 0 if the operation suceeded, 1 otherwise." 1
.el .IP "\f(CWgsl_matrix_swap_columns($m, $i, $j)\fR \- Exchange the \f(CW$i\fR\-th and \f(CW$j\fR\-th column of the matrix \f(CW$m\fR. The function returns 0 if the operation suceeded, 1 otherwise." 1
.IX Item "gsl_matrix_swap_columns($m, $i, $j) - Exchange the $i-th and $j-th column of the matrix $m. The function returns 0 if the operation suceeded, 1 otherwise."
.ie n .IP """gsl_matrix_swap_rowcol($m, $i, $j)"" \- Exchange the $i\-th row and the $j\-th column of the matrix $m. The matrix must be square. The function returns 0 if the operation suceeded, 1 otherwise." 1
.el .IP "\f(CWgsl_matrix_swap_rowcol($m, $i, $j)\fR \- Exchange the \f(CW$i\fR\-th row and the \f(CW$j\fR\-th column of the matrix \f(CW$m\fR. The matrix must be square. The function returns 0 if the operation suceeded, 1 otherwise." 1
.IX Item "gsl_matrix_swap_rowcol($m, $i, $j) - Exchange the $i-th row and the $j-th column of the matrix $m. The matrix must be square. The function returns 0 if the operation suceeded, 1 otherwise."
.ie n .IP """gsl_matrix_transpose($m)"" \- This function replaces the matrix m by its transpose by copying the elements of the matrix in-place. The matrix must be square for this operation to be possible." 1
.el .IP "\f(CWgsl_matrix_transpose($m)\fR \- This function replaces the matrix m by its transpose by copying the elements of the matrix in-place. The matrix must be square for this operation to be possible." 1
.IX Item "gsl_matrix_transpose($m) - This function replaces the matrix m by its transpose by copying the elements of the matrix in-place. The matrix must be square for this operation to be possible."
.ie n .IP """gsl_matrix_transpose_memcpy($dest, $src)"" \- Make the matrix $dest the transpose of the matrix $src. This function works for all matrices provided that the dimensions of the matrix dest match the transposed dimensions of the matrix src." 1
.el .IP "\f(CWgsl_matrix_transpose_memcpy($dest, $src)\fR \- Make the matrix \f(CW$dest\fR the transpose of the matrix \f(CW$src\fR. This function works for all matrices provided that the dimensions of the matrix dest match the transposed dimensions of the matrix src." 1
.IX Item "gsl_matrix_transpose_memcpy($dest, $src) - Make the matrix $dest the transpose of the matrix $src. This function works for all matrices provided that the dimensions of the matrix dest match the transposed dimensions of the matrix src."
.ie n .IP """gsl_matrix_max($m)"" \- Return the maximum value in the matrix $m" 1
.el .IP "\f(CWgsl_matrix_max($m)\fR \- Return the maximum value in the matrix \f(CW$m\fR" 1
.IX Item "gsl_matrix_max($m) - Return the maximum value in the matrix $m"
.ie n .IP """gsl_matrix_min($m)"" \- Return the minimum value in the matrix $m" 1
.el .IP "\f(CWgsl_matrix_min($m)\fR \- Return the minimum value in the matrix \f(CW$m\fR" 1
.IX Item "gsl_matrix_min($m) - Return the minimum value in the matrix $m"
.ie n .IP """gsl_matrix_minmax($m)"" \- Return two values, the first is the minimum value of the Matrix $m and the second is the maximum of the same the same matrix." 1
.el .IP "\f(CWgsl_matrix_minmax($m)\fR \- Return two values, the first is the minimum value of the Matrix \f(CW$m\fR and the second is the maximum of the same the same matrix." 1
.IX Item "gsl_matrix_minmax($m) - Return two values, the first is the minimum value of the Matrix $m and the second is the maximum of the same the same matrix."
.ie n .IP """gsl_matrix_max_index($m)"" \- Return two values, the first is the the i indice of the maximum value of the matrix $m and the second is the j indice of the same value." 1
.el .IP "\f(CWgsl_matrix_max_index($m)\fR \- Return two values, the first is the the i indice of the maximum value of the matrix \f(CW$m\fR and the second is the j indice of the same value." 1
.IX Item "gsl_matrix_max_index($m) - Return two values, the first is the the i indice of the maximum value of the matrix $m and the second is the j indice of the same value."
.ie n .IP """gsl_matrix_min_index($m)"" \- Return two values, the first is the the i indice of the minimum value of the matrix $m and the second is the j indice of the same value." 1
.el .IP "\f(CWgsl_matrix_min_index($m)\fR \- Return two values, the first is the the i indice of the minimum value of the matrix \f(CW$m\fR and the second is the j indice of the same value." 1
.IX Item "gsl_matrix_min_index($m) - Return two values, the first is the the i indice of the minimum value of the matrix $m and the second is the j indice of the same value."
.ie n .IP """gsl_matrix_minmax_index($m)"" \- Return four values, the first is the i indice of the minimum of the matrix $m, the second is the j indice of the same value, the third is the i indice of the maximum of the matrix $m and the fourth is the j indice of the same value" 1
.el .IP "\f(CWgsl_matrix_minmax_index($m)\fR \- Return four values, the first is the i indice of the minimum of the matrix \f(CW$m\fR, the second is the j indice of the same value, the third is the i indice of the maximum of the matrix \f(CW$m\fR and the fourth is the j indice of the same value" 1
.IX Item "gsl_matrix_minmax_index($m) - Return four values, the first is the i indice of the minimum of the matrix $m, the second is the j indice of the same value, the third is the i indice of the maximum of the matrix $m and the fourth is the j indice of the same value"
.ie n .IP """gsl_matrix_isnull($m)"" \- Return 1 if all the elements of the matrix $m are zero, 0 otherwise" 1
.el .IP "\f(CWgsl_matrix_isnull($m)\fR \- Return 1 if all the elements of the matrix \f(CW$m\fR are zero, 0 otherwise" 1
.IX Item "gsl_matrix_isnull($m) - Return 1 if all the elements of the matrix $m are zero, 0 otherwise"
.ie n .IP """gsl_matrix_ispos($m)"" \- Return 1 if all the elements of the matrix $m are strictly positve, 0 otherwise" 1
.el .IP "\f(CWgsl_matrix_ispos($m)\fR \- Return 1 if all the elements of the matrix \f(CW$m\fR are strictly positve, 0 otherwise" 1
.IX Item "gsl_matrix_ispos($m) - Return 1 if all the elements of the matrix $m are strictly positve, 0 otherwise"
.ie n .IP """gsl_matrix_isneg($m)"" \- Return 1 if all the elements of the matrix $m are strictly negative, 0 otherwise" 1
.el .IP "\f(CWgsl_matrix_isneg($m)\fR \- Return 1 if all the elements of the matrix \f(CW$m\fR are strictly negative, 0 otherwise" 1
.IX Item "gsl_matrix_isneg($m) - Return 1 if all the elements of the matrix $m are strictly negative, 0 otherwise"
.ie n .IP """gsl_matrix_isnonneg($m)"" \- Return 1 if all the elements of the matrix $m are non-negatuive, 0 otherwise" 1
.el .IP "\f(CWgsl_matrix_isnonneg($m)\fR \- Return 1 if all the elements of the matrix \f(CW$m\fR are non-negatuive, 0 otherwise" 1
.IX Item "gsl_matrix_isnonneg($m) - Return 1 if all the elements of the matrix $m are non-negatuive, 0 otherwise"
.ie n .IP """gsl_matrix_add($a, $b)"" \- Add the elements of matrix $b to the elements of matrix $a" 1
.el .IP "\f(CWgsl_matrix_add($a, $b)\fR \- Add the elements of matrix \f(CW$b\fR to the elements of matrix \f(CW$a\fR" 1
.IX Item "gsl_matrix_add($a, $b) - Add the elements of matrix $b to the elements of matrix $a"
.ie n .IP """gsl_matrix_sub($a, $b)"" \- Subtract the elements of matrix $b from the elements of matrix $a" 1
.el .IP "\f(CWgsl_matrix_sub($a, $b)\fR \- Subtract the elements of matrix \f(CW$b\fR from the elements of matrix \f(CW$a\fR" 1
.IX Item "gsl_matrix_sub($a, $b) - Subtract the elements of matrix $b from the elements of matrix $a"
.ie n .IP """gsl_matrix_mul_elements($a, $b)"" \- Multiplie the elements of matrix $a by the elements of matrix $b" 1
.el .IP "\f(CWgsl_matrix_mul_elements($a, $b)\fR \- Multiplie the elements of matrix \f(CW$a\fR by the elements of matrix \f(CW$b\fR" 1
.IX Item "gsl_matrix_mul_elements($a, $b) - Multiplie the elements of matrix $a by the elements of matrix $b"
.ie n .IP """gsl_matrix_div_elements($a, $b)"" \- Divide the elements of matrix $a by the elements of matrix $b" 1
.el .IP "\f(CWgsl_matrix_div_elements($a, $b)\fR \- Divide the elements of matrix \f(CW$a\fR by the elements of matrix \f(CW$b\fR" 1
.IX Item "gsl_matrix_div_elements($a, $b) - Divide the elements of matrix $a by the elements of matrix $b"
.ie n .IP """gsl_matrix_scale($a, $x)"" \- Multiplie the elements of matrix $a by the constant factor $x" 1
.el .IP "\f(CWgsl_matrix_scale($a, $x)\fR \- Multiplie the elements of matrix \f(CW$a\fR by the constant factor \f(CW$x\fR" 1
.IX Item "gsl_matrix_scale($a, $x) - Multiplie the elements of matrix $a by the constant factor $x"
.ie n .IP """gsl_matrix_add_constant($a, $x)"" \- Add the constant value $x to the elements of the matrix $a" 1
.el .IP "\f(CWgsl_matrix_add_constant($a, $x)\fR \- Add the constant value \f(CW$x\fR to the elements of the matrix \f(CW$a\fR" 1
.IX Item "gsl_matrix_add_constant($a, $x) - Add the constant value $x to the elements of the matrix $a"
.ie n .IP """gsl_matrix_add_diagonal($a, $x)"" \- Add the constant value $x to the elements of the diagonal of the matrix $a" 1
.el .IP "\f(CWgsl_matrix_add_diagonal($a, $x)\fR \- Add the constant value \f(CW$x\fR to the elements of the diagonal of the matrix \f(CW$a\fR" 1
.IX Item "gsl_matrix_add_diagonal($a, $x) - Add the constant value $x to the elements of the diagonal of the matrix $a"
.ie n .IP """gsl_matrix_get_row($v, $m, $i)"" \- Copy the elements of the $i\-th row of the matrix $m into the vector $v. The lenght of the vector must be of the same as the lenght of the row. The function returns 0 if it succeded, 1 otherwise." 1
.el .IP "\f(CWgsl_matrix_get_row($v, $m, $i)\fR \- Copy the elements of the \f(CW$i\fR\-th row of the matrix \f(CW$m\fR into the vector \f(CW$v\fR. The lenght of the vector must be of the same as the lenght of the row. The function returns 0 if it succeded, 1 otherwise." 1
.IX Item "gsl_matrix_get_row($v, $m, $i) - Copy the elements of the $i-th row of the matrix $m into the vector $v. The lenght of the vector must be of the same as the lenght of the row. The function returns 0 if it succeded, 1 otherwise."
.ie n .IP """gsl_matrix_get_col($v, $m, $i)"" \- Copy the elements of the $j\-th column of the matrix $m into the vector $v. The lenght of the vector must be of the same as the lenght of the column. The function returns 0 if it succeded, 1 otherwise." 1
.el .IP "\f(CWgsl_matrix_get_col($v, $m, $i)\fR \- Copy the elements of the \f(CW$j\fR\-th column of the matrix \f(CW$m\fR into the vector \f(CW$v\fR. The lenght of the vector must be of the same as the lenght of the column. The function returns 0 if it succeded, 1 otherwise." 1
.IX Item "gsl_matrix_get_col($v, $m, $i) - Copy the elements of the $j-th column of the matrix $m into the vector $v. The lenght of the vector must be of the same as the lenght of the column. The function returns 0 if it succeded, 1 otherwise."
.ie n .IP """gsl_matrix_set_row($m, $i, $v)"" \- Copy the elements of vector $v into the $i\-th row of the matrix $m The lenght of the vector must be of the same as the lenght of the row. The function returns 0 if it succeded, 1 otherwise." 1
.el .IP "\f(CWgsl_matrix_set_row($m, $i, $v)\fR \- Copy the elements of vector \f(CW$v\fR into the \f(CW$i\fR\-th row of the matrix \f(CW$m\fR The lenght of the vector must be of the same as the lenght of the row. The function returns 0 if it succeded, 1 otherwise." 1
.IX Item "gsl_matrix_set_row($m, $i, $v) - Copy the elements of vector $v into the $i-th row of the matrix $m The lenght of the vector must be of the same as the lenght of the row. The function returns 0 if it succeded, 1 otherwise."
.ie n .IP """gsl_matrix_set_col($m, $j, $v)"" \- Copy the elements of vector $v into the $j\-th row of the matrix $m The lenght of the vector must be of the same as the lenght of the column. The function returns 0 if it succeded, 1 otherwise." 1
.el .IP "\f(CWgsl_matrix_set_col($m, $j, $v)\fR \- Copy the elements of vector \f(CW$v\fR into the \f(CW$j\fR\-th row of the matrix \f(CW$m\fR The lenght of the vector must be of the same as the lenght of the column. The function returns 0 if it succeded, 1 otherwise." 1
.IX Item "gsl_matrix_set_col($m, $j, $v) - Copy the elements of vector $v into the $j-th row of the matrix $m The lenght of the vector must be of the same as the lenght of the column. The function returns 0 if it succeded, 1 otherwise."
.PD
.PP
These are related to constant views of a matrix.
.ie n .IP """gsl_matrix_const_row""" 1
.el .IP "\f(CWgsl_matrix_const_row\fR" 1
.IX Item "gsl_matrix_const_row"
.PD 0
.ie n .IP """gsl_matrix_const_colum""" 1
.el .IP "\f(CWgsl_matrix_const_colum\fR" 1
.IX Item "gsl_matrix_const_colum"
.ie n .IP """gsl_matrix_const_diagonal""" 1
.el .IP "\f(CWgsl_matrix_const_diagonal\fR" 1
.IX Item "gsl_matrix_const_diagonal"
.ie n .IP """gsl_matrix_const_subdiagonal""" 1
.el .IP "\f(CWgsl_matrix_const_subdiagonal\fR" 1
.IX Item "gsl_matrix_const_subdiagonal"
.ie n .IP """gsl_matrix_const_superdiagonal""" 1
.el .IP "\f(CWgsl_matrix_const_superdiagonal\fR" 1
.IX Item "gsl_matrix_const_superdiagonal"
.ie n .IP """gsl_matrix_const_subrow""" 1
.el .IP "\f(CWgsl_matrix_const_subrow\fR" 1
.IX Item "gsl_matrix_const_subrow"
.ie n .IP """gsl_matrix_const_subcolumn""" 1
.el .IP "\f(CWgsl_matrix_const_subcolumn\fR" 1
.IX Item "gsl_matrix_const_subcolumn"
.ie n .IP """gsl_matrix_const_view_array""" 1
.el .IP "\f(CWgsl_matrix_const_view_array\fR" 1
.IX Item "gsl_matrix_const_view_array"
.ie n .IP """gsl_matrix_const_view_array_with_tda""" 1
.el .IP "\f(CWgsl_matrix_const_view_array_with_tda\fR" 1
.IX Item "gsl_matrix_const_view_array_with_tda"
.PD
.PP
The following functions are similar to those above but work with \f(CW\*(C`char\*(C'\fR's and \f(CW\*(C`int\*(C'\fR's. We are not quite
sure if anyone wants these. Please speak up if you do and/or submit some patches to this documentation, please!
.IP "gsl_matrix_const_view_vector" 1
.IX Item "gsl_matrix_const_view_vector"
.PD 0
.IP "gsl_matrix_const_view_vector_with_tda" 1
.IX Item "gsl_matrix_const_view_vector_with_tda"
.IP "gsl_matrix_char_alloc" 1
.IX Item "gsl_matrix_char_alloc"
.IP "gsl_matrix_char_calloc" 1
.IX Item "gsl_matrix_char_calloc"
.IP "gsl_matrix_char_alloc_from_block" 1
.IX Item "gsl_matrix_char_alloc_from_block"
.IP "gsl_matrix_char_alloc_from_matrix" 1
.IX Item "gsl_matrix_char_alloc_from_matrix"
.IP "gsl_vector_char_alloc_row_from_matrix" 1
.IX Item "gsl_vector_char_alloc_row_from_matrix"
.IP "gsl_vector_char_alloc_col_from_matrix" 1
.IX Item "gsl_vector_char_alloc_col_from_matrix"
.IP "gsl_matrix_char_free" 1
.IX Item "gsl_matrix_char_free"
.IP "gsl_matrix_char_submatrix" 1
.IX Item "gsl_matrix_char_submatrix"
.IP "gsl_matrix_char_row" 1
.IX Item "gsl_matrix_char_row"
.IP "gsl_matrix_char_column" 1
.IX Item "gsl_matrix_char_column"
.IP "gsl_matrix_char_diagonal" 1
.IX Item "gsl_matrix_char_diagonal"
.IP "gsl_matrix_char_subdiagonal" 1
.IX Item "gsl_matrix_char_subdiagonal"
.IP "gsl_matrix_char_superdiagonal" 1
.IX Item "gsl_matrix_char_superdiagonal"
.IP "gsl_matrix_char_subrow" 1
.IX Item "gsl_matrix_char_subrow"
.IP "gsl_matrix_char_subcolumn" 1
.IX Item "gsl_matrix_char_subcolumn"
.IP "gsl_matrix_char_view_array" 1
.IX Item "gsl_matrix_char_view_array"
.IP "gsl_matrix_char_view_array_with_tda" 1
.IX Item "gsl_matrix_char_view_array_with_tda"
.IP "gsl_matrix_char_view_vector" 1
.IX Item "gsl_matrix_char_view_vector"
.IP "gsl_matrix_char_view_vector_with_tda" 1
.IX Item "gsl_matrix_char_view_vector_with_tda"
.IP "gsl_matrix_char_const_submatrix" 1
.IX Item "gsl_matrix_char_const_submatrix"
.IP "gsl_matrix_char_const_row" 1
.IX Item "gsl_matrix_char_const_row"
.IP "gsl_matrix_char_const_column" 1
.IX Item "gsl_matrix_char_const_column"
.IP "gsl_matrix_char_const_diagonal" 1
.IX Item "gsl_matrix_char_const_diagonal"
.IP "gsl_matrix_char_const_subdiagonal" 1
.IX Item "gsl_matrix_char_const_subdiagonal"
.IP "gsl_matrix_char_const_superdiagonal" 1
.IX Item "gsl_matrix_char_const_superdiagonal"
.IP "gsl_matrix_char_const_subrow" 1
.IX Item "gsl_matrix_char_const_subrow"
.IP "gsl_matrix_char_const_subcolumn" 1
.IX Item "gsl_matrix_char_const_subcolumn"
.IP "gsl_matrix_char_const_view_array" 1
.IX Item "gsl_matrix_char_const_view_array"
.IP "gsl_matrix_char_const_view_array_with_tda" 1
.IX Item "gsl_matrix_char_const_view_array_with_tda"
.IP "gsl_matrix_char_const_view_vector" 1
.IX Item "gsl_matrix_char_const_view_vector"
.IP "gsl_matrix_char_const_view_vector_with_tda" 1
.IX Item "gsl_matrix_char_const_view_vector_with_tda"
.IP "gsl_matrix_char_get" 1
.IX Item "gsl_matrix_char_get"
.IP "gsl_matrix_char_set" 1
.IX Item "gsl_matrix_char_set"
.IP "gsl_matrix_char_ptr" 1
.IX Item "gsl_matrix_char_ptr"
.IP "gsl_matrix_char_const_ptr" 1
.IX Item "gsl_matrix_char_const_ptr"
.IP "gsl_matrix_char_set_zero" 1
.IX Item "gsl_matrix_char_set_zero"
.IP "gsl_matrix_char_set_identity" 1
.IX Item "gsl_matrix_char_set_identity"
.IP "gsl_matrix_char_set_all" 1
.IX Item "gsl_matrix_char_set_all"
.IP "gsl_matrix_char_fread" 1
.IX Item "gsl_matrix_char_fread"
.IP "gsl_matrix_char_fwrite" 1
.IX Item "gsl_matrix_char_fwrite"
.IP "gsl_matrix_char_fscanf" 1
.IX Item "gsl_matrix_char_fscanf"
.IP "gsl_matrix_char_fprintf" 1
.IX Item "gsl_matrix_char_fprintf"
.IP "gsl_matrix_char_memcpy" 1
.IX Item "gsl_matrix_char_memcpy"
.IP "gsl_matrix_char_swap" 1
.IX Item "gsl_matrix_char_swap"
.IP "gsl_matrix_char_swap_rows" 1
.IX Item "gsl_matrix_char_swap_rows"
.IP "gsl_matrix_char_swap_columns" 1
.IX Item "gsl_matrix_char_swap_columns"
.IP "gsl_matrix_char_swap_rowcol" 1
.IX Item "gsl_matrix_char_swap_rowcol"
.IP "gsl_matrix_char_transpose" 1
.IX Item "gsl_matrix_char_transpose"
.IP "gsl_matrix_char_transpose_memcpy" 1
.IX Item "gsl_matrix_char_transpose_memcpy"
.IP "gsl_matrix_char_max" 1
.IX Item "gsl_matrix_char_max"
.IP "gsl_matrix_char_min" 1
.IX Item "gsl_matrix_char_min"
.IP "gsl_matrix_char_minmax" 1
.IX Item "gsl_matrix_char_minmax"
.IP "gsl_matrix_char_max_index" 1
.IX Item "gsl_matrix_char_max_index"
.IP "gsl_matrix_char_min_index" 1
.IX Item "gsl_matrix_char_min_index"
.IP "gsl_matrix_char_minmax_index" 1
.IX Item "gsl_matrix_char_minmax_index"
.IP "gsl_matrix_char_isnull" 1
.IX Item "gsl_matrix_char_isnull"
.IP "gsl_matrix_char_ispos" 1
.IX Item "gsl_matrix_char_ispos"
.IP "gsl_matrix_char_isneg" 1
.IX Item "gsl_matrix_char_isneg"
.IP "gsl_matrix_char_isnonneg" 1
.IX Item "gsl_matrix_char_isnonneg"
.IP "gsl_matrix_char_add" 1
.IX Item "gsl_matrix_char_add"
.IP "gsl_matrix_char_sub" 1
.IX Item "gsl_matrix_char_sub"
.IP "gsl_matrix_char_mul_elements" 1
.IX Item "gsl_matrix_char_mul_elements"
.IP "gsl_matrix_char_div_elements" 1
.IX Item "gsl_matrix_char_div_elements"
.IP "gsl_matrix_char_scale" 1
.IX Item "gsl_matrix_char_scale"
.IP "gsl_matrix_char_add_constant" 1
.IX Item "gsl_matrix_char_add_constant"
.IP "gsl_matrix_char_add_diagonal" 1
.IX Item "gsl_matrix_char_add_diagonal"
.IP "gsl_matrix_int_alloc" 1
.IX Item "gsl_matrix_int_alloc"
.IP "gsl_matrix_int_calloc" 1
.IX Item "gsl_matrix_int_calloc"
.IP "gsl_matrix_int_alloc_from_block" 1
.IX Item "gsl_matrix_int_alloc_from_block"
.IP "gsl_matrix_int_alloc_from_matrix" 1
.IX Item "gsl_matrix_int_alloc_from_matrix"
.IP "gsl_vector_int_alloc_row_from_matrix" 1
.IX Item "gsl_vector_int_alloc_row_from_matrix"
.IP "gsl_vector_int_alloc_col_from_matrix" 1
.IX Item "gsl_vector_int_alloc_col_from_matrix"
.IP "gsl_matrix_int_free" 1
.IX Item "gsl_matrix_int_free"
.IP "gsl_matrix_int_submatrix" 1
.IX Item "gsl_matrix_int_submatrix"
.IP "gsl_matrix_int_row" 1
.IX Item "gsl_matrix_int_row"
.IP "gsl_matrix_int_column" 1
.IX Item "gsl_matrix_int_column"
.IP "gsl_matrix_int_diagonal" 1
.IX Item "gsl_matrix_int_diagonal"
.IP "gsl_matrix_int_subdiagonal" 1
.IX Item "gsl_matrix_int_subdiagonal"
.IP "gsl_matrix_int_superdiagonal" 1
.IX Item "gsl_matrix_int_superdiagonal"
.IP "gsl_matrix_int_subrow" 1
.IX Item "gsl_matrix_int_subrow"
.IP "gsl_matrix_int_subcolumn" 1
.IX Item "gsl_matrix_int_subcolumn"
.IP "gsl_matrix_int_view_array" 1
.IX Item "gsl_matrix_int_view_array"
.IP "gsl_matrix_int_view_array_with_tda" 1
.IX Item "gsl_matrix_int_view_array_with_tda"
.IP "gsl_matrix_int_view_vector" 1
.IX Item "gsl_matrix_int_view_vector"
.IP "gsl_matrix_int_view_vector_with_tda" 1
.IX Item "gsl_matrix_int_view_vector_with_tda"
.IP "gsl_matrix_int_const_submatrix" 1
.IX Item "gsl_matrix_int_const_submatrix"
.IP "gsl_matrix_int_const_row" 1
.IX Item "gsl_matrix_int_const_row"
.IP "gsl_matrix_int_const_column" 1
.IX Item "gsl_matrix_int_const_column"
.IP "gsl_matrix_int_ptr" 1
.IX Item "gsl_matrix_int_ptr"
.IP "gsl_matrix_int_const_ptr" 1
.IX Item "gsl_matrix_int_const_ptr"
.IP "gsl_matrix_int_set_zero" 1
.IX Item "gsl_matrix_int_set_zero"
.IP "gsl_matrix_int_set_identity" 1
.IX Item "gsl_matrix_int_set_identity"
.IP "gsl_matrix_int_set_all" 1
.IX Item "gsl_matrix_int_set_all"
.IP "gsl_matrix_int_fread" 1
.IX Item "gsl_matrix_int_fread"
.IP "gsl_matrix_int_fwrite" 1
.IX Item "gsl_matrix_int_fwrite"
.IP "gsl_matrix_int_fscanf" 1
.IX Item "gsl_matrix_int_fscanf"
.IP "gsl_matrix_int_fprintf" 1
.IX Item "gsl_matrix_int_fprintf"
.IP "gsl_matrix_int_memcpy" 1
.IX Item "gsl_matrix_int_memcpy"
.IP "gsl_matrix_int_swap" 1
.IX Item "gsl_matrix_int_swap"
.IP "gsl_matrix_int_swap_rows" 1
.IX Item "gsl_matrix_int_swap_rows"
.IP "gsl_matrix_int_swap_columns" 1
.IX Item "gsl_matrix_int_swap_columns"
.IP "gsl_matrix_int_swap_rowcol" 1
.IX Item "gsl_matrix_int_swap_rowcol"
.IP "gsl_matrix_int_transpose" 1
.IX Item "gsl_matrix_int_transpose"
.IP "gsl_matrix_int_transpose_memcpy" 1
.IX Item "gsl_matrix_int_transpose_memcpy"
.IP "gsl_matrix_int_max" 1
.IX Item "gsl_matrix_int_max"
.IP "gsl_matrix_int_min" 1
.IX Item "gsl_matrix_int_min"
.IP "gsl_matrix_int_minmax" 1
.IX Item "gsl_matrix_int_minmax"
.IP "gsl_matrix_int_max_index" 1
.IX Item "gsl_matrix_int_max_index"
.IP "gsl_matrix_int_min_index" 1
.IX Item "gsl_matrix_int_min_index"
.IP "gsl_matrix_int_minmax_index" 1
.IX Item "gsl_matrix_int_minmax_index"
.IP "gsl_matrix_int_isnull" 1
.IX Item "gsl_matrix_int_isnull"
.IP "gsl_matrix_int_ispos" 1
.IX Item "gsl_matrix_int_ispos"
.IP "gsl_matrix_int_isneg" 1
.IX Item "gsl_matrix_int_isneg"
.IP "gsl_matrix_int_isnonneg" 1
.IX Item "gsl_matrix_int_isnonneg"
.IP "gsl_matrix_int_add" 1
.IX Item "gsl_matrix_int_add"
.IP "gsl_matrix_int_sub" 1
.IX Item "gsl_matrix_int_sub"
.IP "gsl_matrix_int_mul_elements" 1
.IX Item "gsl_matrix_int_mul_elements"
.IP "gsl_matrix_int_div_elements" 1
.IX Item "gsl_matrix_int_div_elements"
.IP "gsl_matrix_int_scale" 1
.IX Item "gsl_matrix_int_scale"
.IP "gsl_matrix_int_add_constant" 1
.IX Item "gsl_matrix_int_add_constant"
.IP "gsl_matrix_int_add_diagonal" 1
.IX Item "gsl_matrix_int_add_diagonal"
.PD
.PP
You have to add the functions you want to use inside the qw /put_funtion_here /.
You can also write use Math::GSL::Matrix qw/:all/ to use all avaible functions of the module.
Other tags are also avaible, here is a complete list of all tags for this module :
.ie n .IP """all""" 1
.el .IP "\f(CWall\fR" 1
.IX Item "all"
.PD 0
.ie n .IP """int""" 1
.el .IP "\f(CWint\fR" 1
.IX Item "int"
.ie n .IP """double""" 1
.el .IP "\f(CWdouble\fR" 1
.IX Item "double"
.ie n .IP """char""" 1
.el .IP "\f(CWchar\fR" 1
.IX Item "char"
.ie n .IP """complex""" 1
.el .IP "\f(CWcomplex\fR" 1
.IX Item "complex"
.PD
.PP
For more informations on the functions, we refer you to the \s-1GSL\s0 offcial documentation
<http://www.gnu.org/software/gsl/manual/html_node/>
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 1
\& Most of the examples from this section are perl versions of the examples at L<http://www.gnu.org/software/gsl/manual/html_node/Example\-programs\-for\-matrices.html>
\&
\& The program below shows how to allocate, initialize and read from a matrix using the functions gsl_matrix_alloc, gsl_matrix_set and gsl_matrix_get.
\&
\& use Math::GSL::Matrix qw/:all/;
\& my $m = gsl_matrix_alloc (10,3);
\& for my $i (0..9){
\&    for my $j (0..2){
\&        gsl_matrix_set($m, $i, $j, 0.23 + 100*$i + $j);
\&    }
\& }
\&
\& for my $i (0..99){ # OUT OF RANGE ERROR
\&     for my $j (0..2){
\&        print "m($i, $j) = " . gsl_matrix_get ($m, $i, $j) . "\en";
\&    }
\& }
\& gsl_matrix_free ($m);
\&
\&
\& use Math::GSL::Matrix qw/:all/;
\&
\& my $m = gsl_matrix_alloc (100, 100);
\& my $a = gsl_matrix_alloc (100, 100);
\&
\& for my $i (0..99){
\&     for my $j (0..99){
\&         gsl_matrix_set ($m, $i, $j, 0.23 + $i + $j);
\&     }
\& }
\&
\& The next program shows how to write a matrix to a file.
\&
\& my $out = gsl_fopen("test.dat", "wb");
\& gsl_matrix_fwrite ($out, $m);
\& gsl_fclose ($out);
\&
\& my $in = gsl_fopen("test.dat", "rb");
\& gsl_matrix_fread ($in, $a);
\& gsl_fclose($in);
\&
\& my $k=0;
\& for my $i (0..99){
\&     for my $j (0..99){
\&         $mij = gsl_matrix_get ($m, $i, $j);
\&         $aij = gsl_matrix_get ($a, $i, $j);
\&         $k++ if ($mij != $aij);
\&     }
\& }
\&
\& gsl_matrix_free($m);
\& gsl_matrix_free($a);
\&
\& print "differences = $k (should be zero)\en";
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
Jonathan \*(L"Duke\*(R" Leto <jonathan@leto.net> and Thierry Moisan <thierry.moisan@gmail.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2008\-2011 Jonathan \*(L"Duke\*(R" Leto and Thierry Moisan
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
