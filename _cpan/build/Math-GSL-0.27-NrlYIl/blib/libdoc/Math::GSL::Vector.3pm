.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Math::GSL::Vector 3pm"
.TH Math::GSL::Vector 3pm "2012-08-17" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::GSL::Vector \- Functions concerning vectors
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&    use Math::GSL::Vector qw/:all/;
\&    my $vec1 = Math::GSL::Vector\->new([1, 7, 94, 15 ]);
\&    my $vec2 = $vec1 * 5; 
\&    my $vec3 = Math::GSL::Vector>new(10);   # 10 element zero vector 
\&    my $vec4 = $vec1 + $vec2;
\&
\&    # set the element at index 1 to 9
\&    # and the element at index 3 to 8
\&    $vec3\->set([ 1, 3 ], [ 9, 8 ]);
\&
\&    my @vec = $vec2\->as_list;               # return elements as Perl list
\&
\&    my $dot_product = $vec1 * $vec2;
\&    my $length      = $vec2\->length;
\&    my $first       = $vec1\->get(0);
\&
\&    # access raw GSL object to call low\-level functions
\&    my $raw         = $vec1\->raw;
\&    my $element     = gsl_vector_get($raw, 2);
.Ve
.SH "Objected Oriented Interface to GSL Math::GSL::Vector"
.IX Header "Objected Oriented Interface to GSL Math::GSL::Vector"
.SS "Math::GSL::Vector\->\fInew()\fP"
.IX Subsection "Math::GSL::Vector->new()"
Creates a new Vector of the given size.
.PP
.Vb 1
\&    my $vector = Math::GSL::Vector\->new(3);
.Ve
.PP
You can also create and set directly the values of the vector like this :
.PP
.Vb 1
\&   my $vector = Math::GSL::Vector\->new([2,4,1]);
.Ve
.SS "\fIraw()\fP"
.IX Subsection "raw()"
Get the underlying \s-1GSL\s0 vector object created by \s-1SWIG\s0, useful for using gsl_vector_* functions which do not have an \s-1OO\s0 counterpart.
.PP
.Vb 3
\&    my $vector    = Math::GSL::Vector\->new(3);
\&    my $gsl_vector = $vector\->raw;
\&    my $stuff      = gsl_vector_get($gsl_vector, 1);
.Ve
.SS "\fIswap()\fP"
.IX Subsection "swap()"
Exchanges the values in the vectors \f(CW$v\fR with \f(CW$w\fR by copying.
.PP
.Vb 3
\&    my $v = Math::GSL::Vector\->new([1..5]);
\&    my $w = Math::GSL::Vector\->new([3..7]);
\&    $v\->swap( $w );
.Ve
.SS "\fIreverse()\fP"
.IX Subsection "reverse()"
Reverse the elements in the vector.
.PP
.Vb 1
\&    $v\->reverse;
.Ve
.SS "\fImin()\fP"
.IX Subsection "min()"
Returns the minimum value contained in the vector.
.PP
.Vb 2
\&   my $vector = Math::GSL::Vector\->new([2,4,1]);
\&   my $minimum = $vector\->min;
.Ve
.SS "\fImax()\fP"
.IX Subsection "max()"
Returns the minimum value contained in the vector.
.PP
.Vb 2
\&   my $vector = Math::GSL::Vector\->new([2,4,1]);
\&   my $maximum = $vector\->max;
.Ve
.SS "\fIlength()\fP"
.IX Subsection "length()"
Returns the number of elements contained in the vector.
.PP
.Vb 2
\&   my $vector = Math::GSL::Vector\->new([2,4,1]);
\&   my $length = $vector\->length;
.Ve
.ie n .SS "$v\->norm($p)"
.el .SS "\f(CW$v\fP\->norm($p)"
.IX Subsection "$v->norm($p)"
Returns the p\-norm of \f(CW$v\fR, which defaults to the Euclidean (p=2) norm when no argument is given.
.PP
.Vb 1
\&    my $euclidean_distance = $v\->norm;
.Ve
.SS "normalize($p)"
.IX Subsection "normalize($p)"
Divide each element of a vector by it's norm, hence creating a unit vector.
Returns the vector for chaining.  If you just want the value of the norm
without changing the vector, use \f(CW\*(C`norm()\*(C'\fR. The default value for \f(CW$p\fR is 2,
which gives the familiar Euclidean distance norm.
.PP
.Vb 1
\&    my $unit_vector = $vector\->normalize(2);
.Ve
.PP
is the same as
.PP
.Vb 1
\&    my $unit_vector = $vector\->normalize;
.Ve
.SS "\fIas_list()\fP"
.IX Subsection "as_list()"
Gets the content of a Math::GSL::Vector object as a Perl list.
.PP
.Vb 3
\&    my $vector = Math::GSL::Vector\->new(3);
\&    ...
\&    my @values = $vector\->as_list;
.Ve
.SS "\fIget()\fP"
.IX Subsection "get()"
Gets the value of an of a Math::GSL::Vector object.
.PP
.Vb 3
\&    my $vector = Math::GSL::Vector\->new(3);
\&    ...
\&    my @values = $vector\->get(2);
.Ve
.PP
You can also enter an array of indices to receive their corresponding values:
.PP
.Vb 3
\&    my $vector = Math::GSL::Vector\->new(3);
\&    ...
\&    my @values = $vector\->get([0,2]);
.Ve
.SS "\fIset()\fP"
.IX Subsection "set()"
Sets values of an of a Math::GSL::Vector object.
.PP
.Vb 2
\&    my $vector = Math::GSL::Vector\->new(3);
\&    $vector\->set([1,2], [8,23]);
.Ve
.PP
This sets the second and third value to 8 and 23.
.SS "\fIcopy()\fP"
.IX Subsection "copy()"
Returns a copy of the vector, which has the same length and values but resides at a different location in memory.
.PP
.Vb 2
\&    my $vector = Math::GSL::Vector\->new([10 .. 20]);
\&    my $copy   = $vector\->copy;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Here is a list of all the functions included in this module :
.ie n .IP """gsl_vector_alloc($x)""" 1
.el .IP "\f(CWgsl_vector_alloc($x)\fR" 1
.IX Item "gsl_vector_alloc($x)"
Create a vector of size \f(CW$x\fR
.ie n .IP """gsl_vector_calloc($x)""" 1
.el .IP "\f(CWgsl_vector_calloc($x)\fR" 1
.IX Item "gsl_vector_calloc($x)"
Create a vector of size \f(CW$x\fR and initializes all the elements of the vector to zero
.ie n .IP """gsl_vector_alloc_from_block""" 1
.el .IP "\f(CWgsl_vector_alloc_from_block\fR" 1
.IX Item "gsl_vector_alloc_from_block"
.PD 0
.ie n .IP """gsl_vector_alloc_from_vector""" 1
.el .IP "\f(CWgsl_vector_alloc_from_vector\fR" 1
.IX Item "gsl_vector_alloc_from_vector"
.ie n .IP """gsl_vector_free($v)""" 1
.el .IP "\f(CWgsl_vector_free($v)\fR" 1
.IX Item "gsl_vector_free($v)"
.PD
Free a previously allocated vector \f(CW$v\fR
.ie n .IP """gsl_vector_view_array($base, $n)""" 1
.el .IP "\f(CWgsl_vector_view_array($base, $n)\fR" 1
.IX Item "gsl_vector_view_array($base, $n)"
This function returns a vector view of an array reference \f(CW$base\fR. The start of
the new vector is given by \f(CW$base\fR and has \f(CW$n\fR elements. Mathematically, the i\-th
element of the new vector v' is given by, v'(i) = \f(CW$base\fR\->[i] where the index i
runs from 0 to \f(CW$n\fR\-1. The array containing the elements of v is not owned by the
new vector view. When the view goes out of scope the original array will
continue to exist. The original memory can only be deallocated by freeing the
original pointer base. Of course, the original array should not be deallocated
while the view is still in use.
.ie n .IP """gsl_vector_const_view_array($base, $n)""" 1
.el .IP "\f(CWgsl_vector_const_view_array($base, $n)\fR" 1
.IX Item "gsl_vector_const_view_array($base, $n)"
This function is equivalent to gsl_vector_view_array but can be used for arrays which are declared const.
.ie n .IP """gsl_vector_view_array_with_stride($base, $stride, $n)""" 1
.el .IP "\f(CWgsl_vector_view_array_with_stride($base, $stride, $n)\fR" 1
.IX Item "gsl_vector_view_array_with_stride($base, $stride, $n)"
This function returns a vector view of an array reference \f(CW$base\fR with an
additional \f(CW$stride\fR argument. The subvector is formed in the same way as for
gsl_vector_view_array but the new vector has \f(CW$n\fR elements with a step-size of
\&\f(CW$stride\fR from one element to the next in the original array. Mathematically,
the i\-th element of the new vector v' is given by, v'(i) = \f(CW$base\fR\->[i*$stride]
where the index i runs from 0 to \f(CW$n\fR\-1. Note that the view gives direct access
to the underlying elements of the original array. A vector view \f(CW$view\fR can be
passed to any subroutine which takes a vector argument just as a directly
allocated vector would be, using \f(CW$view\fR\->{vector}.
.ie n .IP """gsl_vector_const_view_array_with_stride($base, $stride, $n)""" 1
.el .IP "\f(CWgsl_vector_const_view_array_with_stride($base, $stride, $n)\fR" 1
.IX Item "gsl_vector_const_view_array_with_stride($base, $stride, $n)"
This function is equivalent to gsl_vector_view_array_with_stride but can be
used for arrays which are declared const.
.ie n .IP """gsl_vector_subvector($v, $offset, $n)""" 1
.el .IP "\f(CWgsl_vector_subvector($v, $offset, $n)\fR" 1
.IX Item "gsl_vector_subvector($v, $offset, $n)"
Return a vector_view type which contains a subvector of \f(CW$v\fR, with a size of \f(CW$size\fR, starting from the \f(CW$offset\fR position
.ie n .IP """gsl_vector_subvector_with_stride($v, $offset, $stride, $size)""" 1
.el .IP "\f(CWgsl_vector_subvector_with_stride($v, $offset, $stride, $size)\fR" 1
.IX Item "gsl_vector_subvector_with_stride($v, $offset, $stride, $size)"
Return a vector_view type which contains a subvector of \f(CW$v\fR, with a size of
\&\f(CW$size\fR, starting from the \f(CW$offset\fR position and with a \f(CW$stride\fR step between each
element of \f(CW$v\fR
.ie n .IP """gsl_vector_const_subvector""" 1
.el .IP "\f(CWgsl_vector_const_subvector\fR" 1
.IX Item "gsl_vector_const_subvector"
.PD 0
.ie n .IP """gsl_vector_get($v, $i)""" 1
.el .IP "\f(CWgsl_vector_get($v, $i)\fR" 1
.IX Item "gsl_vector_get($v, $i)"
.PD
Return the \f(CW$i\fR\-th element of a raw vector \f(CW$v\fR, where \f(CW$v\fR is a Math::GSL::Vector object. For example:
.Sp
.Vb 1
\&    my $third_element = gsl_vector_get($v\->raw, 3);
.Ve
.ie n .IP """gsl_vector_set($v, $i, $x)""" 1
.el .IP "\f(CWgsl_vector_set($v, $i, $x)\fR" 1
.IX Item "gsl_vector_set($v, $i, $x)"
Return the vector \f(CW$v\fR with his \f(CW$i\fR\-th element set to \f(CW$x\fR
.ie n .IP """gsl_vector_ptr""" 1
.el .IP "\f(CWgsl_vector_ptr\fR" 1
.IX Item "gsl_vector_ptr"
.PD 0
.ie n .IP """gsl_vector_const_ptr""" 1
.el .IP "\f(CWgsl_vector_const_ptr\fR" 1
.IX Item "gsl_vector_const_ptr"
.ie n .IP """gsl_vector_set_zero($v)""" 1
.el .IP "\f(CWgsl_vector_set_zero($v)\fR" 1
.IX Item "gsl_vector_set_zero($v)"
.PD
.Vb 1
\& set all the elements of $v to 0
.Ve
.ie n .IP """gsl_vector_set_all($v, $x)""" 1
.el .IP "\f(CWgsl_vector_set_all($v, $x)\fR" 1
.IX Item "gsl_vector_set_all($v, $x)"
set all the elements of \f(CW$v\fR to \f(CW$x\fR
.ie n .IP """gsl_vector_set_basis($v, $i)""" 1
.el .IP "\f(CWgsl_vector_set_basis($v, $i)\fR" 1
.IX Item "gsl_vector_set_basis($v, $i)"
set all the elements of \f(CW$v\fR to 0 except for the \f(CW$i\fR\-th element which is set to 1
and return 0 if the operation succeded, 1 otherwise.
.ie n .IP """gsl_vector_fread($file, $v)""" 1
.el .IP "\f(CWgsl_vector_fread($file, $v)\fR" 1
.IX Item "gsl_vector_fread($file, $v)"
This function reads into the vector \f(CW$v\fR from the open stream \f(CW$file\fR opened with
gsl_fopen function from the Math::GSL module in binary format. The vector \f(CW$v\fR
must be preallocated with the correct length since the function uses the size
of \f(CW$v\fR to determine how many bytes to read. The return value is 0 for success
and 1 if there was a problem reading from the file.
.ie n .IP """gsl_vector_fwrite($file, $v)""" 1
.el .IP "\f(CWgsl_vector_fwrite($file, $v)\fR" 1
.IX Item "gsl_vector_fwrite($file, $v)"
This function writes the elements of the vector \f(CW$v\fR to the stream \f(CW$file\fR opened
with gsl_fopen function from the Math::GSL module in binary format. The return
value is 0 for success and 1 if there was a problem writing to the file. Since
the data is written in the native binary format it may not be portable between
different architectures.
.ie n .IP """gsl_vector_fscanf($file, $v)""" 1
.el .IP "\f(CWgsl_vector_fscanf($file, $v)\fR" 1
.IX Item "gsl_vector_fscanf($file, $v)"
This function reads formatted data from the stream \f(CW$file\fR opened with gsl_fopen
function from the Math::GSL module into the vector \f(CW$v\fR. The vector \f(CW$v\fR must be
preallocated with the correct length since the function uses the size of \f(CW$v\fR to
determine how many numbers to read. The function returns 0 for success and 1 if
there was a problem reading from the file.
.ie n .IP """gsl_vector_fprintf($file, $v, $format)""" 1
.el .IP "\f(CWgsl_vector_fprintf($file, $v, $format)\fR" 1
.IX Item "gsl_vector_fprintf($file, $v, $format)"
This function writes the elements of the vector \f(CW$v\fR line-by-line to the stream
\&\f(CW$file\fR opened with gsl_fopen function from the Math::GSL module using the format
specifier \f(CW$format\fR, which should be one of the \*(L"%g\*(R", \*(L"%e\*(R" or \*(L"%f\*(R" formats for
floating point numbers and \*(L"%d\*(R" for integers. The function returns 0 for
success and 1 if there was a problem writing to the file.
.ie n .IP """gsl_vector_memcpy($dest, $src)""" 1
.el .IP "\f(CWgsl_vector_memcpy($dest, $src)\fR" 1
.IX Item "gsl_vector_memcpy($dest, $src)"
This function copies the elements of the vector \f(CW$src\fR into the vector \f(CW$dest\fR and
return 0 if the opertaion succeded, 1 otherwise. The two vectors must have the
same length.
.ie n .IP """gsl_vector_reverse($v)""" 1
.el .IP "\f(CWgsl_vector_reverse($v)\fR" 1
.IX Item "gsl_vector_reverse($v)"
reverse the order of the elements of the vector \f(CW$v\fR and return 0 if the
opertaion succeded, 1 otherwise
.ie n .IP """gsl_vector_swap($v, $v2)""" 1
.el .IP "\f(CWgsl_vector_swap($v, $v2)\fR" 1
.IX Item "gsl_vector_swap($v, $v2)"
swap the values of the vectors \f(CW$v\fR and \f(CW$v2\fR and return 0 if the opertaion
succeded, 1 otherwise
.ie n .IP """gsl_vector_swap_elements($v, $i, $j)""" 1
.el .IP "\f(CWgsl_vector_swap_elements($v, $i, $j)\fR" 1
.IX Item "gsl_vector_swap_elements($v, $i, $j)"
permute the elements at position \f(CW$i\fR and \f(CW$j\fR in the vector \f(CW$v\fR and return 0 if the
operation succeded, 1 otherwise.
.ie n .IP """gsl_vector_max($v)""" 1
.el .IP "\f(CWgsl_vector_max($v)\fR" 1
.IX Item "gsl_vector_max($v)"
.Vb 1
\& return the maximum value in the vector $v
.Ve
.ie n .IP """gsl_vector_min($v)""" 1
.el .IP "\f(CWgsl_vector_min($v)\fR" 1
.IX Item "gsl_vector_min($v)"
return the minimum value in the vector \f(CW$v\fR
.ie n .IP """gsl_vector_minmax($v)""" 1
.el .IP "\f(CWgsl_vector_minmax($v)\fR" 1
.IX Item "gsl_vector_minmax($v)"
return two values, the first is the minimum value in the vector \f(CW$v\fR and the
second is the maximum value.
.ie n .IP """gsl_vector_max_index($v)""" 1
.el .IP "\f(CWgsl_vector_max_index($v)\fR" 1
.IX Item "gsl_vector_max_index($v)"
return the position of the maximum value in the vector \f(CW$v\fR
.ie n .IP """gsl_vector_min_index($v)""" 1
.el .IP "\f(CWgsl_vector_min_index($v)\fR" 1
.IX Item "gsl_vector_min_index($v)"
return the position of the minimum value in the vector \f(CW$v\fR
.ie n .IP """gsl_vector_minmax_index""" 1
.el .IP "\f(CWgsl_vector_minmax_index\fR" 1
.IX Item "gsl_vector_minmax_index"
return two values, the first is the position of the minimum value in the vector
\&\f(CW$v\fR and the second is the position of the maximum value.
.ie n .IP """gsl_vector_add($v, $v2)""" 1
.el .IP "\f(CWgsl_vector_add($v, $v2)\fR" 1
.IX Item "gsl_vector_add($v, $v2)"
add the elements of \f(CW$v2\fR to the elements of \f(CW$v\fR, the two vectors must have the
same length and return 0 if the operation succeded, 1 otherwise.
.ie n .IP """gsl_vector_sub($v, $v2)""" 1
.el .IP "\f(CWgsl_vector_sub($v, $v2)\fR" 1
.IX Item "gsl_vector_sub($v, $v2)"
substract the elements of \f(CW$v2\fR from the elements of \f(CW$v\fR, the two vectors must
have the same length and return 0 if the operation succeded, 1 otherwise.
.ie n .IP """gsl_vector_mul($v, $v2)""" 1
.el .IP "\f(CWgsl_vector_mul($v, $v2)\fR" 1
.IX Item "gsl_vector_mul($v, $v2)"
multiply the elements of \f(CW$v\fR by the elements of \f(CW$v2\fR, the two vectors must have
the same length and return 0 if the operation succeded, 1 otherwise.
.ie n .IP """gsl_vector_div($v, $v2)""" 1
.el .IP "\f(CWgsl_vector_div($v, $v2)\fR" 1
.IX Item "gsl_vector_div($v, $v2)"
divides the elements of \f(CW$v\fR by the elements of \f(CW$v2\fR, the two vectors must have
the same length and return 0 if the operation succeded, 1 otherwise.
.ie n .IP """gsl_vector_scale($v, $x)""" 1
.el .IP "\f(CWgsl_vector_scale($v, $x)\fR" 1
.IX Item "gsl_vector_scale($v, $x)"
multiplty the elements of the vector \f(CW$v\fR by a constant \f(CW$x\fR and return 0 if the
operation succeded, 1 otherwise.
.ie n .IP """gsl_vector_add_constant($v, $x)""" 1
.el .IP "\f(CWgsl_vector_add_constant($v, $x)\fR" 1
.IX Item "gsl_vector_add_constant($v, $x)"
add a constant \f(CW$x\fR to the elements of the vector \f(CW$v\fR and return 0 if the
operation succeded, 1 otherwise.
.ie n .IP """gsl_vector_isnull($v)""" 1
.el .IP "\f(CWgsl_vector_isnull($v)\fR" 1
.IX Item "gsl_vector_isnull($v)"
verify if all the elements of the vector \f(CW$v\fR are null, return 0 if it's the
case, 1 otherwise.
.ie n .IP """gsl_vector_ispos($v)""" 1
.el .IP "\f(CWgsl_vector_ispos($v)\fR" 1
.IX Item "gsl_vector_ispos($v)"
verify if all the elements of the vector \f(CW$v\fR are positive, return 0 if it's the
case, 1 otherwise.
.ie n .IP """gsl_vector_isneg($v)""" 1
.el .IP "\f(CWgsl_vector_isneg($v)\fR" 1
.IX Item "gsl_vector_isneg($v)"
verify if all the elements of the vector \f(CW$v\fR are negative, return 0 if it's the
case, 1 otherwise.
.ie n .IP """gsl_vector_isnonneg($v)""" 1
.el .IP "\f(CWgsl_vector_isnonneg($v)\fR" 1
.IX Item "gsl_vector_isnonneg($v)"
verify if all the elements the vector \f(CW$v\fR are not negative, return 0 if it's the
case, 1 otherwise.
.PP
Precision on the vector_view type : every modification you'll make on a
vector_view will also modify the original vector.  For example, the following
code will zero the even elements of the vector \f(CW$v\fR of length \f(CW$size\fR, while
leaving the odd elements untouched :
.ie n .IP """$v_even= gsl_vector_subvector_with_stride ($v, 0, 2, $size/2);""" 1
.el .IP "\f(CW$v_even= gsl_vector_subvector_with_stride ($v, 0, 2, $size/2);\fR" 1
.IX Item "$v_even= gsl_vector_subvector_with_stride ($v, 0, 2, $size/2);"
.PD 0
.ie n .IP """gsl_vector_set_zero ($v_even\->{vector});""" 1
.el .IP "\f(CWgsl_vector_set_zero ($v_even\->{vector});\fR" 1
.IX Item "gsl_vector_set_zero ($v_even->{vector});"
.PD
.PP
For more informations on the functions, we refer you to the \s-1GSL\s0 offcial documentation: 
<http://www.gnu.org/software/gsl/manual/html_node/>
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Here is an example using both interfaces.
.PP
.Vb 1
\&    use Math::GSL::Vector qw/:all/;
\&
\&    print "We\*(Aqll create this vector : [0,1,4,9,16] \en";
\&    my $vector = Math::GSL::Vector\->new([0,1,4,9,16]);
\&    my ($min, $max) = gsl_vector_minmax_index($vector\->raw);
\&
\&    print "We then check the index value of the maximum and minimum values of the vector. \en";
\&    print "The index of the maximum should be 4 and we received $max \en";
\&    print "The index of the minimum should be 0 and we received $min \en";
\&    print "We\*(Aqll then swap the first and the third elements of the vector \en";
\&
\&    gsl_vector_swap_elements($vector\->raw, 0, 3);
\&    my @got = $vector\->as_list;
\&    print "The vector should now be like this : [9,1,4,0,16] \en";
\&    print "and we received : [ @got ]\en";
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
Jonathan \*(L"Duke\*(R" Leto <jonathan@leto.net> and Thierry Moisan <thierry.moisan@gmail.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2008\-2011 Jonathan \*(L"Duke\*(R" Leto and Thierry Moisan
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
