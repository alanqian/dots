.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Math::GSL::Fit 3pm"
.TH Math::GSL::Fit 3pm "2012-08-17" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::GSL::Fit \- Least\-squares functions for a general linear model with one\- or two\-parameter regression
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Math::GSL::Fit qw/:all/;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The functions in this module perform least-squares fits to a general linear
model, y = X c where y is a vector of n observations, X is an n by p matrix of
predictor variables, and the elements of the vector c are the p unknown
best-fit parameters which are to be estimated.
.PP
Here is a list of all the functions in this module :
.ie n .IP "gsl_fit_linear($x, $xstride, $y, $ystride, $n)" 4
.el .IP "gsl_fit_linear($x, \f(CW$xstride\fR, \f(CW$y\fR, \f(CW$ystride\fR, \f(CW$n\fR)" 4
.IX Item "gsl_fit_linear($x, $xstride, $y, $ystride, $n)"
This function computes the best-fit linear regression coefficients (c0,c1) of
the model Y = c_0 + c_1 X for the dataset ($x, \f(CW$y\fR), two vectors (in form of
arrays) of length \f(CW$n\fR with strides \f(CW$xstride\fR and \f(CW$ystride\fR. The errors on y are
assumed unknown so the variance-covariance matrix for the parameters (c0, c1)
is estimated from the scatter of the points around the best-fit line and
returned via the parameters (cov00, cov01, cov11). The sum of squares of the
residuals from the best-fit line is returned in sumsq. Note: the correlation
coefficient of the data can be computed using gsl_stats_correlation (see
Correlation), it does not depend on the fit. The function returns the following
values in this order : 0 if the operation succeeded, 1 otherwise, c0, c1,
cov00, cov01, cov11 and sumsq.
.ie n .IP "gsl_fit_wlinear($x, $xstride, $w, $wstride, $y, $ystride, $n)" 4
.el .IP "gsl_fit_wlinear($x, \f(CW$xstride\fR, \f(CW$w\fR, \f(CW$wstride\fR, \f(CW$y\fR, \f(CW$ystride\fR, \f(CW$n\fR)" 4
.IX Item "gsl_fit_wlinear($x, $xstride, $w, $wstride, $y, $ystride, $n)"
This function computes the best-fit linear regression coefficients (c0,c1) of
the model Y = c_0 + c_1 X for the weighted dataset ($x, \f(CW$y\fR), two vectors (in
form of arrays) of length \f(CW$n\fR with strides \f(CW$xstride\fR and \f(CW$ystride\fR. The vector
(also in the form of an array) \f(CW$w\fR, of length \f(CW$n\fR and stride \f(CW$wstride\fR, specifies
the weight of each datapoint. The weight is the reciprocal of the variance for
each datapoint in y. The covariance matrix for the parameters (c0, c1) is
computed using the weights and returned via the parameters (cov00, cov01,
cov11). The weighted sum of squares of the residuals from the best-fit line,
\&\echi^2, is returned in chisq. The function returns the following values in this
order : 0 if the operation succeeded, 1 otherwise, c0, c1, cov00, cov01, cov11
and sumsq.
.ie n .IP "gsl_fit_linear_est($x, $c0, $c1, $cov00, $cov01, $cov11)" 4
.el .IP "gsl_fit_linear_est($x, \f(CW$c0\fR, \f(CW$c1\fR, \f(CW$cov00\fR, \f(CW$cov01\fR, \f(CW$cov11\fR)" 4
.IX Item "gsl_fit_linear_est($x, $c0, $c1, $cov00, $cov01, $cov11)"
This function uses the best-fit linear regression coefficients \f(CW$c0\fR, \f(CW$c1\fR and
their covariance \f(CW$cov00\fR, \f(CW$cov01\fR, \f(CW$cov11\fR to compute the fitted function y and
its standard deviation y_err for the model Y = c_0 + c_1 X at the point \f(CW$x\fR. The
function returns the following values in this order : 0 if the operation
succeeded, 1 otherwise, y and y_err.
.ie n .IP "gsl_fit_mul($x, $xstride, $y, $ystride, $n)" 4
.el .IP "gsl_fit_mul($x, \f(CW$xstride\fR, \f(CW$y\fR, \f(CW$ystride\fR, \f(CW$n\fR)" 4
.IX Item "gsl_fit_mul($x, $xstride, $y, $ystride, $n)"
This function computes the best-fit linear regression coefficient c1 of the
model Y = c_1 X for the datasets ($x, \f(CW$y\fR), two vectors (in form of arrays) of
length \f(CW$n\fR with strides \f(CW$xstride\fR and \f(CW$ystride\fR. The errors on y are assumed
unknown so the variance of the parameter c1 is estimated from the scatter of
the points around the best-fit line and returned via the parameter cov11. The
sum of squares of the residuals from the best-fit line is returned in sumsq.
The function returns the following values in this order : 0 if the operation
succeeded, 1 otherwise, c1, cov11 and sumsq.
.ie n .IP "gsl_fit_wmul($x, $xstride, $w, $wstride, $y, $ystride, $n)" 4
.el .IP "gsl_fit_wmul($x, \f(CW$xstride\fR, \f(CW$w\fR, \f(CW$wstride\fR, \f(CW$y\fR, \f(CW$ystride\fR, \f(CW$n\fR)" 4
.IX Item "gsl_fit_wmul($x, $xstride, $w, $wstride, $y, $ystride, $n)"
This function computes the best-fit linear regression coefficient c1 of the
model Y = c_1 X for the weighted datasets ($x, \f(CW$y\fR), two vectors (in form of
arrays) of length \f(CW$n\fR with strides \f(CW$xstride\fR and \f(CW$ystride\fR. The vector (also in
the form of an array) \f(CW$w\fR, of length \f(CW$n\fR and stride \f(CW$wstride\fR, specifies the
weight of each datapoint. The weight is the reciprocal of the variance for each
datapoint in y. The variance of the parameter c1 is computed using the weights
and returned via the parameter cov11. The weighted sum of squares of the
residuals from the best-fit line, \echi^2, is returned in chisq. The function
returns the following values in this order : 0 if the operation succeeded, 1
otherwise, c1, cov11 and sumsq.
.ie n .IP "gsl_fit_mul_est($x, $c1, $cov11)" 4
.el .IP "gsl_fit_mul_est($x, \f(CW$c1\fR, \f(CW$cov11\fR)" 4
.IX Item "gsl_fit_mul_est($x, $c1, $cov11)"
This function uses the best-fit linear regression coefficient \f(CW$c1\fR and its
covariance \f(CW$cov11\fR to compute the fitted function y and its standard deviation
y_err for the model Y = c_1 X at the point \f(CW$x\fR. The function returns the
following values in this order : 0 if the operation succeeded, 1 otherwise, y
and y_err.
.PP
For more informations on the functions, we refer you to the \s-1GSL\s0 offcial
documentation: <http://www.gnu.org/software/gsl/manual/html_node/>
.SH "EXAMPLES"
.IX Header "EXAMPLES"
This example shows how to use the function gsl_fit_linear. It's important to
see that the array passed to to function must be an array reference, not a
simple array. Also when you use strides, you need to initialize all the value
in the range used, otherwise you will get warnings.
.PP
.Vb 10
\&    my @norris_x = (0.2, 337.4, 118.2, 884.6, 10.1, 226.5, 666.3, 996.3,
\&                        448.6, 777.0, 558.2, 0.4, 0.6, 775.5, 666.9, 338.0, 
\&                        447.5, 11.6, 556.0, 228.1, 995.8, 887.6, 120.2, 0.3, 
\&                        0.3, 556.8, 339.1, 887.2, 999.0, 779.0, 11.1, 118.3,
\&                        229.2, 669.1, 448.9, 0.5 ) ;
\&    my @norris_y = ( 0.1, 338.8, 118.1, 888.0, 9.2, 228.1, 668.5, 998.5,
\&                        449.1, 778.9, 559.2, 0.3, 0.1, 778.1, 668.8, 339.3, 
\&                        448.9, 10.8, 557.7, 228.3, 998.0, 888.8, 119.6, 0.3, 
\&                        0.6, 557.6, 339.3, 888.0, 998.5, 778.9, 10.2, 117.6,
\&                        228.9, 668.4, 449.2, 0.2);
\&    my $xstride = 2;
\&    my $wstride = 3;
\&    my $ystride = 5;
\&    my ($x, $w, $y);
\&    for my $i (0 .. 175)
\&    {
\&        $x\->[$i] = 0;
\&        $w\->[$i] = 0;
\&        $y\->[$i] = 0;
\&    }
\&
\&    for my $i (0 .. 35)
\&    {
\&        $x\->[$i*$xstride] = $norris_x[$i];
\&        $w\->[$i*$wstride] = 1.0;
\&        $y\->[$i*$ystride] = $norris_y[$i];
\&    }
\&    my ($status, @results) = gsl_fit_linear($x, $xstride, $y, $ystride, 36);
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
Jonathan \*(L"Duke\*(R" Leto <jonathan@leto.net> and Thierry Moisan <thierry.moisan@gmail.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2008\-2011 Jonathan \*(L"Duke\*(R" Leto and Thierry Moisan
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
