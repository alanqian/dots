.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Math::GSL::BLAS 3pm"
.TH Math::GSL::BLAS 3pm "2012-08-17" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::GSL::BLAS \- Basic Linear Algebra Subprograms
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Math::GSL::BLAS qw/:all/;
\&    use Math::GSL::Matrix qw/:all/;
\&
\&    # matrix\-matrix product of double numbers
\&    my $A = Math::GSL::Matrix\->new(2,2);
\&    $A\->set_row(0, [1, 4]);
\&      \->set_row(1, [3, 2]);
\&    my $B = Math::GSL::Matrix\->new(2,2);
\&    $B\->set_row(0, [2, 1]);
\&      \->set_row(1, [5,3]);
\&    my $C = Math::GSL::Matrix\->new(2,2);
\&    gsl_matrix_set_zero($C\->raw);
\&    gsl_blas_dgemm($CblasNoTrans, $CblasNoTrans, 1, $A\->raw, $B\->raw, 1, $C\->raw);
\&    my @got = $C\->row(0)\->as_list;
\&    print "The resulting matrix is: \en[";
\&    print "$got[0]  $got[1]\en";
\&    @got = $C\->row(1)\->as_list;
\&    print "$got[0]  $got[1] ]\en";
\&
\&    # compute the scalar product of two vectors :
\&    use Math::GSL::Vector qw/:all/;
\&    use Math::GSL::CBLAS qw/:all/;
\&    my $vec1 = Math::GSL::Vector\->new([1,2,3,4,5]);
\&    my $vec2 = Math::GSL::Vector\->new([5,4,3,2,1]);
\&    my ($status, $result) = gsl_blas_ddot($vec1\->raw, $vec2\->raw);
\&    if($status == 0) {
\&        print "The function has succeeded. \en";
\&    }
\&    print "The result of the vector multiplication is $result.\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The functions of this module are divised into 3 levels:
.SS "Level 1 \- Vector operations"
.IX Subsection "Level 1 - Vector operations"
.ie n .IP """gsl_blas_sdsdot""" 3
.el .IP "\f(CWgsl_blas_sdsdot\fR" 3
.IX Item "gsl_blas_sdsdot"
.PD 0
.ie n .IP """gsl_blas_dsdot""" 3
.el .IP "\f(CWgsl_blas_dsdot\fR" 3
.IX Item "gsl_blas_dsdot"
.ie n .IP """gsl_blas_sdot""" 3
.el .IP "\f(CWgsl_blas_sdot\fR" 3
.IX Item "gsl_blas_sdot"
.ie n .IP """gsl_blas_ddot($x, $y)""" 3
.el .IP "\f(CWgsl_blas_ddot($x, $y)\fR" 3
.IX Item "gsl_blas_ddot($x, $y)"
.PD
This function computes the scalar product x^T y for the vectors \f(CW$x\fR and \f(CW$y\fR. The
function returns two values, the first is 0 if the operation suceeded, 1
otherwise and the second value is the result of the computation.
.ie n .IP """gsl_blas_cdotu""" 3
.el .IP "\f(CWgsl_blas_cdotu\fR" 3
.IX Item "gsl_blas_cdotu"
.PD 0
.ie n .IP """gsl_blas_cdotc""" 3
.el .IP "\f(CWgsl_blas_cdotc\fR" 3
.IX Item "gsl_blas_cdotc"
.ie n .IP """gsl_blas_zdotu($x, $y, $dotu)""" 3
.el .IP "\f(CWgsl_blas_zdotu($x, $y, $dotu)\fR" 3
.IX Item "gsl_blas_zdotu($x, $y, $dotu)"
.PD
This function computes the complex scalar product x^T y for the complex vectors
\&\f(CW$x\fR and \f(CW$y\fR, returning the result in the complex number \f(CW$dotu\fR. The function
returns 0 if the operation suceeded, 1 otherwise.
.ie n .IP """gsl_blas_zdotc($x, $y, $dotc)""" 3
.el .IP "\f(CWgsl_blas_zdotc($x, $y, $dotc)\fR" 3
.IX Item "gsl_blas_zdotc($x, $y, $dotc)"
This function computes the complex conjugate scalar product x^H y for the
complex vectors \f(CW$x\fR and \f(CW$y\fR, returning the result in the complex number \f(CW$dotc\fR.
The function returns 0 if the operation suceeded, 1 otherwise.
.ie n .IP """gsl_blas_snrm2"" =item ""gsl_blas_sasum""" 3
.el .IP "\f(CWgsl_blas_snrm2\fR =item \f(CWgsl_blas_sasum\fR" 3
.IX Item "gsl_blas_snrm2 =item gsl_blas_sasum"
.PD 0
.ie n .IP """gsl_blas_dnrm2($x)""" 3
.el .IP "\f(CWgsl_blas_dnrm2($x)\fR" 3
.IX Item "gsl_blas_dnrm2($x)"
.PD
This function computes the Euclidean norm
.Sp
.Vb 1
\&    ||x||_2 = \esqrt {\esum x_i^2}
.Ve
.Sp
of the vector \f(CW$x\fR.
.ie n .IP """gsl_blas_dasum($x)""" 3
.el .IP "\f(CWgsl_blas_dasum($x)\fR" 3
.IX Item "gsl_blas_dasum($x)"
This function computes the absolute sum \esum |x_i| of the elements of the vector \f(CW$x\fR.
.ie n .IP """gsl_blas_scnrm2""" 3
.el .IP "\f(CWgsl_blas_scnrm2\fR" 3
.IX Item "gsl_blas_scnrm2"
.PD 0
.ie n .IP """gsl_blas_scasum""" 3
.el .IP "\f(CWgsl_blas_scasum\fR" 3
.IX Item "gsl_blas_scasum"
.ie n .IP """gsl_blas_dznrm2($x)""" 3
.el .IP "\f(CWgsl_blas_dznrm2($x)\fR" 3
.IX Item "gsl_blas_dznrm2($x)"
.PD
This function computes the Euclidean norm of the complex vector \f(CW$x\fR, ||x||_2 = \esqrt {\esum (\eRe(x_i)^2 + \eIm(x_i)^2)}.
.ie n .IP """gsl_blas_dzasum($x)""" 3
.el .IP "\f(CWgsl_blas_dzasum($x)\fR" 3
.IX Item "gsl_blas_dzasum($x)"
This function computes the sum of the magnitudes of the real and imaginary parts of the complex vector \f(CW$x\fR, \esum |\eRe(x_i)| + |\eIm(x_i)|.
.ie n .IP """gsl_blas_isamax""" 3
.el .IP "\f(CWgsl_blas_isamax\fR" 3
.IX Item "gsl_blas_isamax"
.PD 0
.ie n .IP """gsl_blas_idamax""" 3
.el .IP "\f(CWgsl_blas_idamax\fR" 3
.IX Item "gsl_blas_idamax"
.ie n .IP """gsl_blas_icamax""" 3
.el .IP "\f(CWgsl_blas_icamax\fR" 3
.IX Item "gsl_blas_icamax"
.ie n .IP """gsl_blas_izamax """ 3
.el .IP "\f(CWgsl_blas_izamax \fR" 3
.IX Item "gsl_blas_izamax "
.ie n .IP """gsl_blas_sswap""" 3
.el .IP "\f(CWgsl_blas_sswap\fR" 3
.IX Item "gsl_blas_sswap"
.ie n .IP """gsl_blas_scopy""" 3
.el .IP "\f(CWgsl_blas_scopy\fR" 3
.IX Item "gsl_blas_scopy"
.ie n .IP """gsl_blas_saxpy""" 3
.el .IP "\f(CWgsl_blas_saxpy\fR" 3
.IX Item "gsl_blas_saxpy"
.ie n .IP """gsl_blas_dswap($x, $y)""" 3
.el .IP "\f(CWgsl_blas_dswap($x, $y)\fR" 3
.IX Item "gsl_blas_dswap($x, $y)"
.PD
This function exchanges the elements of the vectors \f(CW$x\fR and \f(CW$y\fR. The function returns 0 if the operation suceeded, 1 otherwise.
.ie n .IP """gsl_blas_dcopy($x, $y)""" 3
.el .IP "\f(CWgsl_blas_dcopy($x, $y)\fR" 3
.IX Item "gsl_blas_dcopy($x, $y)"
This function copies the elements of the vector \f(CW$x\fR into the vector \f(CW$y\fR. The function returns 0 if the operation suceeded, 1 otherwise.
.ie n .IP """gsl_blas_daxpy($alpha, $x, $y)""" 3
.el .IP "\f(CWgsl_blas_daxpy($alpha, $x, $y)\fR" 3
.IX Item "gsl_blas_daxpy($alpha, $x, $y)"
These functions compute the sum \f(CW$y\fR = \f(CW$alpha\fR * \f(CW$x\fR + \f(CW$y\fR for the vectors \f(CW$x\fR and \f(CW$y\fR.
.ie n .IP """gsl_blas_cswap""" 3
.el .IP "\f(CWgsl_blas_cswap\fR" 3
.IX Item "gsl_blas_cswap"
.PD 0
.ie n .IP """gsl_blas_ccopy """ 3
.el .IP "\f(CWgsl_blas_ccopy \fR" 3
.IX Item "gsl_blas_ccopy "
.ie n .IP """gsl_blas_caxpy""" 3
.el .IP "\f(CWgsl_blas_caxpy\fR" 3
.IX Item "gsl_blas_caxpy"
.ie n .IP """gsl_blas_zswap""" 3
.el .IP "\f(CWgsl_blas_zswap\fR" 3
.IX Item "gsl_blas_zswap"
.ie n .IP """gsl_blas_zcopy""" 3
.el .IP "\f(CWgsl_blas_zcopy\fR" 3
.IX Item "gsl_blas_zcopy"
.ie n .IP """gsl_blas_zaxpy """ 3
.el .IP "\f(CWgsl_blas_zaxpy \fR" 3
.IX Item "gsl_blas_zaxpy "
.ie n .IP """gsl_blas_srotg""" 3
.el .IP "\f(CWgsl_blas_srotg\fR" 3
.IX Item "gsl_blas_srotg"
.ie n .IP """gsl_blas_srotmg""" 3
.el .IP "\f(CWgsl_blas_srotmg\fR" 3
.IX Item "gsl_blas_srotmg"
.ie n .IP """gsl_blas_srot""" 3
.el .IP "\f(CWgsl_blas_srot\fR" 3
.IX Item "gsl_blas_srot"
.ie n .IP """gsl_blas_srotm """ 3
.el .IP "\f(CWgsl_blas_srotm \fR" 3
.IX Item "gsl_blas_srotm "
.ie n .IP """gsl_blas_drotg""" 3
.el .IP "\f(CWgsl_blas_drotg\fR" 3
.IX Item "gsl_blas_drotg"
.ie n .IP """gsl_blas_drotmg""" 3
.el .IP "\f(CWgsl_blas_drotmg\fR" 3
.IX Item "gsl_blas_drotmg"
.ie n .IP """gsl_blas_drot($x, $y, $c, $s)""" 3
.el .IP "\f(CWgsl_blas_drot($x, $y, $c, $s)\fR" 3
.IX Item "gsl_blas_drot($x, $y, $c, $s)"
.PD
This function applies a Givens rotation (x', y') = (c x + s y, \-s x + c y) to the vectors \f(CW$x\fR, \f(CW$y\fR.
.ie n .IP """gsl_blas_drotm """ 3
.el .IP "\f(CWgsl_blas_drotm \fR" 3
.IX Item "gsl_blas_drotm "
.PD 0
.ie n .IP """gsl_blas_sscal""" 3
.el .IP "\f(CWgsl_blas_sscal\fR" 3
.IX Item "gsl_blas_sscal"
.ie n .IP """gsl_blas_dscal($alpha, $x)""" 3
.el .IP "\f(CWgsl_blas_dscal($alpha, $x)\fR" 3
.IX Item "gsl_blas_dscal($alpha, $x)"
.PD
This function rescales the vector \f(CW$x\fR by the multiplicative factor \f(CW$alpha\fR.
.ie n .IP """gsl_blas_cscal""" 3
.el .IP "\f(CWgsl_blas_cscal\fR" 3
.IX Item "gsl_blas_cscal"
.PD 0
.ie n .IP """gsl_blas_zscal """ 3
.el .IP "\f(CWgsl_blas_zscal \fR" 3
.IX Item "gsl_blas_zscal "
.ie n .IP """gsl_blas_csscal""" 3
.el .IP "\f(CWgsl_blas_csscal\fR" 3
.IX Item "gsl_blas_csscal"
.ie n .IP """gsl_blas_zdscal""" 3
.el .IP "\f(CWgsl_blas_zdscal\fR" 3
.IX Item "gsl_blas_zdscal"
.PD
.SS "Level 2 \- Matrix-vector operations"
.IX Subsection "Level 2 - Matrix-vector operations"
.ie n .IP """gsl_blas_sgemv""" 3
.el .IP "\f(CWgsl_blas_sgemv\fR" 3
.IX Item "gsl_blas_sgemv"
.PD 0
.ie n .IP """gsl_blas_strmv """ 3
.el .IP "\f(CWgsl_blas_strmv \fR" 3
.IX Item "gsl_blas_strmv "
.ie n .IP """gsl_blas_strsv""" 3
.el .IP "\f(CWgsl_blas_strsv\fR" 3
.IX Item "gsl_blas_strsv"
.ie n .IP """gsl_blas_dgemv($TransA, $alpha, $A, $x, $beta, $y)"" \- This function computes the matrix-vector product and sum y = \ealpha op(A) x + \ebeta y, where op(A) = A, A^T, A^H for $TransA = $CblasNoTrans, $CblasTrans, $CblasConjTrans (constant values coming from the \s-1CBLAS\s0 module). $A is a matrix and $x and $y are vectors. The function returns 0 if the operation suceeded, 1 otherwise." 3
.el .IP "\f(CWgsl_blas_dgemv($TransA, $alpha, $A, $x, $beta, $y)\fR \- This function computes the matrix-vector product and sum y = \ealpha op(A) x + \ebeta y, where op(A) = A, A^T, A^H for \f(CW$TransA\fR = \f(CW$CblasNoTrans\fR, \f(CW$CblasTrans\fR, \f(CW$CblasConjTrans\fR (constant values coming from the \s-1CBLAS\s0 module). \f(CW$A\fR is a matrix and \f(CW$x\fR and \f(CW$y\fR are vectors. The function returns 0 if the operation suceeded, 1 otherwise." 3
.IX Item "gsl_blas_dgemv($TransA, $alpha, $A, $x, $beta, $y) - This function computes the matrix-vector product and sum y = alpha op(A) x + beta y, where op(A) = A, A^T, A^H for $TransA = $CblasNoTrans, $CblasTrans, $CblasConjTrans (constant values coming from the CBLAS module). $A is a matrix and $x and $y are vectors. The function returns 0 if the operation suceeded, 1 otherwise."
.ie n .IP """gsl_blas_dtrmv($Uplo, $TransA, $Diag, $A, $x)"" \- This function computes the matrix-vector product x = op(A) x for the triangular matrix $A, where op(A) = A, A^T, A^H for $TransA = $CblasNoTrans, $CblasTrans, $CblasConjTrans (constant values coming from the \s-1CBLAS\s0 module). When $Uplo is $CblasUpper then the upper triangle of $A is used, and when $Uplo is $CblasLower then the lower triangle of $A is used. If $Diag is $CblasNonUnit then the diagonal of the matrix is used, but if $Diag is $CblasUnit then the diagonal elements of the matrix $A are taken as unity and are not referenced. The function returns 0 if the operation suceeded, 1 otherwise." 3
.el .IP "\f(CWgsl_blas_dtrmv($Uplo, $TransA, $Diag, $A, $x)\fR \- This function computes the matrix-vector product x = op(A) x for the triangular matrix \f(CW$A\fR, where op(A) = A, A^T, A^H for \f(CW$TransA\fR = \f(CW$CblasNoTrans\fR, \f(CW$CblasTrans\fR, \f(CW$CblasConjTrans\fR (constant values coming from the \s-1CBLAS\s0 module). When \f(CW$Uplo\fR is \f(CW$CblasUpper\fR then the upper triangle of \f(CW$A\fR is used, and when \f(CW$Uplo\fR is \f(CW$CblasLower\fR then the lower triangle of \f(CW$A\fR is used. If \f(CW$Diag\fR is \f(CW$CblasNonUnit\fR then the diagonal of the matrix is used, but if \f(CW$Diag\fR is \f(CW$CblasUnit\fR then the diagonal elements of the matrix \f(CW$A\fR are taken as unity and are not referenced. The function returns 0 if the operation suceeded, 1 otherwise." 3
.IX Item "gsl_blas_dtrmv($Uplo, $TransA, $Diag, $A, $x) - This function computes the matrix-vector product x = op(A) x for the triangular matrix $A, where op(A) = A, A^T, A^H for $TransA = $CblasNoTrans, $CblasTrans, $CblasConjTrans (constant values coming from the CBLAS module). When $Uplo is $CblasUpper then the upper triangle of $A is used, and when $Uplo is $CblasLower then the lower triangle of $A is used. If $Diag is $CblasNonUnit then the diagonal of the matrix is used, but if $Diag is $CblasUnit then the diagonal elements of the matrix $A are taken as unity and are not referenced. The function returns 0 if the operation suceeded, 1 otherwise."
.ie n .IP """gsl_blas_dtrsv($Uplo, $TransA, $Diag, $A, $x)"" \- This function computes inv(op(A)) x for the vector $x, where op(A) = A, A^T, A^H for $TransA = $CblasNoTrans, $CblasTrans, $CblasConjTrans (constant values coming from the \s-1CBLAS\s0 module). When $Uplo is $CblasUpper then the upper triangle of $A is used, and when $Uplo is $CblasLower then the lower triangle of $A is used. If $Diag is $CblasNonUnit then the diagonal of the matrix is used, but if $Diag is $CblasUnit then the diagonal elements of the matrix $A are taken as unity and are not referenced. The function returns 0 if the operation suceeded, 1 otherwise." 3
.el .IP "\f(CWgsl_blas_dtrsv($Uplo, $TransA, $Diag, $A, $x)\fR \- This function computes inv(op(A)) x for the vector \f(CW$x\fR, where op(A) = A, A^T, A^H for \f(CW$TransA\fR = \f(CW$CblasNoTrans\fR, \f(CW$CblasTrans\fR, \f(CW$CblasConjTrans\fR (constant values coming from the \s-1CBLAS\s0 module). When \f(CW$Uplo\fR is \f(CW$CblasUpper\fR then the upper triangle of \f(CW$A\fR is used, and when \f(CW$Uplo\fR is \f(CW$CblasLower\fR then the lower triangle of \f(CW$A\fR is used. If \f(CW$Diag\fR is \f(CW$CblasNonUnit\fR then the diagonal of the matrix is used, but if \f(CW$Diag\fR is \f(CW$CblasUnit\fR then the diagonal elements of the matrix \f(CW$A\fR are taken as unity and are not referenced. The function returns 0 if the operation suceeded, 1 otherwise." 3
.IX Item "gsl_blas_dtrsv($Uplo, $TransA, $Diag, $A, $x) - This function computes inv(op(A)) x for the vector $x, where op(A) = A, A^T, A^H for $TransA = $CblasNoTrans, $CblasTrans, $CblasConjTrans (constant values coming from the CBLAS module). When $Uplo is $CblasUpper then the upper triangle of $A is used, and when $Uplo is $CblasLower then the lower triangle of $A is used. If $Diag is $CblasNonUnit then the diagonal of the matrix is used, but if $Diag is $CblasUnit then the diagonal elements of the matrix $A are taken as unity and are not referenced. The function returns 0 if the operation suceeded, 1 otherwise."
.ie n .IP """gsl_blas_cgemv """ 3
.el .IP "\f(CWgsl_blas_cgemv \fR" 3
.IX Item "gsl_blas_cgemv "
.ie n .IP """gsl_blas_ctrmv""" 3
.el .IP "\f(CWgsl_blas_ctrmv\fR" 3
.IX Item "gsl_blas_ctrmv"
.ie n .IP """gsl_blas_ctrsv""" 3
.el .IP "\f(CWgsl_blas_ctrsv\fR" 3
.IX Item "gsl_blas_ctrsv"
.ie n .IP """gsl_blas_zgemv """ 3
.el .IP "\f(CWgsl_blas_zgemv \fR" 3
.IX Item "gsl_blas_zgemv "
.ie n .IP """gsl_blas_ztrmv""" 3
.el .IP "\f(CWgsl_blas_ztrmv\fR" 3
.IX Item "gsl_blas_ztrmv"
.ie n .IP """gsl_blas_ztrsv""" 3
.el .IP "\f(CWgsl_blas_ztrsv\fR" 3
.IX Item "gsl_blas_ztrsv"
.ie n .IP """gsl_blas_ssymv""" 3
.el .IP "\f(CWgsl_blas_ssymv\fR" 3
.IX Item "gsl_blas_ssymv"
.ie n .IP """gsl_blas_sger """ 3
.el .IP "\f(CWgsl_blas_sger \fR" 3
.IX Item "gsl_blas_sger "
.ie n .IP """gsl_blas_ssyr""" 3
.el .IP "\f(CWgsl_blas_ssyr\fR" 3
.IX Item "gsl_blas_ssyr"
.ie n .IP """gsl_blas_ssyr2""" 3
.el .IP "\f(CWgsl_blas_ssyr2\fR" 3
.IX Item "gsl_blas_ssyr2"
.ie n .IP """gsl_blas_dsymv""" 3
.el .IP "\f(CWgsl_blas_dsymv\fR" 3
.IX Item "gsl_blas_dsymv"
.ie n .IP """gsl_blas_dger($alpha, $x, $y, $A)"" \- This function computes the rank\-1 update A = alpha x y^T + A of the matrix $A. $x and $y are vectors. The function returns 0 if the operation suceeded, 1 otherwise." 3
.el .IP "\f(CWgsl_blas_dger($alpha, $x, $y, $A)\fR \- This function computes the rank\-1 update A = alpha x y^T + A of the matrix \f(CW$A\fR. \f(CW$x\fR and \f(CW$y\fR are vectors. The function returns 0 if the operation suceeded, 1 otherwise." 3
.IX Item "gsl_blas_dger($alpha, $x, $y, $A) - This function computes the rank-1 update A = alpha x y^T + A of the matrix $A. $x and $y are vectors. The function returns 0 if the operation suceeded, 1 otherwise."
.ie n .IP """gsl_blas_dsyr($Uplo, $alpha, $x, $A)"" \- This function computes the symmetric rank\-1 update A = \ealpha x x^T + A of the symmetric matrix $A and the vector $x. Since the matrix $A is symmetric only its upper half or lower half need to be stored. When $Uplo is $CblasUpper then the upper triangle and diagonal of $A are used, and when $Uplo is $CblasLower then the lower triangle and diagonal of $A are used. The function returns 0 if the operation suceeded, 1 otherwise." 3
.el .IP "\f(CWgsl_blas_dsyr($Uplo, $alpha, $x, $A)\fR \- This function computes the symmetric rank\-1 update A = \ealpha x x^T + A of the symmetric matrix \f(CW$A\fR and the vector \f(CW$x\fR. Since the matrix \f(CW$A\fR is symmetric only its upper half or lower half need to be stored. When \f(CW$Uplo\fR is \f(CW$CblasUpper\fR then the upper triangle and diagonal of \f(CW$A\fR are used, and when \f(CW$Uplo\fR is \f(CW$CblasLower\fR then the lower triangle and diagonal of \f(CW$A\fR are used. The function returns 0 if the operation suceeded, 1 otherwise." 3
.IX Item "gsl_blas_dsyr($Uplo, $alpha, $x, $A) - This function computes the symmetric rank-1 update A = alpha x x^T + A of the symmetric matrix $A and the vector $x. Since the matrix $A is symmetric only its upper half or lower half need to be stored. When $Uplo is $CblasUpper then the upper triangle and diagonal of $A are used, and when $Uplo is $CblasLower then the lower triangle and diagonal of $A are used. The function returns 0 if the operation suceeded, 1 otherwise."
.ie n .IP """gsl_blas_dsyr2($Uplo, $alpha, $x, $y, $A)"" \- This function computes the symmetric rank\-2 update A = \ealpha x y^T + \ealpha y x^T + A of the symmetric matrix $A, the vector $x and vector $y. Since the matrix $A is symmetric only its upper half or lower half need to be stored. When $Uplo is $CblasUpper then the upper triangle and diagonal of $A are used, and when $Uplo is $CblasLower then the lower triangle and diagonal of $A are used." 3
.el .IP "\f(CWgsl_blas_dsyr2($Uplo, $alpha, $x, $y, $A)\fR \- This function computes the symmetric rank\-2 update A = \ealpha x y^T + \ealpha y x^T + A of the symmetric matrix \f(CW$A\fR, the vector \f(CW$x\fR and vector \f(CW$y\fR. Since the matrix \f(CW$A\fR is symmetric only its upper half or lower half need to be stored. When \f(CW$Uplo\fR is \f(CW$CblasUpper\fR then the upper triangle and diagonal of \f(CW$A\fR are used, and when \f(CW$Uplo\fR is \f(CW$CblasLower\fR then the lower triangle and diagonal of \f(CW$A\fR are used." 3
.IX Item "gsl_blas_dsyr2($Uplo, $alpha, $x, $y, $A) - This function computes the symmetric rank-2 update A = alpha x y^T + alpha y x^T + A of the symmetric matrix $A, the vector $x and vector $y. Since the matrix $A is symmetric only its upper half or lower half need to be stored. When $Uplo is $CblasUpper then the upper triangle and diagonal of $A are used, and when $Uplo is $CblasLower then the lower triangle and diagonal of $A are used."
.ie n .IP """gsl_blas_chemv""" 3
.el .IP "\f(CWgsl_blas_chemv\fR" 3
.IX Item "gsl_blas_chemv"
.ie n .IP """gsl_blas_cgeru """ 3
.el .IP "\f(CWgsl_blas_cgeru \fR" 3
.IX Item "gsl_blas_cgeru "
.ie n .IP """gsl_blas_cgerc""" 3
.el .IP "\f(CWgsl_blas_cgerc\fR" 3
.IX Item "gsl_blas_cgerc"
.ie n .IP """gsl_blas_cher""" 3
.el .IP "\f(CWgsl_blas_cher\fR" 3
.IX Item "gsl_blas_cher"
.ie n .IP """gsl_blas_cher2""" 3
.el .IP "\f(CWgsl_blas_cher2\fR" 3
.IX Item "gsl_blas_cher2"
.ie n .IP """gsl_blas_zhemv """ 3
.el .IP "\f(CWgsl_blas_zhemv \fR" 3
.IX Item "gsl_blas_zhemv "
.ie n .IP """gsl_blas_zgeru($alpha, $x, $y, $A)"" \- This function computes the rank\-1 update A = alpha x y^T + A of the complex matrix $A. $alpha is a complex number and $x and $y are complex vectors. The function returns 0 if the operation suceeded, 1 otherwise." 3
.el .IP "\f(CWgsl_blas_zgeru($alpha, $x, $y, $A)\fR \- This function computes the rank\-1 update A = alpha x y^T + A of the complex matrix \f(CW$A\fR. \f(CW$alpha\fR is a complex number and \f(CW$x\fR and \f(CW$y\fR are complex vectors. The function returns 0 if the operation suceeded, 1 otherwise." 3
.IX Item "gsl_blas_zgeru($alpha, $x, $y, $A) - This function computes the rank-1 update A = alpha x y^T + A of the complex matrix $A. $alpha is a complex number and $x and $y are complex vectors. The function returns 0 if the operation suceeded, 1 otherwise."
.ie n .IP """gsl_blas_zgerc""" 3
.el .IP "\f(CWgsl_blas_zgerc\fR" 3
.IX Item "gsl_blas_zgerc"
.ie n .IP """gsl_blas_zher($Uplo, $alpha, $x, $A)"" \- This function computes the hermitian rank\-1 update A = \ealpha x x^H + A of the hermitian matrix $A and of the complex vector $x. Since the matrix $A is hermitian only its upper half or lower half need to be stored. When $Uplo is $CblasUpper then the upper triangle and diagonal of $A are used, and when $Uplo is $CblasLower then the lower triangle and diagonal of $A are used. The imaginary elements of the diagonal are automatically set to zero. The function returns 0 if the operation suceeded, 1 otherwise." 3
.el .IP "\f(CWgsl_blas_zher($Uplo, $alpha, $x, $A)\fR \- This function computes the hermitian rank\-1 update A = \ealpha x x^H + A of the hermitian matrix \f(CW$A\fR and of the complex vector \f(CW$x\fR. Since the matrix \f(CW$A\fR is hermitian only its upper half or lower half need to be stored. When \f(CW$Uplo\fR is \f(CW$CblasUpper\fR then the upper triangle and diagonal of \f(CW$A\fR are used, and when \f(CW$Uplo\fR is \f(CW$CblasLower\fR then the lower triangle and diagonal of \f(CW$A\fR are used. The imaginary elements of the diagonal are automatically set to zero. The function returns 0 if the operation suceeded, 1 otherwise." 3
.IX Item "gsl_blas_zher($Uplo, $alpha, $x, $A) - This function computes the hermitian rank-1 update A = alpha x x^H + A of the hermitian matrix $A and of the complex vector $x. Since the matrix $A is hermitian only its upper half or lower half need to be stored. When $Uplo is $CblasUpper then the upper triangle and diagonal of $A are used, and when $Uplo is $CblasLower then the lower triangle and diagonal of $A are used. The imaginary elements of the diagonal are automatically set to zero. The function returns 0 if the operation suceeded, 1 otherwise."
.ie n .IP """gsl_blas_zher2 """ 3
.el .IP "\f(CWgsl_blas_zher2 \fR" 3
.IX Item "gsl_blas_zher2 "
.PD
.SS "Level 3 \- Matrix-matrix operations"
.IX Subsection "Level 3 - Matrix-matrix operations"
.ie n .IP """gsl_blas_sgemm""" 3
.el .IP "\f(CWgsl_blas_sgemm\fR" 3
.IX Item "gsl_blas_sgemm"
.PD 0
.ie n .IP """gsl_blas_ssymm""" 3
.el .IP "\f(CWgsl_blas_ssymm\fR" 3
.IX Item "gsl_blas_ssymm"
.ie n .IP """gsl_blas_ssyrk""" 3
.el .IP "\f(CWgsl_blas_ssyrk\fR" 3
.IX Item "gsl_blas_ssyrk"
.ie n .IP """gsl_blas_ssyr2k """ 3
.el .IP "\f(CWgsl_blas_ssyr2k \fR" 3
.IX Item "gsl_blas_ssyr2k "
.ie n .IP """gsl_blas_strmm""" 3
.el .IP "\f(CWgsl_blas_strmm\fR" 3
.IX Item "gsl_blas_strmm"
.ie n .IP """gsl_blas_strsm""" 3
.el .IP "\f(CWgsl_blas_strsm\fR" 3
.IX Item "gsl_blas_strsm"
.ie n .IP """gsl_blas_dgemm($TransA, $TransB, $alpha, $A, $B, $beta, $C)"" \- This function computes the matrix-matrix product and sum C = \ealpha op(A) op(B) + \ebeta C where op(A) = A, A^T, A^H for $TransA = $CblasNoTrans, $CblasTrans, $CblasConjTrans and similarly for the parameter $TransB. The function returns 0 if the operation suceeded, 1 otherwise." 3
.el .IP "\f(CWgsl_blas_dgemm($TransA, $TransB, $alpha, $A, $B, $beta, $C)\fR \- This function computes the matrix-matrix product and sum C = \ealpha op(A) op(B) + \ebeta C where op(A) = A, A^T, A^H for \f(CW$TransA\fR = \f(CW$CblasNoTrans\fR, \f(CW$CblasTrans\fR, \f(CW$CblasConjTrans\fR and similarly for the parameter \f(CW$TransB\fR. The function returns 0 if the operation suceeded, 1 otherwise." 3
.IX Item "gsl_blas_dgemm($TransA, $TransB, $alpha, $A, $B, $beta, $C) - This function computes the matrix-matrix product and sum C = alpha op(A) op(B) + beta C where op(A) = A, A^T, A^H for $TransA = $CblasNoTrans, $CblasTrans, $CblasConjTrans and similarly for the parameter $TransB. The function returns 0 if the operation suceeded, 1 otherwise."
.ie n .IP """gsl_blas_dsymm($Side, $Uplo, $alpha, $A, $B, $beta, $C)"" \- This function computes the matrix-matrix product and sum C = \ealpha A B + \ebeta C for $Side is $CblasLeft and C = \ealpha B A + \ebeta C for $Side is $CblasRight, where the matrix $A is symmetric. When $Uplo is $CblasUpper then the upper triangle and diagonal of $A are used, and when $Uplo is $CblasLower then the lower triangle and diagonal of $A are used. The function returns 0 if the operation suceeded, 1 otherwise." 3
.el .IP "\f(CWgsl_blas_dsymm($Side, $Uplo, $alpha, $A, $B, $beta, $C)\fR \- This function computes the matrix-matrix product and sum C = \ealpha A B + \ebeta C for \f(CW$Side\fR is \f(CW$CblasLeft\fR and C = \ealpha B A + \ebeta C for \f(CW$Side\fR is \f(CW$CblasRight\fR, where the matrix \f(CW$A\fR is symmetric. When \f(CW$Uplo\fR is \f(CW$CblasUpper\fR then the upper triangle and diagonal of \f(CW$A\fR are used, and when \f(CW$Uplo\fR is \f(CW$CblasLower\fR then the lower triangle and diagonal of \f(CW$A\fR are used. The function returns 0 if the operation suceeded, 1 otherwise." 3
.IX Item "gsl_blas_dsymm($Side, $Uplo, $alpha, $A, $B, $beta, $C) - This function computes the matrix-matrix product and sum C = alpha A B + beta C for $Side is $CblasLeft and C = alpha B A + beta C for $Side is $CblasRight, where the matrix $A is symmetric. When $Uplo is $CblasUpper then the upper triangle and diagonal of $A are used, and when $Uplo is $CblasLower then the lower triangle and diagonal of $A are used. The function returns 0 if the operation suceeded, 1 otherwise."
.ie n .IP """gsl_blas_dsyrk($Uplo, $Trans, $alpha, $A, $beta, $C)"" \- This function computes a rank-k update of the symmetric matrix $C, C = \ealpha A A^T + \ebeta C when $Trans is $CblasNoTrans and C = \ealpha A^T A + \ebeta C when $Trans is $CblasTrans. Since the matrix $C is symmetric only its upper half or lower half need to be stored. When $Uplo is $CblasUpper then the upper triangle and diagonal of $C are used, and when $Uplo is $CblasLower then the lower triangle and diagonal of $C are used. The function returns 0 if the operation suceeded, 1 otherwise." 3
.el .IP "\f(CWgsl_blas_dsyrk($Uplo, $Trans, $alpha, $A, $beta, $C)\fR \- This function computes a rank-k update of the symmetric matrix \f(CW$C\fR, C = \ealpha A A^T + \ebeta C when \f(CW$Trans\fR is \f(CW$CblasNoTrans\fR and C = \ealpha A^T A + \ebeta C when \f(CW$Trans\fR is \f(CW$CblasTrans\fR. Since the matrix \f(CW$C\fR is symmetric only its upper half or lower half need to be stored. When \f(CW$Uplo\fR is \f(CW$CblasUpper\fR then the upper triangle and diagonal of \f(CW$C\fR are used, and when \f(CW$Uplo\fR is \f(CW$CblasLower\fR then the lower triangle and diagonal of \f(CW$C\fR are used. The function returns 0 if the operation suceeded, 1 otherwise." 3
.IX Item "gsl_blas_dsyrk($Uplo, $Trans, $alpha, $A, $beta, $C) - This function computes a rank-k update of the symmetric matrix $C, C = alpha A A^T + beta C when $Trans is $CblasNoTrans and C = alpha A^T A + beta C when $Trans is $CblasTrans. Since the matrix $C is symmetric only its upper half or lower half need to be stored. When $Uplo is $CblasUpper then the upper triangle and diagonal of $C are used, and when $Uplo is $CblasLower then the lower triangle and diagonal of $C are used. The function returns 0 if the operation suceeded, 1 otherwise."
.ie n .IP """gsl_blas_dsyr2k($Uplo, $Trans, $alpha, $A, $B, $beta, $C)"" \- This function computes a rank\-2k update of the symmetric matrix $C, C = \ealpha A B^T + \ealpha B A^T + \ebeta C when $Trans is $CblasNoTrans and C = \ealpha A^T B + \ealpha B^T A + \ebeta C when $Trans is $CblasTrans. Since the matrix $C is symmetric only its upper half or lower half need to be stored. When $Uplo is $CblasUpper then the upper triangle and diagonal of $C are used, and when $Uplo is $CblasLower then the lower triangle and diagonal of $C are used. The function returns 0 if the operation suceeded, 1 otherwise." 3
.el .IP "\f(CWgsl_blas_dsyr2k($Uplo, $Trans, $alpha, $A, $B, $beta, $C)\fR \- This function computes a rank\-2k update of the symmetric matrix \f(CW$C\fR, C = \ealpha A B^T + \ealpha B A^T + \ebeta C when \f(CW$Trans\fR is \f(CW$CblasNoTrans\fR and C = \ealpha A^T B + \ealpha B^T A + \ebeta C when \f(CW$Trans\fR is \f(CW$CblasTrans\fR. Since the matrix \f(CW$C\fR is symmetric only its upper half or lower half need to be stored. When \f(CW$Uplo\fR is \f(CW$CblasUpper\fR then the upper triangle and diagonal of \f(CW$C\fR are used, and when \f(CW$Uplo\fR is \f(CW$CblasLower\fR then the lower triangle and diagonal of \f(CW$C\fR are used. The function returns 0 if the operation suceeded, 1 otherwise." 3
.IX Item "gsl_blas_dsyr2k($Uplo, $Trans, $alpha, $A, $B, $beta, $C) - This function computes a rank-2k update of the symmetric matrix $C, C = alpha A B^T + alpha B A^T + beta C when $Trans is $CblasNoTrans and C = alpha A^T B + alpha B^T A + beta C when $Trans is $CblasTrans. Since the matrix $C is symmetric only its upper half or lower half need to be stored. When $Uplo is $CblasUpper then the upper triangle and diagonal of $C are used, and when $Uplo is $CblasLower then the lower triangle and diagonal of $C are used. The function returns 0 if the operation suceeded, 1 otherwise."
.ie n .IP """gsl_blas_dtrmm($Side, $Uplo, $TransA, $Diag, $alpha, $A, $B)"" \- This function computes the matrix-matrix product B = \ealpha op(A) B for $Side is $CblasLeft and B = \ealpha B op(A) for $Side is $CblasRight. The matrix $A is triangular and op(A) = A, A^T, A^H for $TransA = $CblasNoTrans, $CblasTrans, $CblasConjTrans. When $Uplo is $CblasUpper then the upper triangle of $A is used, and when $Uplo is $CblasLower then the lower triangle of $A is used. If $Diag is $CblasNonUnit then the diagonal of $A is used, but if $Diag is $CblasUnit then the diagonal elements of the matrix $A are taken as unity and are not referenced. The function returns 0 if the operation suceeded, 1 otherwise." 3
.el .IP "\f(CWgsl_blas_dtrmm($Side, $Uplo, $TransA, $Diag, $alpha, $A, $B)\fR \- This function computes the matrix-matrix product B = \ealpha op(A) B for \f(CW$Side\fR is \f(CW$CblasLeft\fR and B = \ealpha B op(A) for \f(CW$Side\fR is \f(CW$CblasRight\fR. The matrix \f(CW$A\fR is triangular and op(A) = A, A^T, A^H for \f(CW$TransA\fR = \f(CW$CblasNoTrans\fR, \f(CW$CblasTrans\fR, \f(CW$CblasConjTrans\fR. When \f(CW$Uplo\fR is \f(CW$CblasUpper\fR then the upper triangle of \f(CW$A\fR is used, and when \f(CW$Uplo\fR is \f(CW$CblasLower\fR then the lower triangle of \f(CW$A\fR is used. If \f(CW$Diag\fR is \f(CW$CblasNonUnit\fR then the diagonal of \f(CW$A\fR is used, but if \f(CW$Diag\fR is \f(CW$CblasUnit\fR then the diagonal elements of the matrix \f(CW$A\fR are taken as unity and are not referenced. The function returns 0 if the operation suceeded, 1 otherwise." 3
.IX Item "gsl_blas_dtrmm($Side, $Uplo, $TransA, $Diag, $alpha, $A, $B) - This function computes the matrix-matrix product B = alpha op(A) B for $Side is $CblasLeft and B = alpha B op(A) for $Side is $CblasRight. The matrix $A is triangular and op(A) = A, A^T, A^H for $TransA = $CblasNoTrans, $CblasTrans, $CblasConjTrans. When $Uplo is $CblasUpper then the upper triangle of $A is used, and when $Uplo is $CblasLower then the lower triangle of $A is used. If $Diag is $CblasNonUnit then the diagonal of $A is used, but if $Diag is $CblasUnit then the diagonal elements of the matrix $A are taken as unity and are not referenced. The function returns 0 if the operation suceeded, 1 otherwise."
.ie n .IP """gsl_blas_dtrsm($Side, $Uplo, $TransA, $Diag, $alpha, $A, $B)"" \- This function computes the inverse-matrix matrix product B = \ealpha op(inv(A))B for $Side is $CblasLeft and B = \ealpha B op(inv(A)) for $Side is $CblasRight. The matrix $A is triangular and op(A) = A, A^T, A^H for $TransA = $CblasNoTrans, $CblasTrans, $CblasConjTrans. When $Uplo is $CblasUpper then the upper triangle of $A is used, and when $Uplo is $CblasLower then the lower triangle of $A is used. If $Diag is $CblasNonUnit then the diagonal of $A is used, but if $Diag is $CblasUnit then the diagonal elements of the matrix $A are taken as unity and are not referenced. The function returns 0 if the operation suceeded, 1 otherwise." 3
.el .IP "\f(CWgsl_blas_dtrsm($Side, $Uplo, $TransA, $Diag, $alpha, $A, $B)\fR \- This function computes the inverse-matrix matrix product B = \ealpha op(inv(A))B for \f(CW$Side\fR is \f(CW$CblasLeft\fR and B = \ealpha B op(inv(A)) for \f(CW$Side\fR is \f(CW$CblasRight\fR. The matrix \f(CW$A\fR is triangular and op(A) = A, A^T, A^H for \f(CW$TransA\fR = \f(CW$CblasNoTrans\fR, \f(CW$CblasTrans\fR, \f(CW$CblasConjTrans\fR. When \f(CW$Uplo\fR is \f(CW$CblasUpper\fR then the upper triangle of \f(CW$A\fR is used, and when \f(CW$Uplo\fR is \f(CW$CblasLower\fR then the lower triangle of \f(CW$A\fR is used. If \f(CW$Diag\fR is \f(CW$CblasNonUnit\fR then the diagonal of \f(CW$A\fR is used, but if \f(CW$Diag\fR is \f(CW$CblasUnit\fR then the diagonal elements of the matrix \f(CW$A\fR are taken as unity and are not referenced. The function returns 0 if the operation suceeded, 1 otherwise." 3
.IX Item "gsl_blas_dtrsm($Side, $Uplo, $TransA, $Diag, $alpha, $A, $B) - This function computes the inverse-matrix matrix product B = alpha op(inv(A))B for $Side is $CblasLeft and B = alpha B op(inv(A)) for $Side is $CblasRight. The matrix $A is triangular and op(A) = A, A^T, A^H for $TransA = $CblasNoTrans, $CblasTrans, $CblasConjTrans. When $Uplo is $CblasUpper then the upper triangle of $A is used, and when $Uplo is $CblasLower then the lower triangle of $A is used. If $Diag is $CblasNonUnit then the diagonal of $A is used, but if $Diag is $CblasUnit then the diagonal elements of the matrix $A are taken as unity and are not referenced. The function returns 0 if the operation suceeded, 1 otherwise."
.ie n .IP """gsl_blas_cgemm""" 3
.el .IP "\f(CWgsl_blas_cgemm\fR" 3
.IX Item "gsl_blas_cgemm"
.ie n .IP """gsl_blas_csymm""" 3
.el .IP "\f(CWgsl_blas_csymm\fR" 3
.IX Item "gsl_blas_csymm"
.ie n .IP """gsl_blas_csyrk""" 3
.el .IP "\f(CWgsl_blas_csyrk\fR" 3
.IX Item "gsl_blas_csyrk"
.ie n .IP """gsl_blas_csyr2k """ 3
.el .IP "\f(CWgsl_blas_csyr2k \fR" 3
.IX Item "gsl_blas_csyr2k "
.ie n .IP """gsl_blas_ctrmm""" 3
.el .IP "\f(CWgsl_blas_ctrmm\fR" 3
.IX Item "gsl_blas_ctrmm"
.ie n .IP """gsl_blas_ctrsm""" 3
.el .IP "\f(CWgsl_blas_ctrsm\fR" 3
.IX Item "gsl_blas_ctrsm"
.ie n .IP """gsl_blas_zgemm($TransA, $TransB, $alpha, $A, $B, $beta, $C)"" \- This function computes the matrix-matrix product and sum C = \ealpha op(A) op(B) + \ebeta C where op(A) = A, A^T, A^H for $TransA = $CblasNoTrans, $CblasTrans, $CblasConjTrans and similarly for the parameter $TransB. The function returns 0 if the operation suceeded, 1 otherwise. $A, $B and $C are complex matrices" 3
.el .IP "\f(CWgsl_blas_zgemm($TransA, $TransB, $alpha, $A, $B, $beta, $C)\fR \- This function computes the matrix-matrix product and sum C = \ealpha op(A) op(B) + \ebeta C where op(A) = A, A^T, A^H for \f(CW$TransA\fR = \f(CW$CblasNoTrans\fR, \f(CW$CblasTrans\fR, \f(CW$CblasConjTrans\fR and similarly for the parameter \f(CW$TransB\fR. The function returns 0 if the operation suceeded, 1 otherwise. \f(CW$A\fR, \f(CW$B\fR and \f(CW$C\fR are complex matrices" 3
.IX Item "gsl_blas_zgemm($TransA, $TransB, $alpha, $A, $B, $beta, $C) - This function computes the matrix-matrix product and sum C = alpha op(A) op(B) + beta C where op(A) = A, A^T, A^H for $TransA = $CblasNoTrans, $CblasTrans, $CblasConjTrans and similarly for the parameter $TransB. The function returns 0 if the operation suceeded, 1 otherwise. $A, $B and $C are complex matrices"
.ie n .IP """gsl_blas_zsymm($Side, $Uplo, $alpha, $A, $B, $beta, $C)"" \- This function computes the matrix-matrix product and sum C = \ealpha A B + \ebeta C for $Side is $CblasLeft and C = \ealpha B A + \ebeta C for $Side is $CblasRight, where the matrix $A is symmetric. When $Uplo is $CblasUpper then the upper triangle and diagonal of $A are used, and when $Uplo is $CblasLower then the lower triangle and diagonal of $A are used. $A, $B and $C are complex matrices. The function returns 0 if the operation suceeded, 1 otherwise." 3
.el .IP "\f(CWgsl_blas_zsymm($Side, $Uplo, $alpha, $A, $B, $beta, $C)\fR \- This function computes the matrix-matrix product and sum C = \ealpha A B + \ebeta C for \f(CW$Side\fR is \f(CW$CblasLeft\fR and C = \ealpha B A + \ebeta C for \f(CW$Side\fR is \f(CW$CblasRight\fR, where the matrix \f(CW$A\fR is symmetric. When \f(CW$Uplo\fR is \f(CW$CblasUpper\fR then the upper triangle and diagonal of \f(CW$A\fR are used, and when \f(CW$Uplo\fR is \f(CW$CblasLower\fR then the lower triangle and diagonal of \f(CW$A\fR are used. \f(CW$A\fR, \f(CW$B\fR and \f(CW$C\fR are complex matrices. The function returns 0 if the operation suceeded, 1 otherwise." 3
.IX Item "gsl_blas_zsymm($Side, $Uplo, $alpha, $A, $B, $beta, $C) - This function computes the matrix-matrix product and sum C = alpha A B + beta C for $Side is $CblasLeft and C = alpha B A + beta C for $Side is $CblasRight, where the matrix $A is symmetric. When $Uplo is $CblasUpper then the upper triangle and diagonal of $A are used, and when $Uplo is $CblasLower then the lower triangle and diagonal of $A are used. $A, $B and $C are complex matrices. The function returns 0 if the operation suceeded, 1 otherwise."
.ie n .IP """gsl_blas_zsyrk($Uplo, $Trans, $alpha, $A, $beta, $C)"" \- This function computes a rank-k update of the symmetric complex matrix $C, C = \ealpha A A^T + \ebeta C when $Trans is $CblasNoTrans and C = \ealpha A^T A + \ebeta C when $Trans is $CblasTrans. Since the matrix $C is symmetric only its upper half or lower half need to be stored. When $Uplo is $CblasUpper then the upper triangle and diagonal of $C are used, and when $Uplo is $CblasLower then the lower triangle and diagonal of $C are used. The function returns 0 if the operation suceeded, 1 otherwise." 3
.el .IP "\f(CWgsl_blas_zsyrk($Uplo, $Trans, $alpha, $A, $beta, $C)\fR \- This function computes a rank-k update of the symmetric complex matrix \f(CW$C\fR, C = \ealpha A A^T + \ebeta C when \f(CW$Trans\fR is \f(CW$CblasNoTrans\fR and C = \ealpha A^T A + \ebeta C when \f(CW$Trans\fR is \f(CW$CblasTrans\fR. Since the matrix \f(CW$C\fR is symmetric only its upper half or lower half need to be stored. When \f(CW$Uplo\fR is \f(CW$CblasUpper\fR then the upper triangle and diagonal of \f(CW$C\fR are used, and when \f(CW$Uplo\fR is \f(CW$CblasLower\fR then the lower triangle and diagonal of \f(CW$C\fR are used. The function returns 0 if the operation suceeded, 1 otherwise." 3
.IX Item "gsl_blas_zsyrk($Uplo, $Trans, $alpha, $A, $beta, $C) - This function computes a rank-k update of the symmetric complex matrix $C, C = alpha A A^T + beta C when $Trans is $CblasNoTrans and C = alpha A^T A + beta C when $Trans is $CblasTrans. Since the matrix $C is symmetric only its upper half or lower half need to be stored. When $Uplo is $CblasUpper then the upper triangle and diagonal of $C are used, and when $Uplo is $CblasLower then the lower triangle and diagonal of $C are used. The function returns 0 if the operation suceeded, 1 otherwise."
.ie n .IP """gsl_blas_zsyr2k($Uplo, $Trans, $alpha, $A, $B, $beta, $C)"" \- This function computes a rank\-2k update of the symmetric matrix $C, C = \ealpha A B^T + \ealpha B A^T + \ebeta C when $Trans is $CblasNoTrans and C = \ealpha A^T B + \ealpha B^T A + \ebeta C when $Trans is $CblasTrans. Since the matrix $C is symmetric only its upper half or lower half need to be stored. When $Uplo is $CblasUpper then the upper triangle and diagonal of $C are used, and when $Uplo is $CblasLower then the lower triangle and diagonal of $C are used. The function returns 0 if the operation suceeded, 1 otherwise. $A, $B and $C are complex matrices and $beta is a complex number." 3
.el .IP "\f(CWgsl_blas_zsyr2k($Uplo, $Trans, $alpha, $A, $B, $beta, $C)\fR \- This function computes a rank\-2k update of the symmetric matrix \f(CW$C\fR, C = \ealpha A B^T + \ealpha B A^T + \ebeta C when \f(CW$Trans\fR is \f(CW$CblasNoTrans\fR and C = \ealpha A^T B + \ealpha B^T A + \ebeta C when \f(CW$Trans\fR is \f(CW$CblasTrans\fR. Since the matrix \f(CW$C\fR is symmetric only its upper half or lower half need to be stored. When \f(CW$Uplo\fR is \f(CW$CblasUpper\fR then the upper triangle and diagonal of \f(CW$C\fR are used, and when \f(CW$Uplo\fR is \f(CW$CblasLower\fR then the lower triangle and diagonal of \f(CW$C\fR are used. The function returns 0 if the operation suceeded, 1 otherwise. \f(CW$A\fR, \f(CW$B\fR and \f(CW$C\fR are complex matrices and \f(CW$beta\fR is a complex number." 3
.IX Item "gsl_blas_zsyr2k($Uplo, $Trans, $alpha, $A, $B, $beta, $C) - This function computes a rank-2k update of the symmetric matrix $C, C = alpha A B^T + alpha B A^T + beta C when $Trans is $CblasNoTrans and C = alpha A^T B + alpha B^T A + beta C when $Trans is $CblasTrans. Since the matrix $C is symmetric only its upper half or lower half need to be stored. When $Uplo is $CblasUpper then the upper triangle and diagonal of $C are used, and when $Uplo is $CblasLower then the lower triangle and diagonal of $C are used. The function returns 0 if the operation suceeded, 1 otherwise. $A, $B and $C are complex matrices and $beta is a complex number."
.ie n .IP """gsl_blas_ztrmm($Side, $Uplo, $TransA, $Diag, $alpha, $A, $B)"" \- This function computes the matrix-matrix product B = \ealpha op(A) B for $Side is $CblasLeft and B = \ealpha B op(A) for $Side is $CblasRight. The matrix $A is triangular and op(A) = A, A^T, A^H for $TransA = $CblasNoTrans, $CblasTrans, $CblasConjTrans. When $Uplo is $CblasUpper then the upper triangle of $A is used, and when $Uplo is $CblasLower then the lower triangle of $A is used. If $Diag is $CblasNonUnit then the diagonal of $A is used, but if $Diag is $CblasUnit then the diagonal elements of the matrix $A are taken as unity and are not referenced. The function returns 0 if the operation suceeded, 1 otherwise. $A and $B are complex matrices and $alpha is a complex number." 3
.el .IP "\f(CWgsl_blas_ztrmm($Side, $Uplo, $TransA, $Diag, $alpha, $A, $B)\fR \- This function computes the matrix-matrix product B = \ealpha op(A) B for \f(CW$Side\fR is \f(CW$CblasLeft\fR and B = \ealpha B op(A) for \f(CW$Side\fR is \f(CW$CblasRight\fR. The matrix \f(CW$A\fR is triangular and op(A) = A, A^T, A^H for \f(CW$TransA\fR = \f(CW$CblasNoTrans\fR, \f(CW$CblasTrans\fR, \f(CW$CblasConjTrans\fR. When \f(CW$Uplo\fR is \f(CW$CblasUpper\fR then the upper triangle of \f(CW$A\fR is used, and when \f(CW$Uplo\fR is \f(CW$CblasLower\fR then the lower triangle of \f(CW$A\fR is used. If \f(CW$Diag\fR is \f(CW$CblasNonUnit\fR then the diagonal of \f(CW$A\fR is used, but if \f(CW$Diag\fR is \f(CW$CblasUnit\fR then the diagonal elements of the matrix \f(CW$A\fR are taken as unity and are not referenced. The function returns 0 if the operation suceeded, 1 otherwise. \f(CW$A\fR and \f(CW$B\fR are complex matrices and \f(CW$alpha\fR is a complex number." 3
.IX Item "gsl_blas_ztrmm($Side, $Uplo, $TransA, $Diag, $alpha, $A, $B) - This function computes the matrix-matrix product B = alpha op(A) B for $Side is $CblasLeft and B = alpha B op(A) for $Side is $CblasRight. The matrix $A is triangular and op(A) = A, A^T, A^H for $TransA = $CblasNoTrans, $CblasTrans, $CblasConjTrans. When $Uplo is $CblasUpper then the upper triangle of $A is used, and when $Uplo is $CblasLower then the lower triangle of $A is used. If $Diag is $CblasNonUnit then the diagonal of $A is used, but if $Diag is $CblasUnit then the diagonal elements of the matrix $A are taken as unity and are not referenced. The function returns 0 if the operation suceeded, 1 otherwise. $A and $B are complex matrices and $alpha is a complex number."
.ie n .IP """gsl_blas_ztrsm($Side, $Uplo, $TransA, $Diag, $alpha, $A, $B)"" \- This function computes the inverse-matrix matrix product B = \ealpha op(inv(A))B for $Side is $CblasLeft and B = \ealpha B op(inv(A)) for $Side is $CblasRight. The matrix $A is triangular and op(A) = A, A^T, A^H for $TransA = $CblasNoTrans, $CblasTrans, $CblasConjTrans. When $Uplo is $CblasUpper then the upper triangle of $A is used, and when $Uplo is $CblasLower then the lower triangle of $A is used. If $Diag is $CblasNonUnit then the diagonal of $A is used, but if $Diag is $CblasUnit then the diagonal elements of the matrix $A are taken as unity and are not referenced. The function returns 0 if the operation suceeded, 1 otherwise. $A and $B are complex matrices and $alpha is a complex number." 3
.el .IP "\f(CWgsl_blas_ztrsm($Side, $Uplo, $TransA, $Diag, $alpha, $A, $B)\fR \- This function computes the inverse-matrix matrix product B = \ealpha op(inv(A))B for \f(CW$Side\fR is \f(CW$CblasLeft\fR and B = \ealpha B op(inv(A)) for \f(CW$Side\fR is \f(CW$CblasRight\fR. The matrix \f(CW$A\fR is triangular and op(A) = A, A^T, A^H for \f(CW$TransA\fR = \f(CW$CblasNoTrans\fR, \f(CW$CblasTrans\fR, \f(CW$CblasConjTrans\fR. When \f(CW$Uplo\fR is \f(CW$CblasUpper\fR then the upper triangle of \f(CW$A\fR is used, and when \f(CW$Uplo\fR is \f(CW$CblasLower\fR then the lower triangle of \f(CW$A\fR is used. If \f(CW$Diag\fR is \f(CW$CblasNonUnit\fR then the diagonal of \f(CW$A\fR is used, but if \f(CW$Diag\fR is \f(CW$CblasUnit\fR then the diagonal elements of the matrix \f(CW$A\fR are taken as unity and are not referenced. The function returns 0 if the operation suceeded, 1 otherwise. \f(CW$A\fR and \f(CW$B\fR are complex matrices and \f(CW$alpha\fR is a complex number." 3
.IX Item "gsl_blas_ztrsm($Side, $Uplo, $TransA, $Diag, $alpha, $A, $B) - This function computes the inverse-matrix matrix product B = alpha op(inv(A))B for $Side is $CblasLeft and B = alpha B op(inv(A)) for $Side is $CblasRight. The matrix $A is triangular and op(A) = A, A^T, A^H for $TransA = $CblasNoTrans, $CblasTrans, $CblasConjTrans. When $Uplo is $CblasUpper then the upper triangle of $A is used, and when $Uplo is $CblasLower then the lower triangle of $A is used. If $Diag is $CblasNonUnit then the diagonal of $A is used, but if $Diag is $CblasUnit then the diagonal elements of the matrix $A are taken as unity and are not referenced. The function returns 0 if the operation suceeded, 1 otherwise. $A and $B are complex matrices and $alpha is a complex number."
.ie n .IP """gsl_blas_chemm""" 3
.el .IP "\f(CWgsl_blas_chemm\fR" 3
.IX Item "gsl_blas_chemm"
.ie n .IP """gsl_blas_cherk""" 3
.el .IP "\f(CWgsl_blas_cherk\fR" 3
.IX Item "gsl_blas_cherk"
.ie n .IP """gsl_blas_cher2k""" 3
.el .IP "\f(CWgsl_blas_cher2k\fR" 3
.IX Item "gsl_blas_cher2k"
.ie n .IP """gsl_blas_zhemm($Side, $Uplo, $alpha, $A, $B, $beta, $C)"" \- This function computes the matrix-matrix product and sum C = \ealpha A B + \ebeta C for $Side is $CblasLeft and C = \ealpha B A + \ebeta C for $Side is $CblasRight, where the matrix $A is hermitian. When Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used. The imaginary elements of the diagonal are automatically set to zero." 3
.el .IP "\f(CWgsl_blas_zhemm($Side, $Uplo, $alpha, $A, $B, $beta, $C)\fR \- This function computes the matrix-matrix product and sum C = \ealpha A B + \ebeta C for \f(CW$Side\fR is \f(CW$CblasLeft\fR and C = \ealpha B A + \ebeta C for \f(CW$Side\fR is \f(CW$CblasRight\fR, where the matrix \f(CW$A\fR is hermitian. When Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used. The imaginary elements of the diagonal are automatically set to zero." 3
.IX Item "gsl_blas_zhemm($Side, $Uplo, $alpha, $A, $B, $beta, $C) - This function computes the matrix-matrix product and sum C = alpha A B + beta C for $Side is $CblasLeft and C = alpha B A + beta C for $Side is $CblasRight, where the matrix $A is hermitian. When Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used. The imaginary elements of the diagonal are automatically set to zero."
.ie n .IP """gsl_blas_zherk($Uplo, $Trans, $alpha, $A, $beta, $C)"" \- This function computes a rank-k update of the hermitian matrix $C, C = \ealpha A A^H + \ebeta C when $Trans is $CblasNoTrans and C = \ealpha A^H A + \ebeta C when $Trans is $CblasTrans. Since the matrix $C is hermitian only its upper half or lower half need to be stored. When $Uplo is $CblasUpper then the upper triangle and diagonal of $C are used, and when $Uplo is $CblasLower then the lower triangle and diagonal of $C are used. The imaginary elements of the diagonal are automatically set to zero. The function returns 0 if the operation suceeded, 1 otherwise. $A, $B and $C are complex matrices and $alpha and $beta are complex numbers." 3
.el .IP "\f(CWgsl_blas_zherk($Uplo, $Trans, $alpha, $A, $beta, $C)\fR \- This function computes a rank-k update of the hermitian matrix \f(CW$C\fR, C = \ealpha A A^H + \ebeta C when \f(CW$Trans\fR is \f(CW$CblasNoTrans\fR and C = \ealpha A^H A + \ebeta C when \f(CW$Trans\fR is \f(CW$CblasTrans\fR. Since the matrix \f(CW$C\fR is hermitian only its upper half or lower half need to be stored. When \f(CW$Uplo\fR is \f(CW$CblasUpper\fR then the upper triangle and diagonal of \f(CW$C\fR are used, and when \f(CW$Uplo\fR is \f(CW$CblasLower\fR then the lower triangle and diagonal of \f(CW$C\fR are used. The imaginary elements of the diagonal are automatically set to zero. The function returns 0 if the operation suceeded, 1 otherwise. \f(CW$A\fR, \f(CW$B\fR and \f(CW$C\fR are complex matrices and \f(CW$alpha\fR and \f(CW$beta\fR are complex numbers." 3
.IX Item "gsl_blas_zherk($Uplo, $Trans, $alpha, $A, $beta, $C) - This function computes a rank-k update of the hermitian matrix $C, C = alpha A A^H + beta C when $Trans is $CblasNoTrans and C = alpha A^H A + beta C when $Trans is $CblasTrans. Since the matrix $C is hermitian only its upper half or lower half need to be stored. When $Uplo is $CblasUpper then the upper triangle and diagonal of $C are used, and when $Uplo is $CblasLower then the lower triangle and diagonal of $C are used. The imaginary elements of the diagonal are automatically set to zero. The function returns 0 if the operation suceeded, 1 otherwise. $A, $B and $C are complex matrices and $alpha and $beta are complex numbers."
.ie n .IP """gsl_blas_zher2k($Uplo, $Trans, $alpha, $A, $B, $beta, $C)"" \- This function computes a rank\-2k update of the hermitian matrix $C, C = \ealpha A B^H + \ealpha^* B A^H + \ebeta C when $Trans is $CblasNoTrans and C = \ealpha A^H B + \ealpha^* B^H A + \ebeta C when $Trans is $CblasConjTrans. Since the matrix $C is hermitian only its upper half or lower half need to be stored. When $Uplo is $CblasUpper then the upper triangle and diagonal of $C are used, and when $Uplo is $CblasLower then the lower triangle and diagonal of $C are used. The imaginary elements of the diagonal are automatically set to zero. The function returns 0 if the operation suceeded, 1 otherwise." 3
.el .IP "\f(CWgsl_blas_zher2k($Uplo, $Trans, $alpha, $A, $B, $beta, $C)\fR \- This function computes a rank\-2k update of the hermitian matrix \f(CW$C\fR, C = \ealpha A B^H + \ealpha^* B A^H + \ebeta C when \f(CW$Trans\fR is \f(CW$CblasNoTrans\fR and C = \ealpha A^H B + \ealpha^* B^H A + \ebeta C when \f(CW$Trans\fR is \f(CW$CblasConjTrans\fR. Since the matrix \f(CW$C\fR is hermitian only its upper half or lower half need to be stored. When \f(CW$Uplo\fR is \f(CW$CblasUpper\fR then the upper triangle and diagonal of \f(CW$C\fR are used, and when \f(CW$Uplo\fR is \f(CW$CblasLower\fR then the lower triangle and diagonal of \f(CW$C\fR are used. The imaginary elements of the diagonal are automatically set to zero. The function returns 0 if the operation suceeded, 1 otherwise." 3
.IX Item "gsl_blas_zher2k($Uplo, $Trans, $alpha, $A, $B, $beta, $C) - This function computes a rank-2k update of the hermitian matrix $C, C = alpha A B^H + alpha^* B A^H + beta C when $Trans is $CblasNoTrans and C = alpha A^H B + alpha^* B^H A + beta C when $Trans is $CblasConjTrans. Since the matrix $C is hermitian only its upper half or lower half need to be stored. When $Uplo is $CblasUpper then the upper triangle and diagonal of $C are used, and when $Uplo is $CblasLower then the lower triangle and diagonal of $C are used. The imaginary elements of the diagonal are automatically set to zero. The function returns 0 if the operation suceeded, 1 otherwise."
.PD
.PP
You have to add the functions you want to use inside the qw /put_funtion_here /. 
You can also write use Math::GSL::BLAS qw/:all/ to use all avaible functions of the module. 
Other tags are also avaible, here is a complete list of all tags for this module :
.ie n .IP """level1""" 3
.el .IP "\f(CWlevel1\fR" 3
.IX Item "level1"
.PD 0
.ie n .IP """level2""" 3
.el .IP "\f(CWlevel2\fR" 3
.IX Item "level2"
.ie n .IP """level3""" 3
.el .IP "\f(CWlevel3\fR" 3
.IX Item "level3"
.PD
.PP
For more informations on the functions, we refer you to the \s-1GSL\s0 offcial documentation: <http://www.gnu.org/software/gsl/manual/html_node/>
.SH "AUTHORS"
.IX Header "AUTHORS"
Jonathan \*(L"Duke\*(R" Leto <jonathan@leto.net> and Thierry Moisan <thierry.moisan@gmail.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2008\-2011 Jonathan \*(L"Duke\*(R" Leto and Thierry Moisan
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
