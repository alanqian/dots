.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Math::GSL::Eigen 3pm"
.TH Math::GSL::Eigen 3pm "2012-08-17" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::GSL::Eigen \- Functions for computing eigenvalues and eigenvectors of matrices
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
use Math::GSL::Eigen qw/:all/;
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Here is a list of all the functions included in this module :
.IP "gsl_eigen_symm_alloc($n) \- This function returns a workspace for computing eigenvalues of n\-by-n real symmetric matrices." 4
.IX Item "gsl_eigen_symm_alloc($n) - This function returns a workspace for computing eigenvalues of n-by-n real symmetric matrices."
.PD 0
.ie n .IP "gsl_eigen_symm_free($w) \- This function frees the memory associated with the workspace $w." 4
.el .IP "gsl_eigen_symm_free($w) \- This function frees the memory associated with the workspace \f(CW$w\fR." 4
.IX Item "gsl_eigen_symm_free($w) - This function frees the memory associated with the workspace $w."
.ie n .IP "gsl_eigen_symm($A, $eval, $w) \- This function computes the eigenvalues of the real symmetric matrix $A. Additional workspace of the appropriate size must be provided in $w. The diagonal and lower triangular part of $A are destroyed during the computation, but the strict upper triangular part is not referenced. The eigenvalues are stored in the vector $eval and are unordered." 4
.el .IP "gsl_eigen_symm($A, \f(CW$eval\fR, \f(CW$w\fR) \- This function computes the eigenvalues of the real symmetric matrix \f(CW$A\fR. Additional workspace of the appropriate size must be provided in \f(CW$w\fR. The diagonal and lower triangular part of \f(CW$A\fR are destroyed during the computation, but the strict upper triangular part is not referenced. The eigenvalues are stored in the vector \f(CW$eval\fR and are unordered." 4
.IX Item "gsl_eigen_symm($A, $eval, $w) - This function computes the eigenvalues of the real symmetric matrix $A. Additional workspace of the appropriate size must be provided in $w. The diagonal and lower triangular part of $A are destroyed during the computation, but the strict upper triangular part is not referenced. The eigenvalues are stored in the vector $eval and are unordered."
.IP "gsl_eigen_symmv_alloc($n) \- This function returns a workspace for computing eigenvalues and eigenvectors of n\-by-n real symmetric matrices." 4
.IX Item "gsl_eigen_symmv_alloc($n) - This function returns a workspace for computing eigenvalues and eigenvectors of n-by-n real symmetric matrices."
.ie n .IP "gsl_eigen_symmv_free($w) \- This function frees the memory associated with the workspace $w." 4
.el .IP "gsl_eigen_symmv_free($w) \- This function frees the memory associated with the workspace \f(CW$w\fR." 4
.IX Item "gsl_eigen_symmv_free($w) - This function frees the memory associated with the workspace $w."
.ie n .IP "gsl_eigen_symmv($A, $eval, $evec, $w) \- This function computes the eigenvalues and eigenvectors of the real symmetric matrix $A. Additional workspace of the appropriate size must be provided in $w. The diagonal and lower triangular part of $A are destroyed during the computation, but the strict upper triangular part is not referenced. The eigenvalues are stored in the vector $eval and are unordered. The corresponding eigenvectors are stored in the columns of the matrix $evec." 4
.el .IP "gsl_eigen_symmv($A, \f(CW$eval\fR, \f(CW$evec\fR, \f(CW$w\fR) \- This function computes the eigenvalues and eigenvectors of the real symmetric matrix \f(CW$A\fR. Additional workspace of the appropriate size must be provided in \f(CW$w\fR. The diagonal and lower triangular part of \f(CW$A\fR are destroyed during the computation, but the strict upper triangular part is not referenced. The eigenvalues are stored in the vector \f(CW$eval\fR and are unordered. The corresponding eigenvectors are stored in the columns of the matrix \f(CW$evec\fR." 4
.IX Item "gsl_eigen_symmv($A, $eval, $evec, $w) - This function computes the eigenvalues and eigenvectors of the real symmetric matrix $A. Additional workspace of the appropriate size must be provided in $w. The diagonal and lower triangular part of $A are destroyed during the computation, but the strict upper triangular part is not referenced. The eigenvalues are stored in the vector $eval and are unordered. The corresponding eigenvectors are stored in the columns of the matrix $evec."
.IP "gsl_eigen_herm_alloc($n) \- This function returns a workspace for computing eigenvalues of n\-by-n complex hermitian matrices." 4
.IX Item "gsl_eigen_herm_alloc($n) - This function returns a workspace for computing eigenvalues of n-by-n complex hermitian matrices."
.ie n .IP "gsl_eigen_herm_free($w) \- This function frees the memory associated with the workspace $w." 4
.el .IP "gsl_eigen_herm_free($w) \- This function frees the memory associated with the workspace \f(CW$w\fR." 4
.IX Item "gsl_eigen_herm_free($w) - This function frees the memory associated with the workspace $w."
.ie n .IP "gsl_eigen_herm($A, $eval, $w) \- This function computes the eigenvalues of the complex hermitian matrix $A. Additional workspace of the appropriate size must be provided in $w. The diagonal and lower triangular part of $A are destroyed during the computation, but the strict upper triangular part is not referenced. The imaginary parts of the diagonal are assumed to be zero and are not referenced. The eigenvalues are stored in the vector $eval and are unordered." 4
.el .IP "gsl_eigen_herm($A, \f(CW$eval\fR, \f(CW$w\fR) \- This function computes the eigenvalues of the complex hermitian matrix \f(CW$A\fR. Additional workspace of the appropriate size must be provided in \f(CW$w\fR. The diagonal and lower triangular part of \f(CW$A\fR are destroyed during the computation, but the strict upper triangular part is not referenced. The imaginary parts of the diagonal are assumed to be zero and are not referenced. The eigenvalues are stored in the vector \f(CW$eval\fR and are unordered." 4
.IX Item "gsl_eigen_herm($A, $eval, $w) - This function computes the eigenvalues of the complex hermitian matrix $A. Additional workspace of the appropriate size must be provided in $w. The diagonal and lower triangular part of $A are destroyed during the computation, but the strict upper triangular part is not referenced. The imaginary parts of the diagonal are assumed to be zero and are not referenced. The eigenvalues are stored in the vector $eval and are unordered."
.IP "gsl_eigen_hermv_alloc($n) \- This function returns a workspace for computing eigenvalues and eigenvectors of n\-by-n complex hermitian matrices." 4
.IX Item "gsl_eigen_hermv_alloc($n) - This function returns a workspace for computing eigenvalues and eigenvectors of n-by-n complex hermitian matrices."
.ie n .IP "gsl_eigen_hermv_free($w) \- This function frees the memory associated with the workspace $w." 4
.el .IP "gsl_eigen_hermv_free($w) \- This function frees the memory associated with the workspace \f(CW$w\fR." 4
.IX Item "gsl_eigen_hermv_free($w) - This function frees the memory associated with the workspace $w."
.ie n .IP "gsl_eigen_hermv($A, $eval, $evec, $w) \- This function computes the eigenvalues and eigenvectors of the complex hermitian matrix $A. Additional workspace of the appropriate size must be provided in $w. The diagonal and lower triangular part of $A are destroyed during the computation, but the strict upper triangular part is not referenced. The imaginary parts of the diagonal are assumed to be zero and are not referenced. The eigenvalues are stored in the vector $eval and are unordered. The corresponding complex eigenvectors are stored in the columns of the matrix $evec." 4
.el .IP "gsl_eigen_hermv($A, \f(CW$eval\fR, \f(CW$evec\fR, \f(CW$w\fR) \- This function computes the eigenvalues and eigenvectors of the complex hermitian matrix \f(CW$A\fR. Additional workspace of the appropriate size must be provided in \f(CW$w\fR. The diagonal and lower triangular part of \f(CW$A\fR are destroyed during the computation, but the strict upper triangular part is not referenced. The imaginary parts of the diagonal are assumed to be zero and are not referenced. The eigenvalues are stored in the vector \f(CW$eval\fR and are unordered. The corresponding complex eigenvectors are stored in the columns of the matrix \f(CW$evec\fR." 4
.IX Item "gsl_eigen_hermv($A, $eval, $evec, $w) - This function computes the eigenvalues and eigenvectors of the complex hermitian matrix $A. Additional workspace of the appropriate size must be provided in $w. The diagonal and lower triangular part of $A are destroyed during the computation, but the strict upper triangular part is not referenced. The imaginary parts of the diagonal are assumed to be zero and are not referenced. The eigenvalues are stored in the vector $eval and are unordered. The corresponding complex eigenvectors are stored in the columns of the matrix $evec."
.IP "gsl_eigen_francis_alloc($n) \-" 4
.IX Item "gsl_eigen_francis_alloc($n) -"
.ie n .IP "gsl_eigen_francis_free($w) \- This function frees the memory associated with the workspace $w." 4
.el .IP "gsl_eigen_francis_free($w) \- This function frees the memory associated with the workspace \f(CW$w\fR." 4
.IX Item "gsl_eigen_francis_free($w) - This function frees the memory associated with the workspace $w."
.IP "gsl_eigen_francis_T" 4
.IX Item "gsl_eigen_francis_T"
.IP "gsl_eigen_francis" 4
.IX Item "gsl_eigen_francis"
.IP "gsl_eigen_francis_Z" 4
.IX Item "gsl_eigen_francis_Z"
.IP "gsl_eigen_nonsymm_alloc($n) \- This function returns a workspace for computing eigenvalues of n\-by-n real nonsymmetric matrices." 4
.IX Item "gsl_eigen_nonsymm_alloc($n) - This function returns a workspace for computing eigenvalues of n-by-n real nonsymmetric matrices."
.ie n .IP "gsl_eigen_nonsymm_free($w) \- This function frees the memory associated with the workspace $w." 4
.el .IP "gsl_eigen_nonsymm_free($w) \- This function frees the memory associated with the workspace \f(CW$w\fR." 4
.IX Item "gsl_eigen_nonsymm_free($w) - This function frees the memory associated with the workspace $w."
.ie n .IP "gsl_eigen_nonsymm_params($compute_t, $balance, $w) \- This function sets some parameters which determine how the eigenvalue problem is solved in subsequent calls to gsl_eigen_nonsymm. If $compute_t is set to 1, the full Schur form T will be computed by gsl_eigen_nonsymm. If it is set to 0, T will not be computed (this is the default setting). If balance is set to 1, a balancing transformation is applied to the matrix prior to computing eigenvalues. This transformation is designed to make the rows and columns of the matrix have comparable norms, and can result in more accurate eigenvalues for matrices whose entries vary widely in magnitude." 4
.el .IP "gsl_eigen_nonsymm_params($compute_t, \f(CW$balance\fR, \f(CW$w\fR) \- This function sets some parameters which determine how the eigenvalue problem is solved in subsequent calls to gsl_eigen_nonsymm. If \f(CW$compute_t\fR is set to 1, the full Schur form T will be computed by gsl_eigen_nonsymm. If it is set to 0, T will not be computed (this is the default setting). If balance is set to 1, a balancing transformation is applied to the matrix prior to computing eigenvalues. This transformation is designed to make the rows and columns of the matrix have comparable norms, and can result in more accurate eigenvalues for matrices whose entries vary widely in magnitude." 4
.IX Item "gsl_eigen_nonsymm_params($compute_t, $balance, $w) - This function sets some parameters which determine how the eigenvalue problem is solved in subsequent calls to gsl_eigen_nonsymm. If $compute_t is set to 1, the full Schur form T will be computed by gsl_eigen_nonsymm. If it is set to 0, T will not be computed (this is the default setting). If balance is set to 1, a balancing transformation is applied to the matrix prior to computing eigenvalues. This transformation is designed to make the rows and columns of the matrix have comparable norms, and can result in more accurate eigenvalues for matrices whose entries vary widely in magnitude."
.ie n .IP "gsl_eigen_nonsymm($A, $eval, $w) \- This function computes the eigenvalues of the real nonsymmetric matrix $A and stores them in the vector $eval. If T is desired, it is stored in the upper portion of $A on output. Otherwise, on output, the diagonal of $A will contain the 1\-by\-1 real eigenvalues and 2\-by\-2 complex conjugate eigenvalue systems, and the rest of $A is destroyed. In rare cases, this function may fail to find all eigenvalues. If this happens, an error code is returned (1) and the number of converged eigenvalues is stored in $w\->{n_evals}. The converged eigenvalues are stored in the beginning of $eval." 4
.el .IP "gsl_eigen_nonsymm($A, \f(CW$eval\fR, \f(CW$w\fR) \- This function computes the eigenvalues of the real nonsymmetric matrix \f(CW$A\fR and stores them in the vector \f(CW$eval\fR. If T is desired, it is stored in the upper portion of \f(CW$A\fR on output. Otherwise, on output, the diagonal of \f(CW$A\fR will contain the 1\-by\-1 real eigenvalues and 2\-by\-2 complex conjugate eigenvalue systems, and the rest of \f(CW$A\fR is destroyed. In rare cases, this function may fail to find all eigenvalues. If this happens, an error code is returned (1) and the number of converged eigenvalues is stored in \f(CW$w\fR\->{n_evals}. The converged eigenvalues are stored in the beginning of \f(CW$eval\fR." 4
.IX Item "gsl_eigen_nonsymm($A, $eval, $w) - This function computes the eigenvalues of the real nonsymmetric matrix $A and stores them in the vector $eval. If T is desired, it is stored in the upper portion of $A on output. Otherwise, on output, the diagonal of $A will contain the 1-by-1 real eigenvalues and 2-by-2 complex conjugate eigenvalue systems, and the rest of $A is destroyed. In rare cases, this function may fail to find all eigenvalues. If this happens, an error code is returned (1) and the number of converged eigenvalues is stored in $w->{n_evals}. The converged eigenvalues are stored in the beginning of $eval."
.ie n .IP "gsl_eigen_nonsymm_Z($A, $eval, $Z, $w) \- This function is identical to gsl_eigen_nonsymm except it also computes the Schur vectors and stores them into the $Z matrix." 4
.el .IP "gsl_eigen_nonsymm_Z($A, \f(CW$eval\fR, \f(CW$Z\fR, \f(CW$w\fR) \- This function is identical to gsl_eigen_nonsymm except it also computes the Schur vectors and stores them into the \f(CW$Z\fR matrix." 4
.IX Item "gsl_eigen_nonsymm_Z($A, $eval, $Z, $w) - This function is identical to gsl_eigen_nonsymm except it also computes the Schur vectors and stores them into the $Z matrix."
.IP "gsl_eigen_nonsymmv_alloc($n) \- This function allocates a workspace for computing eigenvalues and eigenvectors of n\-by-n real nonsymmetric matrices." 4
.IX Item "gsl_eigen_nonsymmv_alloc($n) - This function allocates a workspace for computing eigenvalues and eigenvectors of n-by-n real nonsymmetric matrices."
.ie n .IP "gsl_eigen_nonsymmv_free($w) \- This function frees the memory associated with the workspace $w." 4
.el .IP "gsl_eigen_nonsymmv_free($w) \- This function frees the memory associated with the workspace \f(CW$w\fR." 4
.IX Item "gsl_eigen_nonsymmv_free($w) - This function frees the memory associated with the workspace $w."
.ie n .IP "gsl_eigen_nonsymmv($A, $eval, $evec, $w) \- This function computes eigenvalues and right eigenvectors of the n\-by-n real nonsymmetric matrix $A. It first calls gsl_eigen_nonsymm to compute the eigenvalues, Schur form T, and Schur vectors. Then it finds eigenvectors of T and backtransforms them using the Schur vectors. The Schur vectors are destroyed in the process, but can be saved by using gsl_eigen_nonsymmv_Z. The computed eigenvectors are normalized to have unit magnitude. On output, the upper portion of $A contains the Schur form T. If gsl_eigen_nonsymm fails, no eigenvectors are computed, and an error code is returned (1). $eval is a complex vector and $evec is a complex matrix." 4
.el .IP "gsl_eigen_nonsymmv($A, \f(CW$eval\fR, \f(CW$evec\fR, \f(CW$w\fR) \- This function computes eigenvalues and right eigenvectors of the n\-by-n real nonsymmetric matrix \f(CW$A\fR. It first calls gsl_eigen_nonsymm to compute the eigenvalues, Schur form T, and Schur vectors. Then it finds eigenvectors of T and backtransforms them using the Schur vectors. The Schur vectors are destroyed in the process, but can be saved by using gsl_eigen_nonsymmv_Z. The computed eigenvectors are normalized to have unit magnitude. On output, the upper portion of \f(CW$A\fR contains the Schur form T. If gsl_eigen_nonsymm fails, no eigenvectors are computed, and an error code is returned (1). \f(CW$eval\fR is a complex vector and \f(CW$evec\fR is a complex matrix." 4
.IX Item "gsl_eigen_nonsymmv($A, $eval, $evec, $w) - This function computes eigenvalues and right eigenvectors of the n-by-n real nonsymmetric matrix $A. It first calls gsl_eigen_nonsymm to compute the eigenvalues, Schur form T, and Schur vectors. Then it finds eigenvectors of T and backtransforms them using the Schur vectors. The Schur vectors are destroyed in the process, but can be saved by using gsl_eigen_nonsymmv_Z. The computed eigenvectors are normalized to have unit magnitude. On output, the upper portion of $A contains the Schur form T. If gsl_eigen_nonsymm fails, no eigenvectors are computed, and an error code is returned (1). $eval is a complex vector and $evec is a complex matrix."
.ie n .IP "gsl_eigen_nonsymmv_Z($A, $eval, $evec, $Z, $w) \- This function is identical to gsl_eigen_nonsymmv except it also saves the Schur vectors into the $Z matrix." 4
.el .IP "gsl_eigen_nonsymmv_Z($A, \f(CW$eval\fR, \f(CW$evec\fR, \f(CW$Z\fR, \f(CW$w\fR) \- This function is identical to gsl_eigen_nonsymmv except it also saves the Schur vectors into the \f(CW$Z\fR matrix." 4
.IX Item "gsl_eigen_nonsymmv_Z($A, $eval, $evec, $Z, $w) - This function is identical to gsl_eigen_nonsymmv except it also saves the Schur vectors into the $Z matrix."
.IP "gsl_eigen_gensymm_alloc($n) \- This function allocates a workspace for computing eigenvalues of n\-by-n real generalized symmetric-definite eigensystems." 4
.IX Item "gsl_eigen_gensymm_alloc($n) - This function allocates a workspace for computing eigenvalues of n-by-n real generalized symmetric-definite eigensystems."
.ie n .IP "gsl_eigen_gensymm_free($w) \- This function frees the memory associated with the workspace $w." 4
.el .IP "gsl_eigen_gensymm_free($w) \- This function frees the memory associated with the workspace \f(CW$w\fR." 4
.IX Item "gsl_eigen_gensymm_free($w) - This function frees the memory associated with the workspace $w."
.ie n .IP "gsl_eigen_gensymm($A, $B, $eval, $w) \- This function computes the eigenvalues of the real generalized symmetric-definite matrix pair ($A, $B), and stores them in the vector $eval. On output, $B contains its Cholesky decomposition and $A is destroyed." 4
.el .IP "gsl_eigen_gensymm($A, \f(CW$B\fR, \f(CW$eval\fR, \f(CW$w\fR) \- This function computes the eigenvalues of the real generalized symmetric-definite matrix pair ($A, \f(CW$B\fR), and stores them in the vector \f(CW$eval\fR. On output, \f(CW$B\fR contains its Cholesky decomposition and \f(CW$A\fR is destroyed." 4
.IX Item "gsl_eigen_gensymm($A, $B, $eval, $w) - This function computes the eigenvalues of the real generalized symmetric-definite matrix pair ($A, $B), and stores them in the vector $eval. On output, $B contains its Cholesky decomposition and $A is destroyed."
.IP "gsl_eigen_gensymm_standardize" 4
.IX Item "gsl_eigen_gensymm_standardize"
.IP "gsl_eigen_gensymmv_alloc($n) \- This function allocates a workspace for computing eigenvalues and eigenvectors of n\-by-n real generalized symmetric-definite eigensystems." 4
.IX Item "gsl_eigen_gensymmv_alloc($n) - This function allocates a workspace for computing eigenvalues and eigenvectors of n-by-n real generalized symmetric-definite eigensystems."
.ie n .IP "gsl_eigen_gensymmv_free($w) \- This function frees the memory associated with the workspace $w." 4
.el .IP "gsl_eigen_gensymmv_free($w) \- This function frees the memory associated with the workspace \f(CW$w\fR." 4
.IX Item "gsl_eigen_gensymmv_free($w) - This function frees the memory associated with the workspace $w."
.ie n .IP "gsl_eigen_gensymmv($A, $B, $eval, $evec, $w) \- This function computes the eigenvalues and eigenvectors of the real generalized symmetric-definite matrix pair ($A, $B), and stores them in $eval vector and $evec matrix respectively. The computed eigenvectors are normalized to have unit magnitude. On output, $B contains its Cholesky decomposition and A is destroyed." 4
.el .IP "gsl_eigen_gensymmv($A, \f(CW$B\fR, \f(CW$eval\fR, \f(CW$evec\fR, \f(CW$w\fR) \- This function computes the eigenvalues and eigenvectors of the real generalized symmetric-definite matrix pair ($A, \f(CW$B\fR), and stores them in \f(CW$eval\fR vector and \f(CW$evec\fR matrix respectively. The computed eigenvectors are normalized to have unit magnitude. On output, \f(CW$B\fR contains its Cholesky decomposition and A is destroyed." 4
.IX Item "gsl_eigen_gensymmv($A, $B, $eval, $evec, $w) - This function computes the eigenvalues and eigenvectors of the real generalized symmetric-definite matrix pair ($A, $B), and stores them in $eval vector and $evec matrix respectively. The computed eigenvectors are normalized to have unit magnitude. On output, $B contains its Cholesky decomposition and A is destroyed."
.IP "gsl_eigen_genherm_alloc($n) \- This function allocates a workspace for computing eigenvalues of n\-by-n complex generalized hermitian-definite eigensystems." 4
.IX Item "gsl_eigen_genherm_alloc($n) - This function allocates a workspace for computing eigenvalues of n-by-n complex generalized hermitian-definite eigensystems."
.ie n .IP "gsl_eigen_genherm_free($w) \- This function frees the memory associated with the workspace $w." 4
.el .IP "gsl_eigen_genherm_free($w) \- This function frees the memory associated with the workspace \f(CW$w\fR." 4
.IX Item "gsl_eigen_genherm_free($w) - This function frees the memory associated with the workspace $w."
.ie n .IP "gsl_eigen_genherm($A, $B, $eval, $w) \- This function computes the eigenvalues of the complex generalized hermitian-definite matrix pair ($A, $B), and stores them in the $eval vector. On output, $B contains its Cholesky decomposition and $A is destroyed." 4
.el .IP "gsl_eigen_genherm($A, \f(CW$B\fR, \f(CW$eval\fR, \f(CW$w\fR) \- This function computes the eigenvalues of the complex generalized hermitian-definite matrix pair ($A, \f(CW$B\fR), and stores them in the \f(CW$eval\fR vector. On output, \f(CW$B\fR contains its Cholesky decomposition and \f(CW$A\fR is destroyed." 4
.IX Item "gsl_eigen_genherm($A, $B, $eval, $w) - This function computes the eigenvalues of the complex generalized hermitian-definite matrix pair ($A, $B), and stores them in the $eval vector. On output, $B contains its Cholesky decomposition and $A is destroyed."
.IP "gsl_eigen_genherm_standardize" 4
.IX Item "gsl_eigen_genherm_standardize"
.IP "gsl_eigen_genhermv_alloc($n) \- This function allocates a workspace for computing eigenvalues and eigenvectors of n\-by-n complex generalized hermitian-definite eigensystems." 4
.IX Item "gsl_eigen_genhermv_alloc($n) - This function allocates a workspace for computing eigenvalues and eigenvectors of n-by-n complex generalized hermitian-definite eigensystems."
.ie n .IP "gsl_eigen_genhermv_free($w) \- This function frees the memory associated with the workspace $w." 4
.el .IP "gsl_eigen_genhermv_free($w) \- This function frees the memory associated with the workspace \f(CW$w\fR." 4
.IX Item "gsl_eigen_genhermv_free($w) - This function frees the memory associated with the workspace $w."
.ie n .IP "gsl_eigen_genhermv($A, $B, $eval, $evec, $w) \- This function computes the eigenvalues and eigenvectors of the complex generalized hermitian-definite matrix pair ($A, $B), and stores them in $eval vector and $evec matrix respectively. The computed eigenvectors are normalized to have unit magnitude. On output, $B contains its Cholesky decomposition and $A is destroyed." 4
.el .IP "gsl_eigen_genhermv($A, \f(CW$B\fR, \f(CW$eval\fR, \f(CW$evec\fR, \f(CW$w\fR) \- This function computes the eigenvalues and eigenvectors of the complex generalized hermitian-definite matrix pair ($A, \f(CW$B\fR), and stores them in \f(CW$eval\fR vector and \f(CW$evec\fR matrix respectively. The computed eigenvectors are normalized to have unit magnitude. On output, \f(CW$B\fR contains its Cholesky decomposition and \f(CW$A\fR is destroyed." 4
.IX Item "gsl_eigen_genhermv($A, $B, $eval, $evec, $w) - This function computes the eigenvalues and eigenvectors of the complex generalized hermitian-definite matrix pair ($A, $B), and stores them in $eval vector and $evec matrix respectively. The computed eigenvectors are normalized to have unit magnitude. On output, $B contains its Cholesky decomposition and $A is destroyed."
.IP "gsl_eigen_gen_alloc($n) \- This function allocates a workspace for computing eigenvalues of n\-by-n real generalized nonsymmetric eigensystems." 4
.IX Item "gsl_eigen_gen_alloc($n) - This function allocates a workspace for computing eigenvalues of n-by-n real generalized nonsymmetric eigensystems."
.ie n .IP "gsl_eigen_gen_free($w) \- This function frees the memory associated with the workspace $w." 4
.el .IP "gsl_eigen_gen_free($w) \- This function frees the memory associated with the workspace \f(CW$w\fR." 4
.IX Item "gsl_eigen_gen_free($w) - This function frees the memory associated with the workspace $w."
.ie n .IP "gsl_eigen_gen_params($compute_s, $compute_t, $balance, $w) \- This function sets some parameters which determine how the eigenvalue problem is solved in subsequent calls to gsl_eigen_gen. If $compute_s is set to 1, the full Schur form S will be computed by gsl_eigen_gen. If it is set to 0, S will not be computed (this is the default setting). S is a quasi upper triangular matrix with 1\-by\-1 and 2\-by\-2 blocks on its diagonal. 1\-by\-1 blocks correspond to real eigenvalues, and 2\-by\-2 blocks correspond to complex eigenvalues. If $compute_t is set to 1, the full Schur form T will be computed by gsl_eigen_gen. If it is set to 0, T will not be computed (this is the default setting). T is an upper triangular matrix with non-negative elements on its diagonal. Any 2\-by\-2 blocks in S will correspond to a 2\-by\-2 diagonal block in T. The $balance parameter is currently ignored, since generalized balancing is not yet implemented." 4
.el .IP "gsl_eigen_gen_params($compute_s, \f(CW$compute_t\fR, \f(CW$balance\fR, \f(CW$w\fR) \- This function sets some parameters which determine how the eigenvalue problem is solved in subsequent calls to gsl_eigen_gen. If \f(CW$compute_s\fR is set to 1, the full Schur form S will be computed by gsl_eigen_gen. If it is set to 0, S will not be computed (this is the default setting). S is a quasi upper triangular matrix with 1\-by\-1 and 2\-by\-2 blocks on its diagonal. 1\-by\-1 blocks correspond to real eigenvalues, and 2\-by\-2 blocks correspond to complex eigenvalues. If \f(CW$compute_t\fR is set to 1, the full Schur form T will be computed by gsl_eigen_gen. If it is set to 0, T will not be computed (this is the default setting). T is an upper triangular matrix with non-negative elements on its diagonal. Any 2\-by\-2 blocks in S will correspond to a 2\-by\-2 diagonal block in T. The \f(CW$balance\fR parameter is currently ignored, since generalized balancing is not yet implemented." 4
.IX Item "gsl_eigen_gen_params($compute_s, $compute_t, $balance, $w) - This function sets some parameters which determine how the eigenvalue problem is solved in subsequent calls to gsl_eigen_gen. If $compute_s is set to 1, the full Schur form S will be computed by gsl_eigen_gen. If it is set to 0, S will not be computed (this is the default setting). S is a quasi upper triangular matrix with 1-by-1 and 2-by-2 blocks on its diagonal. 1-by-1 blocks correspond to real eigenvalues, and 2-by-2 blocks correspond to complex eigenvalues. If $compute_t is set to 1, the full Schur form T will be computed by gsl_eigen_gen. If it is set to 0, T will not be computed (this is the default setting). T is an upper triangular matrix with non-negative elements on its diagonal. Any 2-by-2 blocks in S will correspond to a 2-by-2 diagonal block in T. The $balance parameter is currently ignored, since generalized balancing is not yet implemented."
.ie n .IP "gsl_eigen_gen($A, $B, $alpha, $beta, $w) \- This function computes the eigenvalues of the real generalized nonsymmetric matrix pair ($A, $B), and stores them as pairs in ($alpha, $beta), where $alpha is complex and $beta is real, both are vectors. The elements of $beta are normalized to be non-negative. If S is desired, it is stored in $A on output. If T is desired, it is stored in $B on output. The ordering of eigenvalues in ($alpha, $beta) follows the ordering of the diagonal blocks in the Schur forms S and T. In rare cases, this function may fail to find all eigenvalues. If this occurs, an error code is returned (1)." 4
.el .IP "gsl_eigen_gen($A, \f(CW$B\fR, \f(CW$alpha\fR, \f(CW$beta\fR, \f(CW$w\fR) \- This function computes the eigenvalues of the real generalized nonsymmetric matrix pair ($A, \f(CW$B\fR), and stores them as pairs in ($alpha, \f(CW$beta\fR), where \f(CW$alpha\fR is complex and \f(CW$beta\fR is real, both are vectors. The elements of \f(CW$beta\fR are normalized to be non-negative. If S is desired, it is stored in \f(CW$A\fR on output. If T is desired, it is stored in \f(CW$B\fR on output. The ordering of eigenvalues in ($alpha, \f(CW$beta\fR) follows the ordering of the diagonal blocks in the Schur forms S and T. In rare cases, this function may fail to find all eigenvalues. If this occurs, an error code is returned (1)." 4
.IX Item "gsl_eigen_gen($A, $B, $alpha, $beta, $w) - This function computes the eigenvalues of the real generalized nonsymmetric matrix pair ($A, $B), and stores them as pairs in ($alpha, $beta), where $alpha is complex and $beta is real, both are vectors. The elements of $beta are normalized to be non-negative. If S is desired, it is stored in $A on output. If T is desired, it is stored in $B on output. The ordering of eigenvalues in ($alpha, $beta) follows the ordering of the diagonal blocks in the Schur forms S and T. In rare cases, this function may fail to find all eigenvalues. If this occurs, an error code is returned (1)."
.ie n .IP "gsl_eigen_gen_QZ($A, $B, $alpha, $beta, $Q, $Z, $w) \- This function is identical to gsl_eigen_gen except it also computes the left and right Schur vectors and stores them into $Q matrix and $Z matrix respectively." 4
.el .IP "gsl_eigen_gen_QZ($A, \f(CW$B\fR, \f(CW$alpha\fR, \f(CW$beta\fR, \f(CW$Q\fR, \f(CW$Z\fR, \f(CW$w\fR) \- This function is identical to gsl_eigen_gen except it also computes the left and right Schur vectors and stores them into \f(CW$Q\fR matrix and \f(CW$Z\fR matrix respectively." 4
.IX Item "gsl_eigen_gen_QZ($A, $B, $alpha, $beta, $Q, $Z, $w) - This function is identical to gsl_eigen_gen except it also computes the left and right Schur vectors and stores them into $Q matrix and $Z matrix respectively."
.IP "gsl_eigen_genv_alloc($n) \- This function allocates a workspace for computing eigenvalues and eigenvectors of n\-by-n real generalized nonsymmetric eigensystems." 4
.IX Item "gsl_eigen_genv_alloc($n) - This function allocates a workspace for computing eigenvalues and eigenvectors of n-by-n real generalized nonsymmetric eigensystems."
.ie n .IP "gsl_eigen_genv_free($w) \- This function frees the memory associated with the workspace $w." 4
.el .IP "gsl_eigen_genv_free($w) \- This function frees the memory associated with the workspace \f(CW$w\fR." 4
.IX Item "gsl_eigen_genv_free($w) - This function frees the memory associated with the workspace $w."
.ie n .IP "gsl_eigen_genv($A, $B, $alpha, $beta, $evec, $w) \- This function computes eigenvalues and right eigenvectors of the n\-by-n real generalized nonsymmetric matrix pair ($A, $B). The eigenvalues are stored in ($alpha, $beta) where $alpha is a complex vector and $beta a real vector and the eigenvectors are stored in $evec complex matrix. It first calls gsl_eigen_gen to compute the eigenvalues, Schur forms, and Schur vectors. Then it finds eigenvectors of the Schur forms and backtransforms them using the Schur vectors. The Schur vectors are destroyed in the process, but can be saved by using gsl_eigen_genv_QZ. The computed eigenvectors are normalized to have unit magnitude. On output, ($A, $B) contains the generalized Schur form (S, T). If gsl_eigen_gen fails, no eigenvectors are computed, and an error code is returned (1)." 4
.el .IP "gsl_eigen_genv($A, \f(CW$B\fR, \f(CW$alpha\fR, \f(CW$beta\fR, \f(CW$evec\fR, \f(CW$w\fR) \- This function computes eigenvalues and right eigenvectors of the n\-by-n real generalized nonsymmetric matrix pair ($A, \f(CW$B\fR). The eigenvalues are stored in ($alpha, \f(CW$beta\fR) where \f(CW$alpha\fR is a complex vector and \f(CW$beta\fR a real vector and the eigenvectors are stored in \f(CW$evec\fR complex matrix. It first calls gsl_eigen_gen to compute the eigenvalues, Schur forms, and Schur vectors. Then it finds eigenvectors of the Schur forms and backtransforms them using the Schur vectors. The Schur vectors are destroyed in the process, but can be saved by using gsl_eigen_genv_QZ. The computed eigenvectors are normalized to have unit magnitude. On output, ($A, \f(CW$B\fR) contains the generalized Schur form (S, T). If gsl_eigen_gen fails, no eigenvectors are computed, and an error code is returned (1)." 4
.IX Item "gsl_eigen_genv($A, $B, $alpha, $beta, $evec, $w) - This function computes eigenvalues and right eigenvectors of the n-by-n real generalized nonsymmetric matrix pair ($A, $B). The eigenvalues are stored in ($alpha, $beta) where $alpha is a complex vector and $beta a real vector and the eigenvectors are stored in $evec complex matrix. It first calls gsl_eigen_gen to compute the eigenvalues, Schur forms, and Schur vectors. Then it finds eigenvectors of the Schur forms and backtransforms them using the Schur vectors. The Schur vectors are destroyed in the process, but can be saved by using gsl_eigen_genv_QZ. The computed eigenvectors are normalized to have unit magnitude. On output, ($A, $B) contains the generalized Schur form (S, T). If gsl_eigen_gen fails, no eigenvectors are computed, and an error code is returned (1)."
.ie n .IP "gsl_eigen_genv_QZ($A, $B, $alpha, $beta, $evec, $Q, $Z, $w) \- This function is identical to gsl_eigen_genv except it also computes the left and right Schur vectors and stores them into $Q and $Z matrices respectively." 4
.el .IP "gsl_eigen_genv_QZ($A, \f(CW$B\fR, \f(CW$alpha\fR, \f(CW$beta\fR, \f(CW$evec\fR, \f(CW$Q\fR, \f(CW$Z\fR, \f(CW$w\fR) \- This function is identical to gsl_eigen_genv except it also computes the left and right Schur vectors and stores them into \f(CW$Q\fR and \f(CW$Z\fR matrices respectively." 4
.IX Item "gsl_eigen_genv_QZ($A, $B, $alpha, $beta, $evec, $Q, $Z, $w) - This function is identical to gsl_eigen_genv except it also computes the left and right Schur vectors and stores them into $Q and $Z matrices respectively."
.ie n .IP "gsl_eigen_symmv_sort($eval, $evec, $sort_type) \- This function simultaneously sorts the eigenvalues stored in the vector $eval and the corresponding real eigenvectors stored in the columns of the matrix $evec according to the value of the parameter $sort_type which is one of the constant included in this module." 4
.el .IP "gsl_eigen_symmv_sort($eval, \f(CW$evec\fR, \f(CW$sort_type\fR) \- This function simultaneously sorts the eigenvalues stored in the vector \f(CW$eval\fR and the corresponding real eigenvectors stored in the columns of the matrix \f(CW$evec\fR according to the value of the parameter \f(CW$sort_type\fR which is one of the constant included in this module." 4
.IX Item "gsl_eigen_symmv_sort($eval, $evec, $sort_type) - This function simultaneously sorts the eigenvalues stored in the vector $eval and the corresponding real eigenvectors stored in the columns of the matrix $evec according to the value of the parameter $sort_type which is one of the constant included in this module."
.ie n .IP "gsl_eigen_hermv_sort($eval, $evec, $sort_type) \- This function simultaneously sorts the eigenvalues stored in the vector $eval and the corresponding real eigenvectors stored in the columns of the matrix $evec according to the value of the parameter $sort_type which is one of the constant included in this module." 4
.el .IP "gsl_eigen_hermv_sort($eval, \f(CW$evec\fR, \f(CW$sort_type\fR) \- This function simultaneously sorts the eigenvalues stored in the vector \f(CW$eval\fR and the corresponding real eigenvectors stored in the columns of the matrix \f(CW$evec\fR according to the value of the parameter \f(CW$sort_type\fR which is one of the constant included in this module." 4
.IX Item "gsl_eigen_hermv_sort($eval, $evec, $sort_type) - This function simultaneously sorts the eigenvalues stored in the vector $eval and the corresponding real eigenvectors stored in the columns of the matrix $evec according to the value of the parameter $sort_type which is one of the constant included in this module."
.ie n .IP "gsl_eigen_nonsymmv_sort($eval, $evec, $sort_type) \- This function simultaneously sorts the eigenvalues stored in the vector $eval and the corresponding complex eigenvectors stored in the columns of the complex matrix $evec into ascending or descending order according to the value of the parameter $sort_type. Only $GSL_EIGEN_SORT_ABS_ASC and $GSL_EIGEN_SORT_ABS_DESC are supported due to the eigenvalues being complex." 4
.el .IP "gsl_eigen_nonsymmv_sort($eval, \f(CW$evec\fR, \f(CW$sort_type\fR) \- This function simultaneously sorts the eigenvalues stored in the vector \f(CW$eval\fR and the corresponding complex eigenvectors stored in the columns of the complex matrix \f(CW$evec\fR into ascending or descending order according to the value of the parameter \f(CW$sort_type\fR. Only \f(CW$GSL_EIGEN_SORT_ABS_ASC\fR and \f(CW$GSL_EIGEN_SORT_ABS_DESC\fR are supported due to the eigenvalues being complex." 4
.IX Item "gsl_eigen_nonsymmv_sort($eval, $evec, $sort_type) - This function simultaneously sorts the eigenvalues stored in the vector $eval and the corresponding complex eigenvectors stored in the columns of the complex matrix $evec into ascending or descending order according to the value of the parameter $sort_type. Only $GSL_EIGEN_SORT_ABS_ASC and $GSL_EIGEN_SORT_ABS_DESC are supported due to the eigenvalues being complex."
.ie n .IP "gsl_eigen_gensymmv_sort($eval, $evec, $sort_type) \- This function simultaneously sorts the eigenvalues stored in the vector $eval and the corresponding real eigenvectors stored in the columns of the matrix $evec according to the value of the parameter $sort_type which is one of the constant included in this module." 4
.el .IP "gsl_eigen_gensymmv_sort($eval, \f(CW$evec\fR, \f(CW$sort_type\fR) \- This function simultaneously sorts the eigenvalues stored in the vector \f(CW$eval\fR and the corresponding real eigenvectors stored in the columns of the matrix \f(CW$evec\fR according to the value of the parameter \f(CW$sort_type\fR which is one of the constant included in this module." 4
.IX Item "gsl_eigen_gensymmv_sort($eval, $evec, $sort_type) - This function simultaneously sorts the eigenvalues stored in the vector $eval and the corresponding real eigenvectors stored in the columns of the matrix $evec according to the value of the parameter $sort_type which is one of the constant included in this module."
.ie n .IP "gsl_eigen_genhermv_sort($eval, $evec, $sort_type) \- This function simultaneously sorts the eigenvalues stored in the vector $eval and the corresponding real eigenvectors stored in the columns of the matrix $evec according to the value of the parameter $sort_type which is one of the constant included in this module." 4
.el .IP "gsl_eigen_genhermv_sort($eval, \f(CW$evec\fR, \f(CW$sort_type\fR) \- This function simultaneously sorts the eigenvalues stored in the vector \f(CW$eval\fR and the corresponding real eigenvectors stored in the columns of the matrix \f(CW$evec\fR according to the value of the parameter \f(CW$sort_type\fR which is one of the constant included in this module." 4
.IX Item "gsl_eigen_genhermv_sort($eval, $evec, $sort_type) - This function simultaneously sorts the eigenvalues stored in the vector $eval and the corresponding real eigenvectors stored in the columns of the matrix $evec according to the value of the parameter $sort_type which is one of the constant included in this module."
.ie n .IP "gsl_eigen_genv_sort($eval, $evec, $sort_type) \- This function simultaneously sorts the eigenvalues stored in the vector $eval and the corresponding complex eigenvectors stored in the columns of the complex matrix $evec into ascending or descending order according to the value of the parameter $sort_type. Only $GSL_EIGEN_SORT_ABS_ASC and $GSL_EIGEN_SORT_ABS_DESC are supported due to the eigenvalues being complex." 4
.el .IP "gsl_eigen_genv_sort($eval, \f(CW$evec\fR, \f(CW$sort_type\fR) \- This function simultaneously sorts the eigenvalues stored in the vector \f(CW$eval\fR and the corresponding complex eigenvectors stored in the columns of the complex matrix \f(CW$evec\fR into ascending or descending order according to the value of the parameter \f(CW$sort_type\fR. Only \f(CW$GSL_EIGEN_SORT_ABS_ASC\fR and \f(CW$GSL_EIGEN_SORT_ABS_DESC\fR are supported due to the eigenvalues being complex." 4
.IX Item "gsl_eigen_genv_sort($eval, $evec, $sort_type) - This function simultaneously sorts the eigenvalues stored in the vector $eval and the corresponding complex eigenvectors stored in the columns of the complex matrix $evec into ascending or descending order according to the value of the parameter $sort_type. Only $GSL_EIGEN_SORT_ABS_ASC and $GSL_EIGEN_SORT_ABS_DESC are supported due to the eigenvalues being complex."
.IP "gsl_schur_gen_eigvals" 4
.IX Item "gsl_schur_gen_eigvals"
.IP "gsl_schur_solve_equation" 4
.IX Item "gsl_schur_solve_equation"
.IP "gsl_schur_solve_equation_z" 4
.IX Item "gsl_schur_solve_equation_z"
.IP "gsl_eigen_jacobi" 4
.IX Item "gsl_eigen_jacobi"
.IP "gsl_eigen_invert_jacobi" 4
.IX Item "gsl_eigen_invert_jacobi"
.PD
.PP
This module also includes these constants :
.ie n .IP "$GSL_EIGEN_SORT_VAL_ASC \- ascending order in numerical value" 4
.el .IP "\f(CW$GSL_EIGEN_SORT_VAL_ASC\fR \- ascending order in numerical value" 4
.IX Item "$GSL_EIGEN_SORT_VAL_ASC - ascending order in numerical value"
.PD 0
.ie n .IP "$GSL_EIGEN_SORT_VAL_DESC \- descending order in numerical value" 4
.el .IP "\f(CW$GSL_EIGEN_SORT_VAL_DESC\fR \- descending order in numerical value" 4
.IX Item "$GSL_EIGEN_SORT_VAL_DESC - descending order in numerical value"
.ie n .IP "$GSL_EIGEN_SORT_ABS_ASC \- ascending order in magnitude" 4
.el .IP "\f(CW$GSL_EIGEN_SORT_ABS_ASC\fR \- ascending order in magnitude" 4
.IX Item "$GSL_EIGEN_SORT_ABS_ASC - ascending order in magnitude"
.ie n .IP "$GSL_EIGEN_SORT_ABS_DESC \- descending order in magnitude" 4
.el .IP "\f(CW$GSL_EIGEN_SORT_ABS_DESC\fR \- descending order in magnitude" 4
.IX Item "$GSL_EIGEN_SORT_ABS_DESC - descending order in magnitude"
.PD
.PP
For more informations on the functions, we refer you to the \s-1GSL\s0 offcial documentation: 
<http://www.gnu.org/software/gsl/manual/html_node/>
.SH "EXAMPLES"
.IX Header "EXAMPLES"
This example shows how to use the gsl_eigen_symmv functions to find the eigenvalues and eigenvectors of a matrix.
.PP
.Vb 10
\& use Math::GSL::Vector qw/:all/;
\& use Math::GSL::Matrix qw/:all/;
\& use Math::GSL::Eigen qw/:all/;
\& my $w = gsl_eigen_symmv_alloc(2);
\& my $m = gsl_matrix_alloc(2,2);
\& gsl_matrix_set($m, 0, 0, 2);
\& gsl_matrix_set($m, 0, 1, 1);
\& gsl_matrix_set($m, 1, 0, 1);
\& gsl_matrix_set($m, 1, 1, 2);
\& my $eval = gsl_vector_alloc(2);
\& my $evec = gsl_matrix_alloc(2,2);
\& gsl_eigen_symmv($m, $eval, $evec, $w);
\& gsl_eigen_gensymmv_sort($eval, $evec, $GSL_EIGEN_SORT_ABS_ASC);
\& print "The first eigenvalue is : " . gsl_vector_get($eval, 0) . "\en";
\& print "The second eigenvalue is : " . gsl_vector_get($eval, 1) . "\en";
\& my $x = gsl_matrix_get($evec, 0, 0);
\& my $y = gsl_matrix_get($evec, 0, 1);
\& print "The first eigenvector is [$x, $y] \en";
\& $x = gsl_matrix_get($evec, 1, 0);
\& $y = gsl_matrix_get($evec, 1, 1);
\& print "The second eigenvector is [$x, $y] \en";
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
Jonathan \*(L"Duke\*(R" Leto <jonathan@leto.net> and Thierry Moisan <thierry.moisan@gmail.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2008\-2011 Jonathan \*(L"Duke\*(R" Leto and Thierry Moisan
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
