.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Math::GSL::FFT 3pm"
.TH Math::GSL::FFT 3pm "2012-08-17" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::GSL::FFT \- Fast Fourier Transforms (FFT)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    use Math::GSL::FFT qw /:all/;
\&    # alternating elements are real/imaginary part, hence 256 element array
\&    my $data = [ (1) x 10, (0) x 236, (1) x 10 ]; 
\&
\&    # use every element of the array
\&    my $stride = 1;  
\&
\&    # But it contains 128 complex numbers
\&    my ($status, $fft) = gsl_fft_complex_radix2_forward ($data, $stride, 128);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module and this documentation is still in a very early state. Danger Will Robinson!
An \s-1OO\s0 interface will evolve soon.
.IP "\(bu" 4
\&\f(CW\*(C`gsl_fft_complex_radix2_forward($data, $stride, $n) \*(C'\fR
.Sp
This function computes the forward FFTs of length \f(CW$n\fR with stride \f(CW$stride\fR, on
the array reference \f(CW$data\fR using an in-place radix\-2 decimation-in-time
algorithm. The length of the transform \f(CW$n\fR is restricted to powers of two. For
the transform version of the function the sign argument can be either forward
(\-1) or backward (+1). The functions return a value of \f(CW$GSL_SUCCESS\fR if no
errors were detected, or \f(CW$GSL_EDOM\fR if the length of the data \f(CW$n\fR is not a power
of two. The complex functions of the \s-1FFT\s0 module are not yet fully implemented.
.IP "\(bu" 4
\&\f(CW\*(C`gsl_fft_complex_radix2_backward \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_fft_complex_radix2_inverse \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_fft_complex_radix2_transform \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_fft_complex_radix2_dif_forward \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_fft_complex_radix2_dif_backward \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_fft_complex_radix2_dif_inverse \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_fft_complex_radix2_dif_transform \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_fft_complex_wavetable_alloc($n)\*(C'\fR
.Sp
This function prepares a trigonometric lookup table for a complex \s-1FFT\s0 of length
\&\f(CW$n\fR. The function returns a pointer to the newly allocated
gsl_fft_complex_wavetable if no errors were detected, and a null pointer in the
case of error. The length \f(CW$n\fR is factorized into a product of subtransforms, and
the factors and their trigonometric coefficients are stored in the wavetable.
The trigonometric coefficients are computed using direct calls to sin and cos,
for accuracy. Recursion relations could be used to compute the lookup table
faster, but if an application performs many FFTs of the same length then this
computation is a one-off overhead which does not affect the final throughput.
The wavetable structure can be used repeatedly for any transform of the same
length. The table is not modified by calls to any of the other \s-1FFT\s0 functions.
The same wavetable can be used for both forward and backward (or inverse)
transforms of a given length.
.IP "\(bu" 4
\&\f(CW\*(C`gsl_fft_complex_wavetable_free($wavetable)\*(C'\fR
.Sp
This function frees the memory associated with the wavetable \f(CW$wavetable\fR. The
wavetable can be freed if no further FFTs of the same length will be needed.
.IP "\(bu" 4
\&\f(CW\*(C`gsl_fft_complex_workspace_alloc($n)\*(C'\fR
.Sp
This function allocates a workspace for a complex transform of length \f(CW$n\fR.
.IP "\(bu" 4
\&\f(CW\*(C`gsl_fft_complex_workspace_free($workspace) \*(C'\fR
.Sp
This function frees the memory associated with the workspace \f(CW$workspace\fR. The
workspace can be freed if no further FFTs of the same length will be needed.
.IP "\(bu" 4
\&\f(CW\*(C`gsl_fft_complex_memcpy \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_fft_complex_forward \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_fft_complex_backward \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_fft_complex_inverse \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_fft_complex_transform \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_fft_halfcomplex_radix2_backward($data, $stride, $n)\*(C'\fR
.Sp
This function computes the backwards in-place radix\-2 \s-1FFT\s0 of length \f(CW$n\fR and
stride \f(CW$stride\fR on the half-complex sequence data stored according the output
scheme used by gsl_fft_real_radix2. The result is a real array stored in
natural order.
.IP "\(bu" 4
\&\f(CW\*(C`gsl_fft_halfcomplex_radix2_inverse($data, $stride, $n)\*(C'\fR
.Sp
This function computes the inverse in-place radix\-2 \s-1FFT\s0 of length \f(CW$n\fR and stride
\&\f(CW$stride\fR on the half-complex sequence data stored according the output scheme
used by gsl_fft_real_radix2. The result is a real array stored in natural
order.
.IP "\(bu" 4
\&\f(CW\*(C`gsl_fft_halfcomplex_radix2_transform\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_fft_halfcomplex_wavetable_alloc($n)\*(C'\fR
.Sp
This function prepares trigonometric lookup tables for an \s-1FFT\s0 of size \f(CW$n\fR real
elements. The functions return a pointer to the newly allocated struct if no
errors were detected, and a null pointer in the case of error. The length \f(CW$n\fR is
factorized into a product of subtransforms, and the factors and their
trigonometric coefficients are stored in the wavetable. The trigonometric
coefficients are computed using direct calls to sin and cos, for accuracy.
Recursion relations could be used to compute the lookup table faster, but if an
application performs many FFTs of the same length then computing the wavetable
is a one-off overhead which does not affect the final throughput.  The
wavetable structure can be used repeatedly for any transform of the same
length. The table is not modified by calls to any of the other \s-1FFT\s0 functions.
The appropriate type of wavetable must be used for forward real or inverse
half-complex transforms.
.IP "\(bu" 4
\&\f(CW\*(C`gsl_fft_halfcomplex_wavetable_free($wavetable)\*(C'\fR
.Sp
This function frees the memory associated with the wavetable \f(CW$wavetable\fR. The
wavetable can be freed if no further FFTs of the same length will be needed.
.IP "\(bu" 4
\&\f(CW\*(C`gsl_fft_halfcomplex_backward \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_fft_halfcomplex_inverse \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_fft_halfcomplex_transform \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_fft_halfcomplex_unpack \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_fft_halfcomplex_radix2_unpack \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_fft_real_radix2_transform($data, $stride, $n) \*(C'\fR
.Sp
This function computes an in-place radix\-2 \s-1FFT\s0 of length \f(CW$n\fR and stride \f(CW$stride\fR
on the real array reference \f(CW$data\fR. The output is a half-complex sequence, which
is stored in-place. The arrangement of the half-complex terms uses the
following scheme: for k < N/2 the real part of the k\-th term is stored in
location k, and the corresponding imaginary part is stored in location N\-k.
Terms with k > N/2 can be reconstructed using the symmetry z_k = z^*_{N\-k}. The
terms for k=0 and k=N/2 are both purely real, and count as a special case.
Their real parts are stored in locations 0 and N/2 respectively, while their
imaginary parts which are zero are not stored. The following table shows the
correspondence between the output data and the equivalent results obtained by
considering the input data as a complex sequence with zero imaginary part,
.Sp
.Vb 10
\&          complex[0].real    =    data[0]
\&          complex[0].imag    =    0
\&          complex[1].real    =    data[1]
\&          complex[1].imag    =    data[N\-1]
\&          ...............         ................
\&          complex[k].real    =    data[k]
\&          complex[k].imag    =    data[N\-k]
\&          ...............         ................
\&          complex[N/2].real  =    data[N/2]
\&          complex[N/2].imag  =    0
\&          ...............         ................
\&          complex[k\*(Aq].real   =    data[k]        k\*(Aq = N \- k
\&          complex[k\*(Aq].imag   =   \-data[N\-k]
\&          ...............         ................
\&          complex[N\-1].real  =    data[1]
\&          complex[N\-1].imag  =   \-data[N\-1]
.Ve
.Sp
Note that the output data can be converted into the full complex sequence using
the function gsl_fft_halfcomplex_unpack.
.IP "\(bu" 4
\&\f(CW\*(C`gsl_fft_real_wavetable_alloc($n)\*(C'\fR
.Sp
This function prepares trigonometric lookup tables for an \s-1FFT\s0 of size \f(CW$n\fR real
elements. The functions return a pointer to the newly allocated struct if no
errors were detected, and a null pointer in the case of error. The length \f(CW$n\fR is
factorized into a product of subtransforms, and the factors and their
trigonometric coefficients are stored in the wavetable. The trigonometric
coefficients are computed using direct calls to sin and cos, for accuracy.
Recursion relations could be used to compute the lookup table faster, but if an
application performs many FFTs of the same length then computing the wavetable
is a one-off overhead which does not affect the final throughput.  The
wavetable structure can be used repeatedly for any transform of the same
length. The table is not modified by calls to any of the other \s-1FFT\s0 functions.
The appropriate type of wavetable must be used for forward real or inverse
half-complex transforms.
.IP "\(bu" 4
\&\f(CW\*(C`gsl_fft_real_wavetable_free($wavetable)\*(C'\fR
.Sp
This function frees the memory associated with the wavetable \f(CW$wavetable\fR. The
wavetable can be freed if no further FFTs of the same length will be needed.
.IP "\(bu" 4
\&\f(CW\*(C`gsl_fft_real_workspace_alloc($n)\*(C'\fR
.Sp
This function allocates a workspace for a real transform of length \f(CW$n\fR. The same
workspace can be used for both forward real and inverse halfcomplex transforms.
.IP "\(bu" 4
\&\f(CW\*(C`gsl_fft_real_workspace_free($workspace)\*(C'\fR
.Sp
This function frees the memory associated with the workspace \f(CW$workspace\fR. The
workspace can be freed if no further FFTs of the same length will be needed.
.IP "\(bu" 4
\&\f(CW\*(C`gsl_fft_real_transform \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_fft_real_unpack \*(C'\fR
.PP
This module also includes the following constants :
.IP "\(bu" 4
\&\f(CW$gsl_fft_forward\fR
.IP "\(bu" 4
\&\f(CW$gsl_fft_backward\fR
.PP
For more informations on the functions, we refer you to the \s-1GSL\s0 offcial
documentation: <http://www.gnu.org/software/gsl/manual/html_node/>
.SH "AUTHORS"
.IX Header "AUTHORS"
Jonathan \*(L"Duke\*(R" Leto <jonathan@leto.net> and Thierry Moisan <thierry.moisan@gmail.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2008\-2011 Jonathan \*(L"Duke\*(R" Leto and Thierry Moisan
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
