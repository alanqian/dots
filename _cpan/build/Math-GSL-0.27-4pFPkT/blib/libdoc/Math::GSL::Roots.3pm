.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Math::GSL::Roots 3pm"
.TH Math::GSL::Roots 3pm "2012-08-17" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::GSL::Roots \- Find roots of arbitrary 1\-D functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Math::GSL::Roots qw/:all/;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.IP "\(bu" 4
\&\f(CW\*(C`gsl_root_fsolver_alloc($T)\*(C'\fR \-
.Sp
This function returns a pointer to a newly allocated instance of a solver of
type \f(CW$T\fR. \f(CW$T\fR must be one of the constant included with this module. If there is
insufficient memory to create the solver then the function returns a null
pointer and the error handler is invoked with an error code of \f(CW$GSL_ENOMEM\fR.
.IP "\(bu" 4
\&\f(CW\*(C`gsl_root_fsolver_free($s)\*(C'\fR \-
.Sp
Don't call this function explicitly. It will be called automatically in \s-1DESTROY\s0 for fsolver.
.IP "\(bu" 4
\&\f(CW\*(C`gsl_root_fsolver_set($s, $f, $x_lower, $x_upper)\*(C'\fR \-
.Sp
This function initializes, or reinitializes, an existing solver \f(CW$s\fR to use the
function \f(CW$f\fR and the initial search interval [$x_lower, \f(CW$x_upper\fR]. \f(CW$f\fR has to be
of this form :
.Sp
.Vb 2
\&    sub { my $x=shift; function_with_$x }
\&For example:
\&
\&    sub { my $x=shift; ($x\-3.2)**3 }
.Ve
.Sp
is a valid value for \f(CW$f\fR.  Don't apply this function twice to the same fsolver.
It will cause a memory leak. Instead of this you should create new fsolver.
.IP "\(bu" 4
\&\f(CW\*(C`gsl_root_fsolver_iterate($s)\*(C'\fR \-
.Sp
This function performs a single iteration of the solver \f(CW$s\fR. If the iteration
encounters an unexpected problem then an error code will be returned (the
Math::GSL::Errno has to be included),
.Sp
\&\f(CW$GSL_EBADFUNC\fR \- The iteration encountered a singular point where the function
or its derivative evaluated to Inf or NaN.
.Sp
\&\f(CW$GSL_EZERODIV\fR \- The derivative of the function vanished at the iteration point,
preventing the algorithm from continuing without a division by zero.
.IP "\(bu" 4
\&\f(CW\*(C`gsl_root_fsolver_name($s)\*(C'\fR \-
.Sp
This function returns the name of the solver use within the \f(CW$s\fR solver.
.IP "\(bu" 4
\&\f(CW\*(C`gsl_root_fsolver_root($s)\*(C'\fR \-
.Sp
This function returns the current estimate of the root for the solver \f(CW$s\fR.
.IP "\(bu" 4
\&\f(CW\*(C`gsl_root_fsolver_x_lower($s)\*(C'\fR \-
.Sp
This function returns the current lower value of the bracketing interval for the solver \f(CW$s\fR.
.IP "\(bu" 4
\&\f(CW\*(C`gsl_root_fsolver_x_upper($s)\*(C'\fR \-
.Sp
This function returns the current lower value of the bracketing interval for the solver \f(CW$s\fR.
.IP "\(bu" 4
\&\f(CW\*(C`gsl_root_fdfsolver_alloc($T)\*(C'\fR \-
.Sp
This function returns a pointer to a newly allocated instance of a
derivative-based solver of type \f(CW$T\fR. If there is insufficient memory to create
the solver then the function returns a null pointer and the error handler is
invoked with an error code of \f(CW$GSL_ENOMEM\fR.
.IP "\(bu" 4
\&\f(CW\*(C`gsl_root_fdfsolver_set($s, $fdf, $root)\*(C'\fR \-
.Sp
This function initializes, or reinitializes, an existing solver \f(CW$s\fR to use the
function and derivative \f(CW$fdf\fR and the initial guess \f(CW$root\fR. \f(CW$f\fR has to be of this
form :
.Sp
.Vb 1
\&    sub { my $x=shift; function_with_$x }
.Ve
.Sp
For example:
.Sp
.Vb 1
\&    sub { my $x=shift; ($x\-3.2)**3 }
.Ve
.Sp
is a valid value for \f(CW$fdf\fR.
.IP "\(bu" 4
\&\f(CW\*(C`gsl_root_fdfsolver_iterate($s)\*(C'\fR \-
.Sp
This function performs a single iteration of the solver \f(CW$s\fR. If the iteration
encounters an unexpected problem then an error code will be returned (the
Math::GSL::Errno has to be included),
.Sp
\&\f(CW$GSL_EBADFUNC\fR \- The iteration encountered a singular point where the function or its derivative evaluated to Inf or NaN.
\&\f(CW$GSL_EZERODIV\fR \- The derivative of the function vanished at the iteration point, preventing the algorithm from continuing without a division by zero.
.IP "\(bu" 4
\&\f(CW\*(C`gsl_root_fdfsolver_free($s)\*(C'\fR \-
.Sp
This function frees all the memory associated with the solver \f(CW$s\fR.
.IP "\(bu" 4
\&\f(CW\*(C`gsl_root_fdfsolver_name($s)\*(C'\fR \-
.Sp
This function returns the name of the solver use within the \f(CW$s\fR solver.
.IP "\(bu" 4
\&\f(CW\*(C`gsl_root_fdfsolver_root($s)\*(C'\fR \-
.Sp
This function returns the current estimate of the root for the solver \f(CW$s\fR.
.IP "\(bu" 4
\&\f(CW\*(C`gsl_root_test_interval($x_lower, $x_upper, $epsabs, $epsrel)\*(C'\fR \-
.Sp
This function tests for the convergence of the interval [$x_lower, \f(CW$x_upper\fR]
with absolute error epsabs and relative error \f(CW$epsrel\fR. The test returns
\&\f(CW$GSL_SUCCESS\fR if the following condition is achieved,
.Sp
.Vb 1
\&    |a \- b| < epsabs + epsrel min(|a|,|b|)
\&
\& when the interval x = [a,b] does not include the origin. If the interval
\& includes the origin then \emin(|a|,|b|) is replaced by zero (which is the
\& minimum value of |x| over the interval). This ensures that the relative error
\& is accurately estimated for roots close to the origin.  This condition on the
\& interval also implies that any estimate of the root r in the interval
\& satisfies the same condition with respect to the true root r^*,
\&
\&    |r \- r^*| < epsabs + epsrel r^*
\&
\&  assuming that the true root r^* is contained within the interval.
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`gsl_root_test_residual($f, $epsabs)\*(C'\fR \-
.Sp
This function tests the residual value \f(CW$f\fR against the absolute error bound
\&\f(CW$epsabs\fR. The test returns \f(CW$GSL_SUCCESS\fR if the following condition is achieved,
.Sp
.Vb 1
\&    |$f| < $epsabs
.Ve
.Sp
and returns \f(CW$GSL_CONTINUE\fR otherwise. This criterion is suitable for situations
where the precise location of the root, x, is unimportant provided a value can
be found where the residual, |f(x)|, is small enough.
.IP "\(bu" 4
\&\f(CW\*(C`gsl_root_test_delta($x1, $x0, $epsabs, $epsrel)\*(C'\fR \-
.Sp
This function tests for the convergence of the sequence ..., \f(CW$x0\fR, \f(CW$x1\fR with
absolute error \f(CW$epsabs\fR and relative error \f(CW$epsrel\fR. The test returns
\&\f(CW$GSL_SUCCESS\fR if the following condition is achieved,
.Sp
.Vb 1
\&    |x_1 \- x_0| < epsabs + epsrel |x_1|
.Ve
.Sp
and returns \f(CW$GSL_CONTINUE\fR otherwise.
.PP
This module also includes the following constants :
.IP "\(bu" 4
\&\f(CW$gsl_root_fsolver_bisection\fR \-
.Sp
The bisection algorithm is the simplest method of bracketing the roots of a
function. It is the slowest algorithm provided by the library, with linear
convergence. On each iteration, the interval is bisected and the value of the
function at the midpoint is calculated. The sign of this value is used to
determine which half of the interval does not contain a root. That half is
discarded to give a new, smaller interval containing the root. This procedure
can be continued indefinitely until the interval is sufficiently small. At any
time the current estimate of the root is taken as the midpoint of the interval.
.IP "\(bu" 4
\&\f(CW$gsl_root_fsolver_brent\fR \-
.Sp
The Brent-Dekker method (referred to here as Brent's method) combines an
interpolation strategy with the bisection algorithm. This produces a fast
algorithm which is still robust. On each iteration Brent's method approximates
the function using an interpolating curve. On the first iteration this is a
linear interpolation of the two endpoints. For subsequent iterations the
algorithm uses an inverse quadratic fit to the last three points, for higher
accuracy. The intercept of the interpolating curve with the x\-axis is taken as
a guess for the root. If it lies within the bounds of the current interval then
the interpolating point is accepted, and used to generate a smaller interval.
If the interpolating point is not accepted then the algorithm falls back to an
ordinary bisection step. The best estimate of the root is taken from the most
recent interpolation or bisection.
.IP "\(bu" 4
\&\f(CW$gsl_root_fsolver_falsepos\fR \-
.Sp
The false position algorithm is a method of finding roots based on linear
interpolation. Its convergence is linear, but it is usually faster than
bisection. On each iteration a line is drawn between the endpoints (a,f(a)) and
(b,f(b)) and the point where this line crosses the x\-axis taken as a
\&\*(L"midpoint\*(R". The value of the function at this point is calculated and its sign
is used to determine which side of the interval does not contain a root. That
side is discarded to give a new, smaller interval containing the root. This
procedure can be continued indefinitely until the interval is sufficiently
small. The best estimate of the root is taken from the linear interpolation of
the interval on the current iteration.
.IP "\(bu" 4
\&\f(CW$gsl_root_fdfsolver_newton\fR \-
.Sp
Newton's Method is the standard root-polishing algorithm. The algorithm begins
with an initial guess for the location of the root. On each iteration, a line
tangent to the function f is drawn at that position. The point where this line
crosses the x\-axis becomes the new guess. The iteration is defined by the
following sequence, x_{i+1} = x_i \- f(x_i)/f'(x_i) Newton's method converges
quadratically for single roots, and linearly for multiple roots.
.IP "\(bu" 4
\&\f(CW$gsl_root_fdfsolver_secant\fR \-
.Sp
The secant method is a simplified version of Newton's method which does not
require the computation of the derivative on every step.  On its first
iteration the algorithm begins with Newton's method, using the derivative to
compute a first step,
.Sp
.Vb 1
\&    x_1 = x_0 \- f(x_0)/f\*(Aq(x_0)
.Ve
.Sp
Subsequent iterations avoid the evaluation of the derivative by replacing it
with a numerical estimate, the slope of the line through the previous two
points,
.Sp
.Vb 1
\&    x_{i+1} = x_i f(x_i) / f\*(Aq_{est}
.Ve
.Sp
where
.Sp
.Vb 1
\&    f\*(Aq_{est} = (f(x_i) \- f(x_{i\-1})/(x_i \- x_{i\-1})
.Ve
.Sp
When the derivative does not change significantly in the vicinity of the root
the secant method gives a useful saving. Asymptotically the secant method is
faster than Newton's method whenever the cost of evaluating the derivative is
more than 0.44 times the cost of evaluating the function itself. As with all
methods of computing a numerical derivative the estimate can suffer from
cancellation errors if the separation of the points becomes too small.
.Sp
On single roots, the method has a convergence of order (1 + \esqrt 5)/2
(approximately 1.62). It converges linearly for multiple roots.
.IP "\(bu" 4
\&\f(CW$gsl_root_fdfsolver_steffenson\fR \-
.Sp
The Steffenson Method provides the fastest convergence of all the routines. It
combines the basic Newton algorithm with an Aitken a\*^XXdelta\-squareda\*^XX
acceleration. If the Newton iterates are x_i then the acceleration procedure
generates a new sequence R_i:
.Sp
.Vb 1
\&    R_i = x_i \- (x_{i+1} \- x_i)^2 / (x_{i+2} \- 2 x_{i+1} + x_{i})
.Ve
.Sp
which converges faster than the original sequence under reasonable conditions.
The new sequence requires three terms before it can produce its first value so
the method returns accelerated values on the second and subsequent iterations.
On the first iteration it returns the ordinary Newton estimate. The Newton
iterate is also returned if the denominator of the acceleration term ever
becomes zero.
.Sp
As with all acceleration procedures this method can become unstable if the
function is not well-behaved.
.PP
For more information about these functions, we refer you to the official \s-1GSL\s0
documentation: <http://www.gnu.org/software/gsl/manual/html_node/>
.SH "AUTHORS"
.IX Header "AUTHORS"
Jonathan \*(L"Duke\*(R" Leto <jonathan@leto.net> and Thierry Moisan <thierry.moisan@gmail.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2008\-2011 Jonathan \*(L"Duke\*(R" Leto and Thierry Moisan
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
