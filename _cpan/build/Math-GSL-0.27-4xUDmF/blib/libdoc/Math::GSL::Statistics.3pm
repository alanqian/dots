.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Math::GSL::Statistics 3pm"
.TH Math::GSL::Statistics 3pm "2012-08-21" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::GSL::Statistics \- Statistical functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Math::GSL::Statistics qw /:all/;
\&        
\&    my $data     = [17.2, 18.1, 16.5, 18.3, 12.6];
\&    my $mean     = gsl_stats_mean($data, 1, 5);
\&    my $variance = gsl_stats_variance($data, 1, 5);
\&    my $largest  = gsl_stats_max($data, 1, 5);
\&    my $smallest = gsl_stats_min($data, 1, 5);
\&    print qq{
\&    Dataset : @$data
\&    Sample mean           $mean 
\&    Estimated variance    $variance
\&    Largest value         $largest
\&    Smallest value        $smallest
\&    };
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Here is a list of all the functions in this module :
.IP "\(bu" 2
\&\f(CW\*(C`gsl_stats_mean($data, $stride, $n)\*(C'\fR \- This function returns the arithmetic mean of the array reference \f(CW$data\fR, a dataset of length \f(CW$n\fR with stride \f(CW$stride\fR. The arithmetic mean, or sample mean, is denoted by \eHat\emu and defined as, \eHat\emu = (1/N) \esum x_i where x_i are the elements of the dataset \f(CW$data\fR. For samples drawn from a gaussian distribution the variance of \eHat\emu is \esigma^2 / N.
.IP "\(bu" 2
\&\f(CW\*(C`gsl_stats_variance($data, $stride, $n)\*(C'\fR \- This function returns the estimated, or sample, variance of data, an array reference of length \f(CW$n\fR with stride \f(CW$stride\fR. The estimated variance is denoted by \eHat\esigma^2 and is defined by, \eHat\esigma^2 = (1/(N\-1)) \esum (x_i \- \eHat\emu)^2 where x_i are the elements of the dataset data. Note that the normalization factor of 1/(N\-1) results from the derivation of \eHat\esigma^2 as an unbiased estimator of the population variance \esigma^2. For samples drawn from a gaussian distribution the variance of \eHat\esigma^2 itself is 2 \esigma^4 / N. This function computes the mean via a call to gsl_stats_mean. If you have already computed the mean then you can pass it directly to gsl_stats_variance_m.
.IP "\(bu" 2
\&\f(CW\*(C`gsl_stats_sd($data, $stride, $n)\*(C'\fR
.IP "\(bu" 2
\&\f(CW\*(C`gsl_stats_sd_m($data, $stride, $n, $mean)\*(C'\fR
.Sp
The standard deviation is defined as the square root of the variance. These functions return the square root of the corresponding variance functions above.
.IP "\(bu" 2
\&\f(CW\*(C`gsl_stats_variance_with_fixed_mean($data, $stride, $n, $mean)\*(C'\fR \- This function calculates the standard deviation of the array reference \f(CW$data\fR for a fixed population mean \f(CW$mean\fR. The result is the square root of the corresponding variance function.
.IP "\(bu" 2
\&\f(CW\*(C`gsl_stats_sd_with_fixed_mean($data, $stride, $n, $mean)\*(C'\fR \- This function computes an unbiased estimate of the variance of data when the population mean \f(CW$mean\fR of the underlying distribution is known a priori. In this case the estimator for the variance uses the factor 1/N and the sample mean \eHat\emu is replaced by the known population mean \emu, \eHat\esigma^2 = (1/N) \esum (x_i \- \emu)^2
.IP "\(bu" 2
\&\f(CW\*(C`gsl_stats_tss($data, $stride, $n)\*(C'\fR
.IP "\(bu" 2
\&\f(CW\*(C`gsl_stats_tss_m($data, $stride, $n, $mean)\*(C'\fR
.Sp
These functions return the total sum of squares (\s-1TSS\s0) of data about the mean. For gsl_stats_tss_m the user-supplied value of mean is used, and for gsl_stats_tss it is computed using gsl_stats_mean. \s-1TSS\s0 =  \esum (x_i \- mean)^2
.IP "\(bu" 2
\&\f(CW\*(C`gsl_stats_absdev($data, $stride, $n)\*(C'\fR \- This function computes the absolute deviation from the mean of data, a dataset of length \f(CW$n\fR with stride \f(CW$stride\fR. The absolute deviation from the mean is defined as, absdev  = (1/N) \esum |x_i \- \eHat\emu| where x_i are the elements of the array reference \f(CW$data\fR. The absolute deviation from the mean provides a more robust measure of the width of a distribution than the variance. This function computes the mean of data via a call to gsl_stats_mean.
.IP "\(bu" 2
\&\f(CW\*(C`gsl_stats_skew($data, $stride, $n)\*(C'\fR \- This function computes the skewness of \f(CW$data\fR, a dataset in the form of an array reference of length \f(CW$n\fR with stride \f(CW$stride\fR. The skewness is defined as, skew = (1/N) \esum ((x_i \- \eHat\emu)/\eHat\esigma)^3 where x_i are the elements of the dataset \f(CW$data\fR. The skewness measures the asymmetry of the tails of a distribution. The function computes the mean and estimated standard deviation of data via calls to gsl_stats_mean and gsl_stats_sd.
.IP "\(bu" 2
\&\f(CW\*(C`gsl_stats_skew_m_sd($data, $stride, $n, $mean, $sd)\*(C'\fR \- This function computes the skewness of the array reference \f(CW$data\fR using the given values of the mean \f(CW$mean\fR and standard deviation \f(CW$sd\fR, skew = (1/N) \esum ((x_i \- mean)/sd)^3. These functions are useful if you have already computed the mean and standard deviation of \f(CW$data\fR and want to avoid recomputing them.
.IP "\(bu" 2
\&\f(CW\*(C`gsl_stats_kurtosis($data, $stride, $n)\*(C'\fR \- This function computes the kurtosis of data, an array reference of length \f(CW$n\fR with stride \f(CW$stride\fR. The kurtosis is defined as, kurtosis = ((1/N) \esum ((x_i \- \eHat\emu)/\eHat\esigma)^4)  \- 3. The kurtosis measures how sharply peaked a distribution is, relative to its width. The kurtosis is normalized to zero for a gaussian distribution.
.IP "\(bu" 2
\&\f(CW\*(C`gsl_stats_kurtosis_m_sd($data, $stride, $n, $mean, $sd)\*(C'\fR \- This function computes the kurtosis of the array reference \f(CW$data\fR using the given values of the mean \f(CW$mean\fR and standard deviation \f(CW$sd\fR, kurtosis = ((1/N) \esum ((x_i \- mean)/sd)^4) \- 3. This function is useful if you have already computed the mean and standard deviation of data and want to avoid recomputing them.
.IP "\(bu" 2
\&\f(CW\*(C`gsl_stats_lag1_autocorrelation($data, $stride, $n)\*(C'\fR \- This function computes the lag\-1 autocorrelation of the array reference data.
 a_1 = {\esum_{i = 1}^{n} (x_{i} \- \eHat\emu) (x_{i\-1} \- \eHat\emu)
  \eover
 \esum_{i = 1}^{n} (x_{i} \- \eHat\emu) (x_{i} \- \eHat\emu)}
.IP "\(bu" 2
\&\f(CW\*(C`gsl_stats_lag1_autocorrelation_m($data, $stride, $n, $mean)\*(C'\fR \- This function computes the lag\-1 autocorrelation of the array reference \f(CW$data\fR using the given value of the mean \f(CW$mean\fR.
.IP "\(bu" 2
\&\f(CW\*(C`gsl_stats_covariance($data1, $stride1, $data2, $stride2, $n)\*(C'\fR \- This function computes the covariance of the array reference \f(CW$data1\fR and \f(CW$data2\fR which must both be of the same length \f(CW$n\fR. covar = (1/(n \- 1)) \esum_{i = 1}^{n} (x_i \- \eHat x) (y_i \- \eHat y)
.IP "\(bu" 2
\&\f(CW\*(C`gsl_stats_covariance_m($data1, $stride1, $data2, $stride2, $n, $mean1, $mean2)\*(C'\fR \- This function computes the covariance of the array reference \f(CW$data1\fR and \f(CW$data2\fR using the given values of the means, \f(CW$mean1\fR and \f(CW$mean2\fR. This is useful if you have already computed the means of \f(CW$data1\fR and \f(CW$data2\fR and want to avoid recomputing them.
.IP "\(bu" 2
\&\f(CW\*(C`gsl_stats_correlation($data1, $stride1, $data2, $stride2, $n)\*(C'\fR \- This function efficiently computes the Pearson correlation coefficient between the array reference \f(CW$data1\fR and \f(CW$data2\fR which must both be of the same length \f(CW$n\fR.
 r = cov(x, y) / (\eHat\esigma_x \eHat\esigma_y)
   = {1/(n\-1) \esum (x_i \- \eHat x) (y_i \- \eHat y)
      \eover
      \esqrt{1/(n\-1) \esum (x_i \- \eHat x)^2} \esqrt{1/(n\-1) \esum (y_i \- \eHat y)^2}
     }
.IP "\(bu" 2
\&\f(CW\*(C`gsl_stats_variance_m($data, $stride, $n, $mean)\*(C'\fR \- This function returns the sample variance of \f(CW$data\fR, an array reference, relative to the given value of \f(CW$mean\fR. The function is computed with \eHat\emu replaced by the value of mean that you supply, \eHat\esigma^2 = (1/(N\-1)) \esum (x_i \- mean)^2
.IP "\(bu" 2
\&\f(CW\*(C`gsl_stats_absdev_m($data, $stride, $n, $mean)\*(C'\fR \- This function computes the absolute deviation of the dataset \f(CW$data\fR, an array refrence, relative to the given value of \f(CW$mean\fR, absdev  = (1/N) \esum |x_i \- mean|. This function is useful if you have already computed the mean of data (and want to avoid recomputing it), or wish to calculate the absolute deviation relative to another value (such as zero, or the median).
.IP "\(bu" 2
\&\f(CW\*(C`gsl_stats_wmean($w, $wstride, $data, $stride, $n)\*(C'\fR \- This function returns the weighted mean of the dataset \f(CW$data\fR array reference with stride \f(CW$stride\fR and length \f(CW$n\fR, using the set of weights \f(CW$w\fR, which is an array reference, with stride \f(CW$wstride\fR and length \f(CW$n\fR. The weighted mean is defined as, \eHat\emu = (\esum w_i x_i) / (\esum w_i)
.IP "\(bu" 2
\&\f(CW\*(C`gsl_stats_wvariance($w, $wstride, $data, $stride, $n)\*(C'\fR \- This function returns the estimated variance of the dataset \f(CW$data\fR, which is the dataset, with stride \f(CW$stride\fR and length \f(CW$n\fR, using the set of weights \f(CW$w\fR (as an array reference) with stride \f(CW$wstride\fR and length \f(CW$n\fR. The estimated variance of a weighted dataset is defined as,  \eHat\esigma^2 = ((\esum w_i)/((\esum w_i)^2 \- \esum (w_i^2))) \esum w_i (x_i \- \eHat\emu)^2. Note that this expression reduces to an unweighted variance with the familiar 1/(N\-1) factor when there are N equal non-zero weights.
.IP "\(bu" 2
\&\f(CW\*(C`gsl_stats_wvariance_m($w, $wstride, $data, $stride, $n, $wmean, $wsd)\*(C'\fR \- This function returns the estimated variance of the weighted dataset \f(CW$data\fR (which is an array reference) using the given weighted mean \f(CW$wmean\fR.
.IP "\(bu" 2
\&\f(CW\*(C`gsl_stats_wsd($w, $wstride, $data, $stride, $n)\*(C'\fR \- The standard deviation is defined as the square root of the variance. This function returns the square root of the corresponding variance function gsl_stats_wvariance above.
.IP "\(bu" 2
\&\f(CW\*(C`gsl_stats_wsd_m($w, $wstride, $data, $stride, $n, $wmean)\*(C'\fR \- This function returns the square root of the corresponding variance function gsl_stats_wvariance_m above.
.IP "\(bu" 2
\&\f(CW\*(C`gsl_stats_wvariance_with_fixed_mean($w, $wstride, $data, $stride, $n, $mean)\*(C'\fR \- This function computes an unbiased estimate of the variance of weighted dataset \f(CW$data\fR (which is an array reference) when the population mean \f(CW$mean\fR of the underlying distribution is known a priori. In this case the estimator for the variance replaces the sample mean \eHat\emu by the known population mean \emu, \eHat\esigma^2 = (\esum w_i (x_i \- \emu)^2) / (\esum w_i)
.IP "\(bu" 2
\&\f(CW\*(C`gsl_stats_wsd_with_fixed_mean($w, $wstride, $data, $stride, $n, $mean)\*(C'\fR \- The standard deviation is defined as the square root of the variance. This function returns the square root of the corresponding variance function above.
.IP "\(bu" 2
\&\f(CW\*(C`gsl_stats_wtss($w, $wstride, $data, $stride, $n)\*(C'\fR
.IP "\(bu" 2
\&\f(CW\*(C`gsl_stats_wtss_m($w, $wstride, $data, $stride, $n, $wmean)\*(C'\fR \- These functions return the weighted total sum of squares (\s-1TSS\s0) of data about the weighted mean. For gsl_stats_wtss_m the user-supplied value of \f(CW$wmean\fR is used, and for gsl_stats_wtss it is computed using gsl_stats_wmean. \s-1TSS\s0 =  \esum w_i (x_i \- wmean)^2
.IP "\(bu" 2
\&\f(CW\*(C`gsl_stats_wabsdev($w, $wstride, $data, $stride, $n)\*(C'\fR \- This function computes the weighted absolute deviation from the weighted mean of \f(CW$data\fR, which is an array reference. The absolute deviation from the mean is defined as, absdev = (\esum w_i |x_i \- \eHat\emu|) / (\esum w_i)
.IP "\(bu" 2
\&\f(CW\*(C`gsl_stats_wabsdev_m($w, $wstride, $data, $stride, $n, $wmean)\*(C'\fR \- This function computes the absolute deviation of the weighted dataset \f(CW$data\fR (an array reference) about the given weighted mean \f(CW$wmean\fR.
.IP "\(bu" 2
\&\f(CW\*(C`gsl_stats_wskew($w, $wstride, $data, $stride, $n)\*(C'\fR \- This function computes the weighted skewness of the dataset \f(CW$data\fR, an array reference. skew = (\esum w_i ((x_i \- xbar)/\esigma)^3) / (\esum w_i)
.IP "\(bu" 2
\&\f(CW\*(C`gsl_stats_wskew_m_sd($w, $wstride, $data, $stride, $n, $wmean, $wsd)\*(C'\fR \- This function computes the weighted skewness of the dataset \f(CW$data\fR using the given values of the weighted mean and weighted standard deviation, \f(CW$wmean\fR and \f(CW$wsd\fR.
.IP "\(bu" 2
\&\f(CW\*(C`gsl_stats_wkurtosis($w, $wstride, $data, $stride, $n)\*(C'\fR \- This function computes the weighted kurtosis of the dataset \f(CW$data\fR, an array reference. kurtosis = ((\esum w_i ((x_i \- xbar)/sigma)^4) / (\esum w_i)) \- 3
.IP "\(bu" 2
\&\f(CW\*(C`gsl_stats_wkurtosis_m_sd($w, $wstride, $data, $stride, $n, $wmean, $wsd)\*(C'\fR \- This function computes the weighted kurtosis of the dataset \f(CW$data\fR, an array reference, using the given values of the weighted mean and weighted standard deviation, \f(CW$wmean\fR and \f(CW$wsd\fR.
.IP "\(bu" 2
\&\f(CW\*(C`gsl_stats_pvariance($data, $stride, $n, $data2, $stride2, $n2)\*(C'\fR
.IP "\(bu" 2
\&\f(CW\*(C`gsl_stats_ttest($data1, $stride1, $n1, $data2, $stride2, $n2)\*(C'\fR
.IP "\(bu" 2
\&\f(CW\*(C`gsl_stats_max($data, $stride, $n)\*(C'\fR \- This function returns the maximum value in the \f(CW$data\fR array reference, a dataset of length \f(CW$n\fR with stride \f(CW$stride\fR. The maximum value is defined as the value of the element x_i which satisfies x_i >= x_j for all j. If you want instead to find the element with the largest absolute magnitude you will need to apply fabs or abs to your data before calling this function.
.IP "\(bu" 2
\&\f(CW\*(C`gsl_stats_min($data, $stride, $n)\*(C'\fR \- This function returns the minimum value in \f(CW$data\fR (which is an array reference) a dataset of length \f(CW$n\fR with stride \f(CW$stride\fR. The minimum value is defined as the value of the element x_i which satisfies x_i <= x_j for all j. If you want instead to find the element with the smallest absolute magnitude you will need to apply fabs or abs to your data before calling this function.
.IP "\(bu" 2
\&\f(CW\*(C`gsl_stats_minmax($data, $stride, $n)\*(C'\fR \- This function finds both the minimum and maximum values in \f(CW$data\fR, which is an array reference, in a single pass and returns them in this order.
.IP "\(bu" 2
\&\f(CW\*(C`gsl_stats_max_index($data, $stride, $n)\*(C'\fR \- This function returns the index of the maximum value in \f(CW$data\fR array reference, a dataset of length \f(CW$n\fR with stride \f(CW$stride\fR. The maximum value is defined as the value of the element x_i which satisfies x_i >= x_j for all j. When there are several equal maximum elements then the first one is chosen.
.IP "\(bu" 2
\&\f(CW\*(C`gsl_stats_min_index($data, $stride, $n)\*(C'\fR \- This function returns the index of the minimum value in \f(CW$data\fR array reference, a dataset of length \f(CW$n\fR with stride \f(CW$stride\fR. The minimum value is defined as the value of the element x_i which satisfies x_i <= x_j for all j. When there are several equal minimum elements then the first one is chosen.
.IP "\(bu" 2
\&\f(CW\*(C`gsl_stats_minmax_index($data, $stride, $n)\*(C'\fR \- This function returns the indexes of the minimum and maximum values in \f(CW$data\fR, an array reference in a single pass. The value are returned in this order.
.IP "\(bu" 2
\&\f(CW\*(C`gsl_stats_median_from_sorted_data($sorted_data, $stride, $n)\*(C'\fR \- This function returns the median value of \f(CW$sorted_data\fR (which is an array reference), a dataset of length \f(CW$n\fR with stride \f(CW$stride\fR. The elements of the array must be in ascending numerical order. There are no checks to see whether the data are sorted, so the function gsl_sort should always be used first. This function can be found in the Math::GSL::Sort module.  When the dataset has an odd number of elements the median is the value of element (n\-1)/2. When the dataset has an even number of elements the median is the mean of the two nearest middle values, elements (n\-1)/2 and n/2. Since the algorithm for computing the median involves interpolation this function always returns a floating-point number, even for integer data types.
.IP "\(bu" 2
\&\f(CW\*(C`gsl_stats_quantile_from_sorted_data($sorted_data, $stride, $n, $f)\*(C'\fR \- This function returns a quantile value of \f(CW$sorted_data\fR, a double-precision array reference of length \f(CW$n\fR with stride \f(CW$stride\fR. The elements of the array must be in ascending numerical order. The quantile is determined by the f, a fraction between 0 and 1. For example, to compute the value of the 75th percentile f should have the value 0.75. There are no checks to see whether the data are sorted, so the function gsl_sort should always be used first. This function can be found in the Math::GSL::Sort module. The quantile is found by interpolation, using the formula quantile = (1 \- \edelta) x_i + \edelta x_{i+1} where i is floor((n \- 1)f) and \edelta is (n\-1)f \- i. Thus the minimum value of the array (data[0*stride]) is given by f equal to zero, the maximum value (data[(n\-1)*stride]) is given by f equal to one and the median value is given by f equal to 0.5. Since the algorithm for computing quantiles involves interpolation this function always returns a floating-point number, even for integer data types.
.PP
The following function are simply variants for int and char of the last functions:
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_int_mean \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_int_variance \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_int_sd \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_int_variance_with_fixed_mean \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_int_sd_with_fixed_mean \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_int_tss \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_int_tss_m \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_int_absdev \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_int_skew \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_int_kurtosis \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_int_lag1_autocorrelation \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_int_covariance \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_int_correlation \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_int_variance_m \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_int_sd_m \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_int_absdev_m \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_int_skew_m_sd \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_int_kurtosis_m_sd \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_int_lag1_autocorrelation_m \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_int_covariance_m \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_int_pvariance \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_int_ttest \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_int_max \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_int_min \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_int_minmax \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_int_max_index \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_int_min_index \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_int_minmax_index \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_int_median_from_sorted_data \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_int_quantile_from_sorted_data \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_char_mean \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_char_variance \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_char_sd \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_char_variance_with_fixed_mean \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_char_sd_with_fixed_mean \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_char_tss \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_char_tss_m \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_char_absdev \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_char_skew \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_char_kurtosis \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_char_lag1_autocorrelation \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_char_covariance \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_char_correlation \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_char_variance_m \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_char_sd_m \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_char_absdev_m \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_char_skew_m_sd \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_char_kurtosis_m_sd \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_char_lag1_autocorrelation_m \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_char_covariance_m \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_char_pvariance \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_char_ttest \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_char_max \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_char_min \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_char_minmax \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_char_max_index \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_char_min_index \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_char_minmax_index \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_char_median_from_sorted_data \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_stats_char_quantile_from_sorted_data \*(C'\fR
.PP
You have to add the functions you want to use inside the qw /put_funtion_here /. 
You can also write use Math::GSL::Statistics qw/:all/; to use all avaible functions of the module. 
Other tags are also avaible, here is a complete list of all tags for this module :
.IP "all" 4
.IX Item "all"
.PD 0
.IP "int" 4
.IX Item "int"
.IP "char" 4
.IX Item "char"
.PD
.PP
For more informations on the functions, we refer you to the \s-1GSL\s0 offcial
documentation: <http://www.gnu.org/software/gsl/manual/html_node/>
.SH "AUTHORS"
.IX Header "AUTHORS"
Jonathan \*(L"Duke\*(R" Leto <jonathan@leto.net> and Thierry Moisan <thierry.moisan@gmail.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2008\-2011 Jonathan \*(L"Duke\*(R" Leto and Thierry Moisan
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
