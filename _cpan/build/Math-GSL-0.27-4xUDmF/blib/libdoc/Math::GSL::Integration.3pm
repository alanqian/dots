.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Math::GSL::Integration 3pm"
.TH Math::GSL::Integration 3pm "2012-08-21" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::GSL::Integration \- Routines for performing numerical integration (quadrature) of a function in one dimension
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Math::GSL::Integration qw /:all/;
\&
\&    my $function = sub { $_[0]**2 } ;
\&    my ($lower, $upper ) = (0,1);
\&    my ($relerr,$abserr) = (0,1e\-7);
\&
\&    my ($status, $result, $abserr, $num_evals) = gsl_integration_qng ( $function,
\&                                                    $lower, $upper, $relerr, $abserr
\&                                                 );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module allows you to numerically integrate a Perl subroutine. Depending
on the properties of your function (singularities, smoothness) and the type
of integration range (finite, infinite, semi-infinite), you will need to 
choose a quadrature routine that fits your needs.
.IP "\(bu" 4
\&\f(CW\*(C`gsl_integration_workspace_alloc($n)\*(C'\fR
.Sp
This function allocates a workspace sufficient to hold \f(CW$n\fR double precision
intervals, their integration results and error estimates.
.IP "\(bu" 4
\&\f(CW\*(C`gsl_integration_workspace_free($w)\*(C'\fR
.Sp
.Vb 1
\& This function frees the memory associated with the workspace $w.
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`gsl_integration_qaws_table_alloc($alpha, $beta, $mu, $nu)\*(C'\fR
.Sp
.Vb 5
\& This function allocates space for a gsl_integration_qaws_table struct
\& describing a singular weight function W(x) with the parameters ($alpha, $beta,
\& $mu, $nu), W(x) = (x\-a)^alpha (b\-x)^beta log^mu (x\-a) log^nu (b\-x) where
\& $alpha > \-1, $beta > \-1, and $mu = 0, 1, $nu = 0, 1. The weight function can
\& take four different forms depending on the values of $mu and $nu,
\&
\&              W(x) = (x\-a)^alpha (b\-x)^beta                   (mu = 0, nu = 0)
\&              W(x) = (x\-a)^alpha (b\-x)^beta log(x\-a)          (mu = 1, nu = 0)
\&              W(x) = (x\-a)^alpha (b\-x)^beta log(b\-x)          (mu = 0, nu = 1)
\&              W(x) = (x\-a)^alpha (b\-x)^beta log(x\-a) log(b\-x) (mu = 1, nu = 1)
.Ve
.Sp
The singular points (a,b) do not have to be specified until the integral is
computed, where they are the endpoints of the integration range.  The function
returns a pointer to the newly allocated table gsl_integration_qaws_table if no
errors were detected, and 0 in the case of error.
.IP "\(bu" 4
\&\f(CW\*(C`gsl_integration_qaws_table_set($t, $alpha, $beta, $mu, $nu)\*(C'\fR
.Sp
.Vb 2
\& This function modifies the parameters ($alpha, $beta, $mu, $nu) of an existing
\& gsl_integration_qaws_table struct $t.
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`gsl_integration_qaws_table_free($t)\*(C'\fR
.Sp
.Vb 2
\& This function frees all the memory associated with the
\& gsl_integration_qaws_table struct $t.
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`gsl_integration_qawo_table_alloc($omega, $L, $sine, $n)\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_integration_qawo_table_set($t, $omega, $L, $sine, $n)\*(C'\fR
.Sp
.Vb 2
\& This function changes the parameters omega, L and sine of the existing
\& workspace $t.
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`gsl_integration_qawo_table_set_length($t, $L)\*(C'\fR
.Sp
.Vb 2
\& This function allows the length parameter $L of the workspace $t to be
\& changed.
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`gsl_integration_qawo_table_free($t)\*(C'\fR
.Sp
.Vb 1
\& This function frees all the memory associated with the workspace $t.
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`gsl_integration_qk15($function,$a,$b,$resabs,$resasc) \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_integration_qk21($function,$a,$b,$resabs,$resasc) \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_integration_qk31($function,$a,$b,$resabs,$resasc) \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_integration_qk41($function,$a,$b,$resabs,$resasc) \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_integration_qk51($function,$a,$b,$resabs,$resasc) \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_integration_qk61($function,$a,$b,$resabs,$resasc) \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_integration_qcheb($function, $a, $b, $cheb12, $cheb24) \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_integration_qk \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_integration_qng($function,$a,$b,$epsabs,$epsrel,$num_evals) \*(C'\fR
.Sp
This routine \s-1QNG\s0 (Quadrature Non-Adaptive Gaussian) is inexpensive is the sense
that it will evaluate the function much fewer times than the adaptive routines.
Because of this it does not need any workspaces, so it is also more memory
efficient. It should be perfectly fine for well-behaved functions (smooth and
nonsingular), but will not be able to get the required accuracy or may not
converge for more complicated functions.
.IP "\(bu" 4
\&\f(CW\*(C`gsl_integration_qag($function,$a,$b,$epsabs,$epsrel,$limit,$key,$workspace) \*(C'\fR
.Sp
This routine \s-1QAG\s0 (Quadrature Adaptive Gaussian) ...
.IP "\(bu" 4
\&\f(CW\*(C`gsl_integration_qagi($function,$epsabs,$epsrel,$limit,$workspace) \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_integration_qagiu($function,$a,$epsabs,$epsrel,$limit,$workspace) \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_integration_qagil($function,$b,$epsabs,$epsrel,$limit,$workspace) \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_integration_qags($func,$a,$b,$epsabs,$epsrel,$limit,$workspace)\*(C'\fR
.Sp
.Vb 5
\&    ($status, $result, $abserr) = gsl_integration_qags (
\&                            sub { 1/$_[0]} , 
\&                            1, 10, 0, 1e\-7, 1000,
\&                            $workspace,
\&                        );
\&
\& This function applies the Gauss\-Kronrod 21\-point integration rule
\& adaptively until an estimate of the integral of $func over ($a,$b) is
\& achieved within the desired absolute and relative error limits,
\& $epsabs and $epsrel.
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`gsl_integration_qagp($function, $pts, $npts, $epsbs, $epsrel, $limit, $workspace) \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_integration_qawc($function, $a, $b, $c, $epsabs, $epsrel, $limit, $workspace) \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_integration_qaws($function, $a, $b, $qaws_table, $epsabs, $epsrel, $limit, $workspace) \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_integration_qawo($function, $a, $epsabs, $epsrel, $limit, $workspace, $qawo_table) \*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`gsl_integration_qawf($function, $a, $epsabs, $limit, $workspace, $cycle_workspace, $qawo_table) \*(C'\fR
.PP
This module also includes the following constants :
.IP "\(bu" 4
\&\f(CW$GSL_INTEG_COSINE\fR
.IP "\(bu" 4
\&\f(CW$GSL_INTEG_SINE\fR
.IP "\(bu" 4
\&\f(CW$GSL_INTEG_GAUSS15\fR
.IP "\(bu" 4
\&\f(CW$GSL_INTEG_GAUSS21\fR
.IP "\(bu" 4
\&\f(CW$GSL_INTEG_GAUSS31\fR
.IP "\(bu" 4
\&\f(CW$GSL_INTEG_GAUSS41\fR
.IP "\(bu" 4
\&\f(CW$GSL_INTEG_GAUSS51\fR
.IP "\(bu" 4
\&\f(CW$GSL_INTEG_GAUSS61\fR
.PP
The following error constants are part of the Math::GSL::Errno module and can
be returned by the gsl_integration_* functions :
.IP "\(bu" 4
\&\f(CW$GSL_EMAXITER\fR
.Sp
Maximum number of subdivisions was exceeded.
.IP "\(bu" 4
\&\f(CW$GSL_EROUND\fR
.Sp
Cannot reach tolerance because of roundoff error, or roundoff error was detected in the extrapolation table.
.IP "\(bu" 4
\&\s-1GSL_ESING\s0
.Sp
A non-integrable singularity or other bad integrand behavior was found in the integration interval.
.IP "\(bu" 4
\&\s-1GSL_EDIVERGE\s0
.Sp
The integral is divergent, or too slowly convergent to be integrated numerically.
.SH "MORE INFO"
.IX Header "MORE INFO"
For more informations on the functions, we refer you to the \s-1GSL\s0 offcial
documentation: <http://www.gnu.org/software/gsl/manual/html_node/>
.SH "AUTHORS"
.IX Header "AUTHORS"
Jonathan \*(L"Duke\*(R" Leto <jonathan@leto.net> and Thierry Moisan <thierry.moisan@gmail.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2008\-2011 Jonathan \*(L"Duke\*(R" Leto and Thierry Moisan
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
