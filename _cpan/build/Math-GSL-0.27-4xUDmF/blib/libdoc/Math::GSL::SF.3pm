.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Math::GSL::SF 3pm"
.TH Math::GSL::SF 3pm "2012-08-21" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::GSL::SF \- Special Functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Math::GSL::SF qw/:all/;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module contains a data structure named gsl_sf_result. To create a new one use
.PP
.Vb 1
\&    $r = Math::GSL::SF::gsl_sf_result_struct\->new;
.Ve
.PP
You can then access the elements of the structure in this way :
.PP
.Vb 1
\&    my $val   = $r\->{val};
\&
\&    my $error = $r\->{err};
.Ve
.PP
Here is a list of all included functions:
.ie n .IP """gsl_sf_airy_Ai_e($x, $mode)""" 4
.el .IP "\f(CWgsl_sf_airy_Ai_e($x, $mode)\fR" 4
.IX Item "gsl_sf_airy_Ai_e($x, $mode)"
.PD 0
.ie n .IP """gsl_sf_airy_Ai($x, $mode, $result)""" 4
.el .IP "\f(CWgsl_sf_airy_Ai($x, $mode, $result)\fR" 4
.IX Item "gsl_sf_airy_Ai($x, $mode, $result)"
.PD
.Vb 1
\& These routines compute the Airy function Ai($x) with an accuracy specified by $mode. $mode should be $GSL_PREC_DOUBLE, $GSL_PREC_SINGLE or $GSL_PREC_APPROX. $result is a gsl_sf_result structure.
.Ve
.ie n .IP """gsl_sf_airy_Bi_e($x, $mode, $result)""" 4
.el .IP "\f(CWgsl_sf_airy_Bi_e($x, $mode, $result)\fR" 4
.IX Item "gsl_sf_airy_Bi_e($x, $mode, $result)"
.PD 0
.ie n .IP """gsl_sf_airy_Bi($x, $mode)""" 4
.el .IP "\f(CWgsl_sf_airy_Bi($x, $mode)\fR" 4
.IX Item "gsl_sf_airy_Bi($x, $mode)"
.PD
.Vb 1
\& These routines compute the Airy function Bi($x) with an accuracy specified by $mode. $mode should be $GSL_PREC_DOUBLE, $GSL_PREC_SINGLE or $GSL_PREC_APPROX. $result is a gsl_sf_result structure.
.Ve
.ie n .IP """gsl_sf_airy_Ai_scaled_e($x, $mode, $result)""" 4
.el .IP "\f(CWgsl_sf_airy_Ai_scaled_e($x, $mode, $result)\fR" 4
.IX Item "gsl_sf_airy_Ai_scaled_e($x, $mode, $result)"
.PD 0
.ie n .IP """gsl_sf_airy_Ai_scaled($x, $mode)""" 4
.el .IP "\f(CWgsl_sf_airy_Ai_scaled($x, $mode)\fR" 4
.IX Item "gsl_sf_airy_Ai_scaled($x, $mode)"
.PD
.Vb 1
\& These routines compute a scaled version of the Airy function S_A($x) Ai($x). For $x>0 the scaling factor S_A($x) is \eexp(+(2/3) $x**(3/2)), and is 1 for $x<0. $result is a gsl_sf_result structure.
.Ve
.ie n .IP """gsl_sf_airy_Bi_scaled_e($x, $mode, $result)""" 4
.el .IP "\f(CWgsl_sf_airy_Bi_scaled_e($x, $mode, $result)\fR" 4
.IX Item "gsl_sf_airy_Bi_scaled_e($x, $mode, $result)"
.PD 0
.ie n .IP """gsl_sf_airy_Bi_scaled($x, $mode)""" 4
.el .IP "\f(CWgsl_sf_airy_Bi_scaled($x, $mode)\fR" 4
.IX Item "gsl_sf_airy_Bi_scaled($x, $mode)"
.PD
.Vb 1
\& These routines compute a scaled version of the Airy function S_B($x) Bi($x). For $x>0 the scaling factor S_B($x) is exp(\-(2/3) $x**(3/2)), and is 1 for $x<0. $result is a gsl_sf_result structure.
.Ve
.ie n .IP """gsl_sf_airy_Ai_deriv_e($x, $mode, $result)""" 4
.el .IP "\f(CWgsl_sf_airy_Ai_deriv_e($x, $mode, $result)\fR" 4
.IX Item "gsl_sf_airy_Ai_deriv_e($x, $mode, $result)"
.PD 0
.ie n .IP """gsl_sf_airy_Ai_deriv($x, $mode)""" 4
.el .IP "\f(CWgsl_sf_airy_Ai_deriv($x, $mode)\fR" 4
.IX Item "gsl_sf_airy_Ai_deriv($x, $mode)"
.PD
.Vb 1
\& These routines compute the Airy function derivative Ai\*(Aq($x) with an accuracy specified by $mode. $result is a gsl_sf_result structure.
.Ve
.ie n .IP """gsl_sf_airy_Bi_deriv_e($x, $mode, $result)""" 4
.el .IP "\f(CWgsl_sf_airy_Bi_deriv_e($x, $mode, $result)\fR" 4
.IX Item "gsl_sf_airy_Bi_deriv_e($x, $mode, $result)"
.PD 0
.ie n .IP """gsl_sf_airy_Bi_deriv($x, $mode)""" 4
.el .IP "\f(CWgsl_sf_airy_Bi_deriv($x, $mode)\fR" 4
.IX Item "gsl_sf_airy_Bi_deriv($x, $mode)"
.PD
These routines compute the Airy function derivative Bi'($x) with an accuracy specified by \f(CW$mode\fR. \f(CW$result\fR is a gsl_sf_result structure.
.ie n .IP """gsl_sf_airy_Ai_deriv_scaled_e($x, $mode, $result)""" 4
.el .IP "\f(CWgsl_sf_airy_Ai_deriv_scaled_e($x, $mode, $result)\fR" 4
.IX Item "gsl_sf_airy_Ai_deriv_scaled_e($x, $mode, $result)"
.PD 0
.ie n .IP """gsl_sf_airy_Ai_deriv_scaled($x, $mode)""" 4
.el .IP "\f(CWgsl_sf_airy_Ai_deriv_scaled($x, $mode)\fR" 4
.IX Item "gsl_sf_airy_Ai_deriv_scaled($x, $mode)"
.PD
These routines compute the scaled Airy function derivative S_A(x) Ai'(x). For x>0 the scaling factor S_A(x) is \eexp(+(2/3) x^(3/2)), and is 1 for x<0. \f(CW$result\fR is a gsl_sf_result structure.
.ie n .IP """gsl_sf_airy_Bi_deriv_scaled_e($x, $mode, $result)""" 4
.el .IP "\f(CWgsl_sf_airy_Bi_deriv_scaled_e($x, $mode, $result)\fR" 4
.IX Item "gsl_sf_airy_Bi_deriv_scaled_e($x, $mode, $result)"
.PD 0
.ie n .IP """gsl_sf_airy_Bi_deriv_scaled($x, $mode)""" 4
.el .IP "\f(CWgsl_sf_airy_Bi_deriv_scaled($x, $mode)\fR" 4
.IX Item "gsl_sf_airy_Bi_deriv_scaled($x, $mode)"
.PD
These routines compute the scaled Airy function derivative S_B(x) Bi'(x). For x>0 the scaling factor S_B(x) is exp(\-(2/3) x^(3/2)), and is 1 for x<0. \f(CW$result\fR is a gsl_sf_result structure.
.ie n .IP """gsl_sf_airy_zero_Ai_e($s, $result)""" 4
.el .IP "\f(CWgsl_sf_airy_zero_Ai_e($s, $result)\fR" 4
.IX Item "gsl_sf_airy_zero_Ai_e($s, $result)"
.PD 0
.ie n .IP """gsl_sf_airy_zero_Ai($s)""" 4
.el .IP "\f(CWgsl_sf_airy_zero_Ai($s)\fR" 4
.IX Item "gsl_sf_airy_zero_Ai($s)"
.PD
These routines compute the location of the s\-th zero of the Airy function Ai($x). \f(CW$result\fR is a gsl_sf_result structure.
.ie n .IP """gsl_sf_airy_zero_Bi_e($s, $result)""" 4
.el .IP "\f(CWgsl_sf_airy_zero_Bi_e($s, $result)\fR" 4
.IX Item "gsl_sf_airy_zero_Bi_e($s, $result)"
.PD 0
.ie n .IP """gsl_sf_airy_zero_Bi($s)""" 4
.el .IP "\f(CWgsl_sf_airy_zero_Bi($s)\fR" 4
.IX Item "gsl_sf_airy_zero_Bi($s)"
.PD
These routines compute the location of the s\-th zero of the Airy function Bi($x). \f(CW$result\fR is a gsl_sf_result structure.
.ie n .IP """gsl_sf_airy_zero_Ai_deriv_e($s, $result)""" 4
.el .IP "\f(CWgsl_sf_airy_zero_Ai_deriv_e($s, $result)\fR" 4
.IX Item "gsl_sf_airy_zero_Ai_deriv_e($s, $result)"
.PD 0
.ie n .IP """gsl_sf_airy_zero_Ai_deriv($s)""" 4
.el .IP "\f(CWgsl_sf_airy_zero_Ai_deriv($s)\fR" 4
.IX Item "gsl_sf_airy_zero_Ai_deriv($s)"
.PD
These routines compute the location of the s\-th zero of the Airy function derivative Ai'(x). \f(CW$result\fR is a gsl_sf_result structure.
.ie n .IP """gsl_sf_airy_zero_Bi_deriv_e($s, $result)""" 4
.el .IP "\f(CWgsl_sf_airy_zero_Bi_deriv_e($s, $result)\fR" 4
.IX Item "gsl_sf_airy_zero_Bi_deriv_e($s, $result)"
.PD 0
.ie n .IP """gsl_sf_airy_zero_Bi_deriv($s)""" 4
.el .IP "\f(CWgsl_sf_airy_zero_Bi_deriv($s)\fR" 4
.IX Item "gsl_sf_airy_zero_Bi_deriv($s)"
.PD
.Vb 1
\& These routines compute the location of the s\-th zero of the Airy function derivative Bi\*(Aq(x). $result is a gsl_sf_result structure.
.Ve
.ie n .IP """gsl_sf_bessel_J0_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_bessel_J0_e($x, $result)\fR" 4
.IX Item "gsl_sf_bessel_J0_e($x, $result)"
.PD 0
.ie n .IP """gsl_sf_bessel_J0($x)""" 4
.el .IP "\f(CWgsl_sf_bessel_J0($x)\fR" 4
.IX Item "gsl_sf_bessel_J0($x)"
.PD
These routines compute the regular cylindrical Bessel function of zeroth order, J_0($x). \f(CW$result\fR is a gsl_sf_result structure.
.ie n .IP """gsl_sf_bessel_J1_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_bessel_J1_e($x, $result)\fR" 4
.IX Item "gsl_sf_bessel_J1_e($x, $result)"
.PD 0
.ie n .IP """gsl_sf_bessel_J1($x)""" 4
.el .IP "\f(CWgsl_sf_bessel_J1($x)\fR" 4
.IX Item "gsl_sf_bessel_J1($x)"
.PD
.Vb 1
\& These routines compute the regular cylindrical Bessel function of first order, J_1($x). $result is a gsl_sf_result structure.
.Ve
.ie n .IP """gsl_sf_bessel_Jn_e($n, $x, $result)""" 4
.el .IP "\f(CWgsl_sf_bessel_Jn_e($n, $x, $result)\fR" 4
.IX Item "gsl_sf_bessel_Jn_e($n, $x, $result)"
.PD 0
.ie n .IP """gsl_sf_bessel_Jn($n, $x)""" 4
.el .IP "\f(CWgsl_sf_bessel_Jn($n, $x)\fR" 4
.IX Item "gsl_sf_bessel_Jn($n, $x)"
.PD
These routines compute the regular cylindrical Bessel function of order n, J_n($x).
.ie n .IP """gsl_sf_bessel_Jn_array($nmin, $nmax, $x, $result_array)""" 4
.el .IP "\f(CWgsl_sf_bessel_Jn_array($nmin, $nmax, $x, $result_array)\fR" 4
.IX Item "gsl_sf_bessel_Jn_array($nmin, $nmax, $x, $result_array)"
This routine computes the values of the regular cylindrical Bessel functions
J_n($x) for n from \f(CW$nmin\fR to \f(CW$nmax\fR inclusive, storing the results in the array
\&\f(CW$result_array\fR. The values are computed using recurrence relations for
efficiency, and therefore may differ slightly from the exact values.
.ie n .IP """gsl_sf_bessel_Y0_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_bessel_Y0_e($x, $result)\fR" 4
.IX Item "gsl_sf_bessel_Y0_e($x, $result)"
.PD 0
.ie n .IP """gsl_sf_bessel_Y0($x)""" 4
.el .IP "\f(CWgsl_sf_bessel_Y0($x)\fR" 4
.IX Item "gsl_sf_bessel_Y0($x)"
.PD
.Vb 1
\& These routines compute the irregular spherical Bessel function of zeroth order, y_0(x) = \-\ecos(x)/x.
.Ve
.ie n .IP """gsl_sf_bessel_Y1_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_bessel_Y1_e($x, $result)\fR" 4
.IX Item "gsl_sf_bessel_Y1_e($x, $result)"
.PD 0
.ie n .IP """gsl_sf_bessel_Y1($x)""" 4
.el .IP "\f(CWgsl_sf_bessel_Y1($x)\fR" 4
.IX Item "gsl_sf_bessel_Y1($x)"
.PD
These routines compute the irregular spherical Bessel function of first order, y_1(x) = \-(\ecos(x)/x + \esin(x))/x.
.ie n .IP """gsl_sf_bessel_Yn_e""($n, $x, $result)" 4
.el .IP "\f(CWgsl_sf_bessel_Yn_e\fR($n, \f(CW$x\fR, \f(CW$result\fR)" 4
.IX Item "gsl_sf_bessel_Yn_e($n, $x, $result)"
.PD 0
.ie n .IP """gsl_sf_bessel_Yn($n, $x)""" 4
.el .IP "\f(CWgsl_sf_bessel_Yn($n, $x)\fR" 4
.IX Item "gsl_sf_bessel_Yn($n, $x)"
.PD
These routines compute the irregular cylindrical Bessel function of order \f(CW$n\fR, Y_n(x), for x>0.
.ie n .IP """gsl_sf_bessel_Yn_array""" 4
.el .IP "\f(CWgsl_sf_bessel_Yn_array\fR" 4
.IX Item "gsl_sf_bessel_Yn_array"
.PD 0
.ie n .IP """gsl_sf_bessel_I0_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_bessel_I0_e($x, $result)\fR" 4
.IX Item "gsl_sf_bessel_I0_e($x, $result)"
.ie n .IP """gsl_sf_bessel_I0($x)""" 4
.el .IP "\f(CWgsl_sf_bessel_I0($x)\fR" 4
.IX Item "gsl_sf_bessel_I0($x)"
.PD
These routines compute the regular modified cylindrical Bessel function of zeroth order, I_0(x).
.ie n .IP """gsl_sf_bessel_I1_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_bessel_I1_e($x, $result)\fR" 4
.IX Item "gsl_sf_bessel_I1_e($x, $result)"
.PD 0
.ie n .IP """gsl_sf_bessel_I1($x)""" 4
.el .IP "\f(CWgsl_sf_bessel_I1($x)\fR" 4
.IX Item "gsl_sf_bessel_I1($x)"
.PD
These routines compute the regular modified cylindrical Bessel function of first order, I_1(x).
.ie n .IP """gsl_sf_bessel_In_e($n, $x, $result)""" 4
.el .IP "\f(CWgsl_sf_bessel_In_e($n, $x, $result)\fR" 4
.IX Item "gsl_sf_bessel_In_e($n, $x, $result)"
.PD 0
.ie n .IP """gsl_sf_bessel_In($n, $x)""" 4
.el .IP "\f(CWgsl_sf_bessel_In($n, $x)\fR" 4
.IX Item "gsl_sf_bessel_In($n, $x)"
.PD
These routines compute the regular modified cylindrical Bessel function of order \f(CW$n\fR, I_n(x).
.ie n .IP """gsl_sf_bessel_In_array""" 4
.el .IP "\f(CWgsl_sf_bessel_In_array\fR" 4
.IX Item "gsl_sf_bessel_In_array"
.PD 0
.ie n .IP """gsl_sf_bessel_I0_scaled_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_bessel_I0_scaled_e($x, $result)\fR" 4
.IX Item "gsl_sf_bessel_I0_scaled_e($x, $result)"
.ie n .IP """gsl_sf_bessel_I0_scaled($x)""" 4
.el .IP "\f(CWgsl_sf_bessel_I0_scaled($x)\fR" 4
.IX Item "gsl_sf_bessel_I0_scaled($x)"
.PD
These routines compute the scaled regular modified cylindrical Bessel function of zeroth order \eexp(\-|x|) I_0(x).
.ie n .IP """gsl_sf_bessel_I1_scaled_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_bessel_I1_scaled_e($x, $result)\fR" 4
.IX Item "gsl_sf_bessel_I1_scaled_e($x, $result)"
.PD 0
.ie n .IP """gsl_sf_bessel_I1_scaled($x)""" 4
.el .IP "\f(CWgsl_sf_bessel_I1_scaled($x)\fR" 4
.IX Item "gsl_sf_bessel_I1_scaled($x)"
.PD
These routines compute the scaled regular modified cylindrical Bessel function of first order \eexp(\-|x|) I_1(x).
.ie n .IP """gsl_sf_bessel_In_scaled_e($n, $x, $result)""" 4
.el .IP "\f(CWgsl_sf_bessel_In_scaled_e($n, $x, $result)\fR" 4
.IX Item "gsl_sf_bessel_In_scaled_e($n, $x, $result)"
.PD 0
.ie n .IP """gsl_sf_bessel_In_scaled($n, $x)""" 4
.el .IP "\f(CWgsl_sf_bessel_In_scaled($n, $x)\fR" 4
.IX Item "gsl_sf_bessel_In_scaled($n, $x)"
.PD
These routines compute the scaled regular modified cylindrical Bessel function of order \f(CW$n\fR, \eexp(\-|x|) I_n(x)
.ie n .IP """gsl_sf_bessel_In_scaled_array""" 4
.el .IP "\f(CWgsl_sf_bessel_In_scaled_array\fR" 4
.IX Item "gsl_sf_bessel_In_scaled_array"
.PD 0
.ie n .IP """gsl_sf_bessel_K0_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_bessel_K0_e($x, $result)\fR" 4
.IX Item "gsl_sf_bessel_K0_e($x, $result)"
.ie n .IP """gsl_sf_bessel_K0($x)""" 4
.el .IP "\f(CWgsl_sf_bessel_K0($x)\fR" 4
.IX Item "gsl_sf_bessel_K0($x)"
.PD
These routines compute the irregular modified cylindrical Bessel function of zeroth order, K_0(x), for x > 0.
.ie n .IP """gsl_sf_bessel_K1_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_bessel_K1_e($x, $result)\fR" 4
.IX Item "gsl_sf_bessel_K1_e($x, $result)"
.PD 0
.ie n .IP """gsl_sf_bessel_K1($x)""" 4
.el .IP "\f(CWgsl_sf_bessel_K1($x)\fR" 4
.IX Item "gsl_sf_bessel_K1($x)"
.PD
These routines compute the irregular modified cylindrical Bessel function of first order, K_1(x), for x > 0.
.ie n .IP """gsl_sf_bessel_Kn_e($n, $x, $result)""" 4
.el .IP "\f(CWgsl_sf_bessel_Kn_e($n, $x, $result)\fR" 4
.IX Item "gsl_sf_bessel_Kn_e($n, $x, $result)"
.PD 0
.ie n .IP """gsl_sf_bessel_Kn($n, $x)""" 4
.el .IP "\f(CWgsl_sf_bessel_Kn($n, $x)\fR" 4
.IX Item "gsl_sf_bessel_Kn($n, $x)"
.PD
These routines compute the irregular modified cylindrical Bessel function of order \f(CW$n\fR, K_n(x), for x > 0.
.ie n .IP """gsl_sf_bessel_Kn_array""" 4
.el .IP "\f(CWgsl_sf_bessel_Kn_array\fR" 4
.IX Item "gsl_sf_bessel_Kn_array"
.PD 0
.ie n .IP """gsl_sf_bessel_K0_scaled_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_bessel_K0_scaled_e($x, $result)\fR" 4
.IX Item "gsl_sf_bessel_K0_scaled_e($x, $result)"
.ie n .IP """gsl_sf_bessel_K0_scaled($x)""" 4
.el .IP "\f(CWgsl_sf_bessel_K0_scaled($x)\fR" 4
.IX Item "gsl_sf_bessel_K0_scaled($x)"
.PD
These routines compute the scaled irregular modified cylindrical Bessel function of zeroth order \eexp(x) K_0(x) for x>0.
.ie n .IP """gsl_sf_bessel_K1_scaled_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_bessel_K1_scaled_e($x, $result)\fR" 4
.IX Item "gsl_sf_bessel_K1_scaled_e($x, $result)"
.PD 0
.ie n .IP """gsl_sf_bessel_K1_scaled($x)""" 4
.el .IP "\f(CWgsl_sf_bessel_K1_scaled($x)\fR" 4
.IX Item "gsl_sf_bessel_K1_scaled($x)"
.ie n .IP """gsl_sf_bessel_Kn_scaled_e($n, $x, $result)""" 4
.el .IP "\f(CWgsl_sf_bessel_Kn_scaled_e($n, $x, $result)\fR" 4
.IX Item "gsl_sf_bessel_Kn_scaled_e($n, $x, $result)"
.ie n .IP """gsl_sf_bessel_Kn_scaled($n, $x)""" 4
.el .IP "\f(CWgsl_sf_bessel_Kn_scaled($n, $x)\fR" 4
.IX Item "gsl_sf_bessel_Kn_scaled($n, $x)"
.ie n .IP """gsl_sf_bessel_Kn_scaled_array """ 4
.el .IP "\f(CWgsl_sf_bessel_Kn_scaled_array \fR" 4
.IX Item "gsl_sf_bessel_Kn_scaled_array "
.ie n .IP """gsl_sf_bessel_j0_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_bessel_j0_e($x, $result)\fR" 4
.IX Item "gsl_sf_bessel_j0_e($x, $result)"
.ie n .IP """gsl_sf_bessel_j0($x)""" 4
.el .IP "\f(CWgsl_sf_bessel_j0($x)\fR" 4
.IX Item "gsl_sf_bessel_j0($x)"
.ie n .IP """gsl_sf_bessel_j1_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_bessel_j1_e($x, $result)\fR" 4
.IX Item "gsl_sf_bessel_j1_e($x, $result)"
.ie n .IP """gsl_sf_bessel_j1($x)""" 4
.el .IP "\f(CWgsl_sf_bessel_j1($x)\fR" 4
.IX Item "gsl_sf_bessel_j1($x)"
.ie n .IP """gsl_sf_bessel_j2_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_bessel_j2_e($x, $result)\fR" 4
.IX Item "gsl_sf_bessel_j2_e($x, $result)"
.ie n .IP """gsl_sf_bessel_j2($x)""" 4
.el .IP "\f(CWgsl_sf_bessel_j2($x)\fR" 4
.IX Item "gsl_sf_bessel_j2($x)"
.ie n .IP """gsl_sf_bessel_jl_e($l, $x, $result)""" 4
.el .IP "\f(CWgsl_sf_bessel_jl_e($l, $x, $result)\fR" 4
.IX Item "gsl_sf_bessel_jl_e($l, $x, $result)"
.ie n .IP """gsl_sf_bessel_jl($l, $x)""" 4
.el .IP "\f(CWgsl_sf_bessel_jl($l, $x)\fR" 4
.IX Item "gsl_sf_bessel_jl($l, $x)"
.ie n .IP """gsl_sf_bessel_jl_array""" 4
.el .IP "\f(CWgsl_sf_bessel_jl_array\fR" 4
.IX Item "gsl_sf_bessel_jl_array"
.ie n .IP """gsl_sf_bessel_jl_steed_array""" 4
.el .IP "\f(CWgsl_sf_bessel_jl_steed_array\fR" 4
.IX Item "gsl_sf_bessel_jl_steed_array"
.ie n .IP """gsl_sf_bessel_y0_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_bessel_y0_e($x, $result)\fR" 4
.IX Item "gsl_sf_bessel_y0_e($x, $result)"
.ie n .IP """gsl_sf_bessel_y0($x)""" 4
.el .IP "\f(CWgsl_sf_bessel_y0($x)\fR" 4
.IX Item "gsl_sf_bessel_y0($x)"
.ie n .IP """gsl_sf_bessel_y1_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_bessel_y1_e($x, $result)\fR" 4
.IX Item "gsl_sf_bessel_y1_e($x, $result)"
.ie n .IP """gsl_sf_bessel_y1($x)""" 4
.el .IP "\f(CWgsl_sf_bessel_y1($x)\fR" 4
.IX Item "gsl_sf_bessel_y1($x)"
.ie n .IP """gsl_sf_bessel_y2_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_bessel_y2_e($x, $result)\fR" 4
.IX Item "gsl_sf_bessel_y2_e($x, $result)"
.ie n .IP """gsl_sf_bessel_y2($x)""" 4
.el .IP "\f(CWgsl_sf_bessel_y2($x)\fR" 4
.IX Item "gsl_sf_bessel_y2($x)"
.ie n .IP """gsl_sf_bessel_yl_e($l, $x, $result)""" 4
.el .IP "\f(CWgsl_sf_bessel_yl_e($l, $x, $result)\fR" 4
.IX Item "gsl_sf_bessel_yl_e($l, $x, $result)"
.ie n .IP """gsl_sf_bessel_yl($l, $x)""" 4
.el .IP "\f(CWgsl_sf_bessel_yl($l, $x)\fR" 4
.IX Item "gsl_sf_bessel_yl($l, $x)"
.ie n .IP """gsl_sf_bessel_yl_array""" 4
.el .IP "\f(CWgsl_sf_bessel_yl_array\fR" 4
.IX Item "gsl_sf_bessel_yl_array"
.ie n .IP """gsl_sf_bessel_i0_scaled_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_bessel_i0_scaled_e($x, $result)\fR" 4
.IX Item "gsl_sf_bessel_i0_scaled_e($x, $result)"
.ie n .IP """gsl_sf_bessel_i0_scaled($x)""" 4
.el .IP "\f(CWgsl_sf_bessel_i0_scaled($x)\fR" 4
.IX Item "gsl_sf_bessel_i0_scaled($x)"
.ie n .IP """gsl_sf_bessel_i1_scaled_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_bessel_i1_scaled_e($x, $result)\fR" 4
.IX Item "gsl_sf_bessel_i1_scaled_e($x, $result)"
.ie n .IP """gsl_sf_bessel_i1_scaled($x)""" 4
.el .IP "\f(CWgsl_sf_bessel_i1_scaled($x)\fR" 4
.IX Item "gsl_sf_bessel_i1_scaled($x)"
.ie n .IP """gsl_sf_bessel_i2_scaled_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_bessel_i2_scaled_e($x, $result)\fR" 4
.IX Item "gsl_sf_bessel_i2_scaled_e($x, $result)"
.ie n .IP """gsl_sf_bessel_i2_scaled($x)""" 4
.el .IP "\f(CWgsl_sf_bessel_i2_scaled($x)\fR" 4
.IX Item "gsl_sf_bessel_i2_scaled($x)"
.ie n .IP """gsl_sf_bessel_il_scaled_e($l, $x, $result)""" 4
.el .IP "\f(CWgsl_sf_bessel_il_scaled_e($l, $x, $result)\fR" 4
.IX Item "gsl_sf_bessel_il_scaled_e($l, $x, $result)"
.ie n .IP """gsl_sf_bessel_il_scaled($x)""" 4
.el .IP "\f(CWgsl_sf_bessel_il_scaled($x)\fR" 4
.IX Item "gsl_sf_bessel_il_scaled($x)"
.ie n .IP """gsl_sf_bessel_il_scaled_array""" 4
.el .IP "\f(CWgsl_sf_bessel_il_scaled_array\fR" 4
.IX Item "gsl_sf_bessel_il_scaled_array"
.ie n .IP """gsl_sf_bessel_k0_scaled_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_bessel_k0_scaled_e($x, $result)\fR" 4
.IX Item "gsl_sf_bessel_k0_scaled_e($x, $result)"
.ie n .IP """gsl_sf_bessel_k0_scale($x)""" 4
.el .IP "\f(CWgsl_sf_bessel_k0_scale($x)\fR" 4
.IX Item "gsl_sf_bessel_k0_scale($x)"
.ie n .IP """gsl_sf_bessel_k1_scaled_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_bessel_k1_scaled_e($x, $result)\fR" 4
.IX Item "gsl_sf_bessel_k1_scaled_e($x, $result)"
.ie n .IP """gsl_sf_bessel_k1_scaled($x)""" 4
.el .IP "\f(CWgsl_sf_bessel_k1_scaled($x)\fR" 4
.IX Item "gsl_sf_bessel_k1_scaled($x)"
.ie n .IP """gsl_sf_bessel_k2_scaled_e($x, $result) """ 4
.el .IP "\f(CWgsl_sf_bessel_k2_scaled_e($x, $result) \fR" 4
.IX Item "gsl_sf_bessel_k2_scaled_e($x, $result) "
.ie n .IP """gsl_sf_bessel_k2_scaled($x)""" 4
.el .IP "\f(CWgsl_sf_bessel_k2_scaled($x)\fR" 4
.IX Item "gsl_sf_bessel_k2_scaled($x)"
.ie n .IP """gsl_sf_bessel_kl_scaled_e($l, $x, $result)""" 4
.el .IP "\f(CWgsl_sf_bessel_kl_scaled_e($l, $x, $result)\fR" 4
.IX Item "gsl_sf_bessel_kl_scaled_e($l, $x, $result)"
.ie n .IP """gsl_sf_bessel_kl_scaled($l, $x)""" 4
.el .IP "\f(CWgsl_sf_bessel_kl_scaled($l, $x)\fR" 4
.IX Item "gsl_sf_bessel_kl_scaled($l, $x)"
.ie n .IP """gsl_sf_bessel_kl_scaled_array""" 4
.el .IP "\f(CWgsl_sf_bessel_kl_scaled_array\fR" 4
.IX Item "gsl_sf_bessel_kl_scaled_array"
.ie n .IP """gsl_sf_bessel_Jnu_e($nu, $x, $result)""" 4
.el .IP "\f(CWgsl_sf_bessel_Jnu_e($nu, $x, $result)\fR" 4
.IX Item "gsl_sf_bessel_Jnu_e($nu, $x, $result)"
.ie n .IP """gsl_sf_bessel_Jnu($nu, $x)""" 4
.el .IP "\f(CWgsl_sf_bessel_Jnu($nu, $x)\fR" 4
.IX Item "gsl_sf_bessel_Jnu($nu, $x)"
.ie n .IP """gsl_sf_bessel_sequence_Jnu_e """ 4
.el .IP "\f(CWgsl_sf_bessel_sequence_Jnu_e \fR" 4
.IX Item "gsl_sf_bessel_sequence_Jnu_e "
.ie n .IP """gsl_sf_bessel_Ynu_e($nu, $x, $result)""" 4
.el .IP "\f(CWgsl_sf_bessel_Ynu_e($nu, $x, $result)\fR" 4
.IX Item "gsl_sf_bessel_Ynu_e($nu, $x, $result)"
.ie n .IP """gsl_sf_bessel_Ynu($nu, $x)""" 4
.el .IP "\f(CWgsl_sf_bessel_Ynu($nu, $x)\fR" 4
.IX Item "gsl_sf_bessel_Ynu($nu, $x)"
.ie n .IP """gsl_sf_bessel_Inu_scaled_e($nu, $x, $result)""" 4
.el .IP "\f(CWgsl_sf_bessel_Inu_scaled_e($nu, $x, $result)\fR" 4
.IX Item "gsl_sf_bessel_Inu_scaled_e($nu, $x, $result)"
.ie n .IP """gsl_sf_bessel_Inu_scaled($nu, $x)""" 4
.el .IP "\f(CWgsl_sf_bessel_Inu_scaled($nu, $x)\fR" 4
.IX Item "gsl_sf_bessel_Inu_scaled($nu, $x)"
.ie n .IP """gsl_sf_bessel_Inu_e($nu, $x, $result)""" 4
.el .IP "\f(CWgsl_sf_bessel_Inu_e($nu, $x, $result)\fR" 4
.IX Item "gsl_sf_bessel_Inu_e($nu, $x, $result)"
.ie n .IP """gsl_sf_bessel_Inu($nu, $x)""" 4
.el .IP "\f(CWgsl_sf_bessel_Inu($nu, $x)\fR" 4
.IX Item "gsl_sf_bessel_Inu($nu, $x)"
.ie n .IP """gsl_sf_bessel_Knu_scaled_e($nu, $x, $result)""" 4
.el .IP "\f(CWgsl_sf_bessel_Knu_scaled_e($nu, $x, $result)\fR" 4
.IX Item "gsl_sf_bessel_Knu_scaled_e($nu, $x, $result)"
.ie n .IP """gsl_sf_bessel_Knu_scaled($nu, $x)""" 4
.el .IP "\f(CWgsl_sf_bessel_Knu_scaled($nu, $x)\fR" 4
.IX Item "gsl_sf_bessel_Knu_scaled($nu, $x)"
.ie n .IP """gsl_sf_bessel_Knu_e($nu, $x, $result)""" 4
.el .IP "\f(CWgsl_sf_bessel_Knu_e($nu, $x, $result)\fR" 4
.IX Item "gsl_sf_bessel_Knu_e($nu, $x, $result)"
.ie n .IP """gsl_sf_bessel_Knu($nu, $x)""" 4
.el .IP "\f(CWgsl_sf_bessel_Knu($nu, $x)\fR" 4
.IX Item "gsl_sf_bessel_Knu($nu, $x)"
.ie n .IP """gsl_sf_bessel_lnKnu_e($nu, $x, $result)""" 4
.el .IP "\f(CWgsl_sf_bessel_lnKnu_e($nu, $x, $result)\fR" 4
.IX Item "gsl_sf_bessel_lnKnu_e($nu, $x, $result)"
.ie n .IP """gsl_sf_bessel_lnKnu($nu, $x)""" 4
.el .IP "\f(CWgsl_sf_bessel_lnKnu($nu, $x)\fR" 4
.IX Item "gsl_sf_bessel_lnKnu($nu, $x)"
.ie n .IP """gsl_sf_bessel_zero_J0_e($s, $result)""" 4
.el .IP "\f(CWgsl_sf_bessel_zero_J0_e($s, $result)\fR" 4
.IX Item "gsl_sf_bessel_zero_J0_e($s, $result)"
.ie n .IP """gsl_sf_bessel_zero_J0($s)""" 4
.el .IP "\f(CWgsl_sf_bessel_zero_J0($s)\fR" 4
.IX Item "gsl_sf_bessel_zero_J0($s)"
.ie n .IP """gsl_sf_bessel_zero_J1_e($s, $result)""" 4
.el .IP "\f(CWgsl_sf_bessel_zero_J1_e($s, $result)\fR" 4
.IX Item "gsl_sf_bessel_zero_J1_e($s, $result)"
.ie n .IP """gsl_sf_bessel_zero_J1($s)""" 4
.el .IP "\f(CWgsl_sf_bessel_zero_J1($s)\fR" 4
.IX Item "gsl_sf_bessel_zero_J1($s)"
.ie n .IP """gsl_sf_bessel_zero_Jnu_e($nu, $s, $result)""" 4
.el .IP "\f(CWgsl_sf_bessel_zero_Jnu_e($nu, $s, $result)\fR" 4
.IX Item "gsl_sf_bessel_zero_Jnu_e($nu, $s, $result)"
.ie n .IP """gsl_sf_bessel_zero_Jnu($nu, $s)""" 4
.el .IP "\f(CWgsl_sf_bessel_zero_Jnu($nu, $s)\fR" 4
.IX Item "gsl_sf_bessel_zero_Jnu($nu, $s)"
.ie n .IP """gsl_sf_clausen_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_clausen_e($x, $result)\fR" 4
.IX Item "gsl_sf_clausen_e($x, $result)"
.ie n .IP """gsl_sf_clausen($x)""" 4
.el .IP "\f(CWgsl_sf_clausen($x)\fR" 4
.IX Item "gsl_sf_clausen($x)"
.ie n .IP """gsl_sf_hydrogenicR_1_e($Z, $r, $result)""" 4
.el .IP "\f(CWgsl_sf_hydrogenicR_1_e($Z, $r, $result)\fR" 4
.IX Item "gsl_sf_hydrogenicR_1_e($Z, $r, $result)"
.ie n .IP """gsl_sf_hydrogenicR_1($Z, $r)""" 4
.el .IP "\f(CWgsl_sf_hydrogenicR_1($Z, $r)\fR" 4
.IX Item "gsl_sf_hydrogenicR_1($Z, $r)"
.ie n .IP """gsl_sf_hydrogenicR_e($n, $l, $Z, $r, $result)""" 4
.el .IP "\f(CWgsl_sf_hydrogenicR_e($n, $l, $Z, $r, $result)\fR" 4
.IX Item "gsl_sf_hydrogenicR_e($n, $l, $Z, $r, $result)"
.ie n .IP """gsl_sf_hydrogenicR($n, $l, $Z, $r)""" 4
.el .IP "\f(CWgsl_sf_hydrogenicR($n, $l, $Z, $r)\fR" 4
.IX Item "gsl_sf_hydrogenicR($n, $l, $Z, $r)"
.ie n .IP """gsl_sf_coulomb_wave_FG_e($eta, $x, $L_F, $k, $F, gsl_sf_result * Fp, gsl_sf_result * G, $Gp)"" \- This function computes the Coulomb wave functions F_L(\eeta,x), G_{L\-k}(\eeta,x) and their derivatives F'_L(\eeta,x), G'_{L\-k}(\eeta,x) with respect to $x. The parameters are restricted to L, L\-k > \-1/2, x > 0 and integer $k. Note that L itself is not restricted to being an integer. The results are stored in the parameters $F, $G for the function values and $Fp, $Gp for the derivative values. $F, $G, $Fp, $Gp are all gsl_result structs. If an overflow occurs, $GSL_EOVRFLW is returned and scaling exponents are returned as second and third values." 4
.el .IP "\f(CWgsl_sf_coulomb_wave_FG_e($eta, $x, $L_F, $k, $F, gsl_sf_result * Fp, gsl_sf_result * G, $Gp)\fR \- This function computes the Coulomb wave functions F_L(\eeta,x), G_{L\-k}(\eeta,x) and their derivatives F'_L(\eeta,x), G'_{L\-k}(\eeta,x) with respect to \f(CW$x\fR. The parameters are restricted to L, L\-k > \-1/2, x > 0 and integer \f(CW$k\fR. Note that L itself is not restricted to being an integer. The results are stored in the parameters \f(CW$F\fR, \f(CW$G\fR for the function values and \f(CW$Fp\fR, \f(CW$Gp\fR for the derivative values. \f(CW$F\fR, \f(CW$G\fR, \f(CW$Fp\fR, \f(CW$Gp\fR are all gsl_result structs. If an overflow occurs, \f(CW$GSL_EOVRFLW\fR is returned and scaling exponents are returned as second and third values." 4
.IX Item "gsl_sf_coulomb_wave_FG_e($eta, $x, $L_F, $k, $F, gsl_sf_result * Fp, gsl_sf_result * G, $Gp) - This function computes the Coulomb wave functions F_L(eta,x), G_{L-k}(eta,x) and their derivatives F'_L(eta,x), G'_{L-k}(eta,x) with respect to $x. The parameters are restricted to L, L-k > -1/2, x > 0 and integer $k. Note that L itself is not restricted to being an integer. The results are stored in the parameters $F, $G for the function values and $Fp, $Gp for the derivative values. $F, $G, $Fp, $Gp are all gsl_result structs. If an overflow occurs, $GSL_EOVRFLW is returned and scaling exponents are returned as second and third values."
.ie n .IP """gsl_sf_coulomb_wave_F_array "" \-" 4
.el .IP "\f(CWgsl_sf_coulomb_wave_F_array \fR \-" 4
.IX Item "gsl_sf_coulomb_wave_F_array  -"
.ie n .IP """gsl_sf_coulomb_wave_FG_array"" \-" 4
.el .IP "\f(CWgsl_sf_coulomb_wave_FG_array\fR \-" 4
.IX Item "gsl_sf_coulomb_wave_FG_array -"
.ie n .IP """gsl_sf_coulomb_wave_FGp_array"" \-" 4
.el .IP "\f(CWgsl_sf_coulomb_wave_FGp_array\fR \-" 4
.IX Item "gsl_sf_coulomb_wave_FGp_array -"
.ie n .IP """gsl_sf_coulomb_wave_sphF_array"" \-" 4
.el .IP "\f(CWgsl_sf_coulomb_wave_sphF_array\fR \-" 4
.IX Item "gsl_sf_coulomb_wave_sphF_array -"
.ie n .IP """gsl_sf_coulomb_CL_e($L, $eta, $result)"" \- This function computes the Coulomb wave function normalization constant C_L($eta) for $L > \-1." 4
.el .IP "\f(CWgsl_sf_coulomb_CL_e($L, $eta, $result)\fR \- This function computes the Coulomb wave function normalization constant C_L($eta) for \f(CW$L\fR > \-1." 4
.IX Item "gsl_sf_coulomb_CL_e($L, $eta, $result) - This function computes the Coulomb wave function normalization constant C_L($eta) for $L > -1."
.ie n .IP """gsl_sf_coulomb_CL_arrayi"" \-" 4
.el .IP "\f(CWgsl_sf_coulomb_CL_arrayi\fR \-" 4
.IX Item "gsl_sf_coulomb_CL_arrayi -"
.ie n .IP """gsl_sf_coupling_3j_e($two_ja, $two_jb, $two_jc, $two_ma, $two_mb, $two_mc, $result)""" 4
.el .IP "\f(CWgsl_sf_coupling_3j_e($two_ja, $two_jb, $two_jc, $two_ma, $two_mb, $two_mc, $result)\fR" 4
.IX Item "gsl_sf_coupling_3j_e($two_ja, $two_jb, $two_jc, $two_ma, $two_mb, $two_mc, $result)"
.ie n .IP """gsl_sf_coupling_3j($two_ja, $two_jb, $two_jc, $two_ma, $two_mb, $two_mc)""" 4
.el .IP "\f(CWgsl_sf_coupling_3j($two_ja, $two_jb, $two_jc, $two_ma, $two_mb, $two_mc)\fR" 4
.IX Item "gsl_sf_coupling_3j($two_ja, $two_jb, $two_jc, $two_ma, $two_mb, $two_mc)"
.PD
.Vb 4
\& These routines compute the Wigner 3\-j coefficient,
\&   (ja jb jc
\&    ma mb mc)
\& where the arguments are given in half\-integer units, ja = $two_ja/2, ma = $two_ma/2, etc.
.Ve
.ie n .IP """gsl_sf_coupling_6j_e($two_ja, $two_jb, $two_jc, $two_jd, $two_je, $two_jf, $result)""" 4
.el .IP "\f(CWgsl_sf_coupling_6j_e($two_ja, $two_jb, $two_jc, $two_jd, $two_je, $two_jf, $result)\fR" 4
.IX Item "gsl_sf_coupling_6j_e($two_ja, $two_jb, $two_jc, $two_jd, $two_je, $two_jf, $result)"
.PD 0
.ie n .IP """gsl_sf_coupling_6j($two_ja, $two_jb, $two_jc, $two_jd, $two_je, $two_jf)""" 4
.el .IP "\f(CWgsl_sf_coupling_6j($two_ja, $two_jb, $two_jc, $two_jd, $two_je, $two_jf)\fR" 4
.IX Item "gsl_sf_coupling_6j($two_ja, $two_jb, $two_jc, $two_jd, $two_je, $two_jf)"
.PD
.Vb 4
\& These routines compute the Wigner 6\-j coefficient,
\&   {ja jb jc
\&    jd je jf}
\& where the arguments are given in half\-integer units, ja = $two_ja/2, ma = $two_ma/2, etc.
.Ve
.ie n .IP """gsl_sf_coupling_RacahW_e""" 4
.el .IP "\f(CWgsl_sf_coupling_RacahW_e\fR" 4
.IX Item "gsl_sf_coupling_RacahW_e"
.PD 0
.ie n .IP """gsl_sf_coupling_RacahW""" 4
.el .IP "\f(CWgsl_sf_coupling_RacahW\fR" 4
.IX Item "gsl_sf_coupling_RacahW"
.ie n .IP """gsl_sf_coupling_9j_e($two_ja, $two_jb, $two_jc, $two_jd, $two_je, $two_jf, $two_jg, $two_jh, $two_ji, $result)""" 4
.el .IP "\f(CWgsl_sf_coupling_9j_e($two_ja, $two_jb, $two_jc, $two_jd, $two_je, $two_jf, $two_jg, $two_jh, $two_ji, $result)\fR" 4
.IX Item "gsl_sf_coupling_9j_e($two_ja, $two_jb, $two_jc, $two_jd, $two_je, $two_jf, $two_jg, $two_jh, $two_ji, $result)"
.ie n .IP """gsl_sf_coupling_9j($two_ja, $two_jb, $two_jc, $two_jd, $two_je, $two_jf, $two_jg, $two_jh, $two_ji)""" 4
.el .IP "\f(CWgsl_sf_coupling_9j($two_ja, $two_jb, $two_jc, $two_jd, $two_je, $two_jf, $two_jg, $two_jh, $two_ji)\fR" 4
.IX Item "gsl_sf_coupling_9j($two_ja, $two_jb, $two_jc, $two_jd, $two_je, $two_jf, $two_jg, $two_jh, $two_ji)"
.PD
These routines compute the Wigner 9\-j coefficient,
.Sp
.Vb 4
\&          {ja jb jc
\&           jd je jf
\&           jg jh ji}
\& where the arguments are given in half\-integer units, ja = two_ja/2, ma = two_ma/2, etc.
.Ve
.ie n .IP """gsl_sf_dawson_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_dawson_e($x, $result)\fR" 4
.IX Item "gsl_sf_dawson_e($x, $result)"
.PD 0
.ie n .IP """gsl_sf_dawson($x)""" 4
.el .IP "\f(CWgsl_sf_dawson($x)\fR" 4
.IX Item "gsl_sf_dawson($x)"
.PD
These routines compute the value of Dawson's integral for \f(CW$x\fR.
.ie n .IP """gsl_sf_debye_1_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_debye_1_e($x, $result)\fR" 4
.IX Item "gsl_sf_debye_1_e($x, $result)"
.PD 0
.ie n .IP """gsl_sf_debye_1($x)""" 4
.el .IP "\f(CWgsl_sf_debye_1($x)\fR" 4
.IX Item "gsl_sf_debye_1($x)"
.PD
These routines compute the first-order Debye function D_1(x) = (1/x) \eint_0^x dt (t/(e^t \- 1)).
.ie n .IP """gsl_sf_debye_2_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_debye_2_e($x, $result)\fR" 4
.IX Item "gsl_sf_debye_2_e($x, $result)"
.PD 0
.ie n .IP """gsl_sf_debye_2($x)""" 4
.el .IP "\f(CWgsl_sf_debye_2($x)\fR" 4
.IX Item "gsl_sf_debye_2($x)"
.PD
These routines compute the second-order Debye function D_2(x) = (2/x^2) \eint_0^x dt (t^2/(e^t \- 1)).
.ie n .IP """gsl_sf_debye_3_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_debye_3_e($x, $result)\fR" 4
.IX Item "gsl_sf_debye_3_e($x, $result)"
.PD 0
.ie n .IP """gsl_sf_debye_3($x)""" 4
.el .IP "\f(CWgsl_sf_debye_3($x)\fR" 4
.IX Item "gsl_sf_debye_3($x)"
.PD
These routines compute the third-order Debye function D_3(x) = (3/x^3) \eint_0^x dt (t^3/(e^t \- 1)).
.ie n .IP """gsl_sf_debye_4_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_debye_4_e($x, $result)\fR" 4
.IX Item "gsl_sf_debye_4_e($x, $result)"
.PD 0
.ie n .IP """gsl_sf_debye_4($x)""" 4
.el .IP "\f(CWgsl_sf_debye_4($x)\fR" 4
.IX Item "gsl_sf_debye_4($x)"
.PD
These routines compute the fourth-order Debye function D_4(x) = (4/x^4) \eint_0^x dt (t^4/(e^t \- 1)).
.ie n .IP """gsl_sf_debye_5_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_debye_5_e($x, $result)\fR" 4
.IX Item "gsl_sf_debye_5_e($x, $result)"
.PD 0
.ie n .IP """gsl_sf_debye_5($x)""" 4
.el .IP "\f(CWgsl_sf_debye_5($x)\fR" 4
.IX Item "gsl_sf_debye_5($x)"
.PD
These routines compute the fifth-order Debye function D_5(x) = (5/x^5) \eint_0^x dt (t^5/(e^t \- 1)).
.ie n .IP """gsl_sf_debye_6_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_debye_6_e($x, $result)\fR" 4
.IX Item "gsl_sf_debye_6_e($x, $result)"
.PD 0
.ie n .IP """gsl_sf_debye_6($x)""" 4
.el .IP "\f(CWgsl_sf_debye_6($x)\fR" 4
.IX Item "gsl_sf_debye_6($x)"
.PD
These routines compute the sixth-order Debye function D_6(x) = (6/x^6) \eint_0^x dt (t^6/(e^t \- 1)).
.ie n .IP """gsl_sf_dilog_e ($x, $result)""" 4
.el .IP "\f(CWgsl_sf_dilog_e ($x, $result)\fR" 4
.IX Item "gsl_sf_dilog_e ($x, $result)"
.PD 0
.ie n .IP """gsl_sf_dilog($x)""" 4
.el .IP "\f(CWgsl_sf_dilog($x)\fR" 4
.IX Item "gsl_sf_dilog($x)"
.PD
.Vb 1
\& These routines compute the dilogarithm for a real argument. In Lewin\*(Aqs notation this is Li_2(x), the real part of the dilogarithm of a real x. It is defined by the integral representation Li_2(x) = \- \eRe \eint_0^x ds \elog(1\-s) / s. Note that \eIm(Li_2(x)) = 0 for x <= 1, and \-\epi\elog(x) for x > 1. Note that Abramowitz & Stegun refer to the Spence integral S(x)=Li_2(1\-x) as the dilogarithm rather than Li_2(x).
.Ve
.ie n .IP """gsl_sf_complex_dilog_xy_e"" \-" 4
.el .IP "\f(CWgsl_sf_complex_dilog_xy_e\fR \-" 4
.IX Item "gsl_sf_complex_dilog_xy_e -"
.PD 0
.ie n .IP """gsl_sf_complex_dilog_e($r, $theta, $result_re, $result_im)"" \- This function computes the full complex-valued dilogarithm for the complex argument z = r \eexp(i \etheta). The real and imaginary parts of the result are returned in the $result_re and $result_im gsl_result structs." 4
.el .IP "\f(CWgsl_sf_complex_dilog_e($r, $theta, $result_re, $result_im)\fR \- This function computes the full complex-valued dilogarithm for the complex argument z = r \eexp(i \etheta). The real and imaginary parts of the result are returned in the \f(CW$result_re\fR and \f(CW$result_im\fR gsl_result structs." 4
.IX Item "gsl_sf_complex_dilog_e($r, $theta, $result_re, $result_im) - This function computes the full complex-valued dilogarithm for the complex argument z = r exp(i theta). The real and imaginary parts of the result are returned in the $result_re and $result_im gsl_result structs."
.ie n .IP """gsl_sf_complex_spence_xy_e"" \-" 4
.el .IP "\f(CWgsl_sf_complex_spence_xy_e\fR \-" 4
.IX Item "gsl_sf_complex_spence_xy_e -"
.ie n .IP """gsl_sf_multiply""" 4
.el .IP "\f(CWgsl_sf_multiply\fR" 4
.IX Item "gsl_sf_multiply"
.ie n .IP """gsl_sf_multiply_e($x, $y, $result)"" \- This function multiplies $x and $y storing the product and its associated error in $result." 4
.el .IP "\f(CWgsl_sf_multiply_e($x, $y, $result)\fR \- This function multiplies \f(CW$x\fR and \f(CW$y\fR storing the product and its associated error in \f(CW$result\fR." 4
.IX Item "gsl_sf_multiply_e($x, $y, $result) - This function multiplies $x and $y storing the product and its associated error in $result."
.ie n .IP """gsl_sf_multiply_err_e($x, $dx, $y, $dy, $result)"" \- This function multiplies $x and $y with associated absolute errors $dx and $dy. The product xy +/\- xy \esqrt((dx/x)^2 +(dy/y)^2) is stored in $result." 4
.el .IP "\f(CWgsl_sf_multiply_err_e($x, $dx, $y, $dy, $result)\fR \- This function multiplies \f(CW$x\fR and \f(CW$y\fR with associated absolute errors \f(CW$dx\fR and \f(CW$dy\fR. The product xy +/\- xy \esqrt((dx/x)^2 +(dy/y)^2) is stored in \f(CW$result\fR." 4
.IX Item "gsl_sf_multiply_err_e($x, $dx, $y, $dy, $result) - This function multiplies $x and $y with associated absolute errors $dx and $dy. The product xy +/- xy sqrt((dx/x)^2 +(dy/y)^2) is stored in $result."
.ie n .IP """gsl_sf_ellint_Kcomp_e($k, $mode, $result)""" 4
.el .IP "\f(CWgsl_sf_ellint_Kcomp_e($k, $mode, $result)\fR" 4
.IX Item "gsl_sf_ellint_Kcomp_e($k, $mode, $result)"
.ie n .IP """gsl_sf_ellint_Kcomp($k, $mode)""" 4
.el .IP "\f(CWgsl_sf_ellint_Kcomp($k, $mode)\fR" 4
.IX Item "gsl_sf_ellint_Kcomp($k, $mode)"
.PD
These routines compute the complete elliptic integral K($k) to the accuracy specified by the mode variable mode. Note that Abramowitz & Stegun define this function in terms of the parameter m = k^2.
.ie n .IP """gsl_sf_ellint_Ecomp_e($k, $mode, $result)""" 4
.el .IP "\f(CWgsl_sf_ellint_Ecomp_e($k, $mode, $result)\fR" 4
.IX Item "gsl_sf_ellint_Ecomp_e($k, $mode, $result)"
.PD 0
.ie n .IP """gsl_sf_ellint_Ecomp($k, $mode)""" 4
.el .IP "\f(CWgsl_sf_ellint_Ecomp($k, $mode)\fR" 4
.IX Item "gsl_sf_ellint_Ecomp($k, $mode)"
.ie n .IP """gsl_sf_ellint_Pcomp_e($k, $n, $mode, $result)""" 4
.el .IP "\f(CWgsl_sf_ellint_Pcomp_e($k, $n, $mode, $result)\fR" 4
.IX Item "gsl_sf_ellint_Pcomp_e($k, $n, $mode, $result)"
.ie n .IP """gsl_sf_ellint_Pcomp($k, $n, $mode)""" 4
.el .IP "\f(CWgsl_sf_ellint_Pcomp($k, $n, $mode)\fR" 4
.IX Item "gsl_sf_ellint_Pcomp($k, $n, $mode)"
.ie n .IP """gsl_sf_ellint_Dcomp_e""" 4
.el .IP "\f(CWgsl_sf_ellint_Dcomp_e\fR" 4
.IX Item "gsl_sf_ellint_Dcomp_e"
.ie n .IP """gsl_sf_ellint_Dcomp """ 4
.el .IP "\f(CWgsl_sf_ellint_Dcomp \fR" 4
.IX Item "gsl_sf_ellint_Dcomp "
.ie n .IP """gsl_sf_ellint_F_e($phi, $k, $mode, $result)""" 4
.el .IP "\f(CWgsl_sf_ellint_F_e($phi, $k, $mode, $result)\fR" 4
.IX Item "gsl_sf_ellint_F_e($phi, $k, $mode, $result)"
.ie n .IP """gsl_sf_ellint_F($phi, $k, $mode)""" 4
.el .IP "\f(CWgsl_sf_ellint_F($phi, $k, $mode)\fR" 4
.IX Item "gsl_sf_ellint_F($phi, $k, $mode)"
.PD
These routines compute the incomplete elliptic integral F($phi,$k) to the accuracy specified by the mode variable mode. Note that Abramowitz & Stegun define this function in terms of the parameter m = k^2.
.ie n .IP """gsl_sf_ellint_E_e($phi, $k, $mode, $result)""" 4
.el .IP "\f(CWgsl_sf_ellint_E_e($phi, $k, $mode, $result)\fR" 4
.IX Item "gsl_sf_ellint_E_e($phi, $k, $mode, $result)"
.PD 0
.ie n .IP """gsl_sf_ellint_E($phi, $k, $mode)""" 4
.el .IP "\f(CWgsl_sf_ellint_E($phi, $k, $mode)\fR" 4
.IX Item "gsl_sf_ellint_E($phi, $k, $mode)"
.PD
These routines compute the incomplete elliptic integral E($phi,$k) to the accuracy specified by the mode variable mode. Note that Abramowitz & Stegun define this function in terms of the parameter m = k^2.
.ie n .IP """gsl_sf_ellint_P_e($phi, $k, $n, $mode, $result)""" 4
.el .IP "\f(CWgsl_sf_ellint_P_e($phi, $k, $n, $mode, $result)\fR" 4
.IX Item "gsl_sf_ellint_P_e($phi, $k, $n, $mode, $result)"
.PD 0
.ie n .IP """gsl_sf_ellint_P($phi, $k, $n, $mode)""" 4
.el .IP "\f(CWgsl_sf_ellint_P($phi, $k, $n, $mode)\fR" 4
.IX Item "gsl_sf_ellint_P($phi, $k, $n, $mode)"
.PD
These routines compute the incomplete elliptic integral \ePi(\ephi,k,n) to the accuracy specified by the mode variable mode. Note that Abramowitz & Stegun define this function in terms of the parameters m = k^2 and \esin^2(\ealpha) = k^2, with the change of sign n \eto \-n.
.ie n .IP """gsl_sf_ellint_D_e($phi, $k, $n, $mode, $result)""" 4
.el .IP "\f(CWgsl_sf_ellint_D_e($phi, $k, $n, $mode, $result)\fR" 4
.IX Item "gsl_sf_ellint_D_e($phi, $k, $n, $mode, $result)"
.PD 0
.ie n .IP """gsl_sf_ellint_D($phi, $k, $n, $mode)""" 4
.el .IP "\f(CWgsl_sf_ellint_D($phi, $k, $n, $mode)\fR" 4
.IX Item "gsl_sf_ellint_D($phi, $k, $n, $mode)"
.PD
These functions compute the incomplete elliptic integral D(\ephi,k) which is defined through the Carlson form \s-1RD\s0(x,y,z) by the following relation, D(\ephi,k,n) = (1/3)(\esin(\ephi))^3 \s-1RD\s0 (1\-\esin^2(\ephi), 1\-k^2 \esin^2(\ephi), 1). The argument \f(CW$n\fR is not used and will be removed in a future release.
.ie n .IP """gsl_sf_ellint_RC_e($x, $y, $mode, $result)""" 4
.el .IP "\f(CWgsl_sf_ellint_RC_e($x, $y, $mode, $result)\fR" 4
.IX Item "gsl_sf_ellint_RC_e($x, $y, $mode, $result)"
.PD 0
.ie n .IP """gsl_sf_ellint_RC($x, $y, $mode)""" 4
.el .IP "\f(CWgsl_sf_ellint_RC($x, $y, $mode)\fR" 4
.IX Item "gsl_sf_ellint_RC($x, $y, $mode)"
.PD
.Vb 1
\& These routines compute the incomplete elliptic integral RC($x,$y) to the accuracy specified by the mode variable $mode.
.Ve
.ie n .IP """gsl_sf_ellint_RD_e($x, $y, $z, $mode, $result)""" 4
.el .IP "\f(CWgsl_sf_ellint_RD_e($x, $y, $z, $mode, $result)\fR" 4
.IX Item "gsl_sf_ellint_RD_e($x, $y, $z, $mode, $result)"
.PD 0
.ie n .IP """gsl_sf_ellint_RD($x, $y, $z, $mode)""" 4
.el .IP "\f(CWgsl_sf_ellint_RD($x, $y, $z, $mode)\fR" 4
.IX Item "gsl_sf_ellint_RD($x, $y, $z, $mode)"
.PD
.Vb 1
\& These routines compute the incomplete elliptic integral RD($x,$y,$z) to the accuracy specified by the mode variable $mode.
.Ve
.ie n .IP """gsl_sf_ellint_RF_e($x, $y, $z, $mode, $result)""" 4
.el .IP "\f(CWgsl_sf_ellint_RF_e($x, $y, $z, $mode, $result)\fR" 4
.IX Item "gsl_sf_ellint_RF_e($x, $y, $z, $mode, $result)"
.PD 0
.ie n .IP """gsl_sf_ellint_RF($x, $y, $z, $mode)""" 4
.el .IP "\f(CWgsl_sf_ellint_RF($x, $y, $z, $mode)\fR" 4
.IX Item "gsl_sf_ellint_RF($x, $y, $z, $mode)"
.PD
.Vb 1
\& These routines compute the incomplete elliptic integral RF($x,$y,$z) to the accuracy specified by the mode variable $mode.
.Ve
.ie n .IP """gsl_sf_ellint_RJ_e($x, $y, $z, $p, $mode, $result)""" 4
.el .IP "\f(CWgsl_sf_ellint_RJ_e($x, $y, $z, $p, $mode, $result)\fR" 4
.IX Item "gsl_sf_ellint_RJ_e($x, $y, $z, $p, $mode, $result)"
.PD 0
.ie n .IP """gsl_sf_ellint_RJ($x, $y, $z, $p, $mode)""" 4
.el .IP "\f(CWgsl_sf_ellint_RJ($x, $y, $z, $p, $mode)\fR" 4
.IX Item "gsl_sf_ellint_RJ($x, $y, $z, $p, $mode)"
.PD
.Vb 1
\& These routines compute the incomplete elliptic integral RJ($x,$y,$z,$p) to the accuracy specified by the mode variable $mode.
.Ve
.ie n .IP """gsl_sf_elljac_e($u, $m)"" \- This function computes the Jacobian elliptic functions sn(u|m), cn(u|m), dn(u|m) by descending Landen transformations. The function returns 0 if the operation succeded, 1 otherwise and then returns the result of sn, cn and dn in this order." 4
.el .IP "\f(CWgsl_sf_elljac_e($u, $m)\fR \- This function computes the Jacobian elliptic functions sn(u|m), cn(u|m), dn(u|m) by descending Landen transformations. The function returns 0 if the operation succeded, 1 otherwise and then returns the result of sn, cn and dn in this order." 4
.IX Item "gsl_sf_elljac_e($u, $m) - This function computes the Jacobian elliptic functions sn(u|m), cn(u|m), dn(u|m) by descending Landen transformations. The function returns 0 if the operation succeded, 1 otherwise and then returns the result of sn, cn and dn in this order."
.PD 0
.ie n .IP """gsl_sf_erfc_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_erfc_e($x, $result)\fR" 4
.IX Item "gsl_sf_erfc_e($x, $result)"
.ie n .IP """gsl_sf_erfc($x)""" 4
.el .IP "\f(CWgsl_sf_erfc($x)\fR" 4
.IX Item "gsl_sf_erfc($x)"
.PD
These routines compute the complementary error function erfc(x) = 1 \- erf(x) = (2/\esqrt(\epi)) \eint_x^\einfty \eexp(\-t^2).
.ie n .IP """gsl_sf_log_erfc_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_log_erfc_e($x, $result)\fR" 4
.IX Item "gsl_sf_log_erfc_e($x, $result)"
.PD 0
.ie n .IP """gsl_sf_log_erfc($x)""" 4
.el .IP "\f(CWgsl_sf_log_erfc($x)\fR" 4
.IX Item "gsl_sf_log_erfc($x)"
.PD
These routines compute the logarithm of the complementary error function \elog(\eerfc(x)).
.ie n .IP """gsl_sf_erf_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_erf_e($x, $result)\fR" 4
.IX Item "gsl_sf_erf_e($x, $result)"
.PD 0
.ie n .IP """gsl_sf_erf($x)""" 4
.el .IP "\f(CWgsl_sf_erf($x)\fR" 4
.IX Item "gsl_sf_erf($x)"
.PD
These routines compute the error function erf(x), where erf(x) = (2/\esqrt(\epi)) \eint_0^x dt \eexp(\-t^2).
.ie n .IP """gsl_sf_erf_Z_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_erf_Z_e($x, $result)\fR" 4
.IX Item "gsl_sf_erf_Z_e($x, $result)"
.PD 0
.ie n .IP """gsl_sf_erf_Z($x)""" 4
.el .IP "\f(CWgsl_sf_erf_Z($x)\fR" 4
.IX Item "gsl_sf_erf_Z($x)"
.PD
These routines compute the Gaussian probability density function Z(x) = (1/\esqrt{2\epi}) \eexp(\-x^2/2).
.ie n .IP """gsl_sf_erf_Q_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_erf_Q_e($x, $result)\fR" 4
.IX Item "gsl_sf_erf_Q_e($x, $result)"
.PD 0
.ie n .IP """gsl_sf_erf_Q($x)""" 4
.el .IP "\f(CWgsl_sf_erf_Q($x)\fR" 4
.IX Item "gsl_sf_erf_Q($x)"
.PD
.Vb 1
\& These routines compute the upper tail of the Gaussian probability function Q(x) = (1/\esqrt{2\epi}) \eint_x^\einfty dt \eexp(\-t^2/2). The hazard function for the normal distribution, also known as the inverse Mill\*(Aqs ratio, is defined as, h(x) = Z(x)/Q(x) = \esqrt{2/\epi} \eexp(\-x^2 / 2) / \eerfc(x/\esqrt 2) It decreases rapidly as x approaches \-\einfty and asymptotes to h(x) \esim x as x approaches +\einfty.
.Ve
.ie n .IP """gsl_sf_hazard_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_hazard_e($x, $result)\fR" 4
.IX Item "gsl_sf_hazard_e($x, $result)"
.PD 0
.ie n .IP """gsl_sf_hazard($x)""" 4
.el .IP "\f(CWgsl_sf_hazard($x)\fR" 4
.IX Item "gsl_sf_hazard($x)"
.PD
.Vb 1
\& These routines compute the hazard function for the normal distribution.
.Ve
.ie n .IP """gsl_sf_exp_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_exp_e($x, $result)\fR" 4
.IX Item "gsl_sf_exp_e($x, $result)"
.PD 0
.ie n .IP """gsl_sf_exp($x)""" 4
.el .IP "\f(CWgsl_sf_exp($x)\fR" 4
.IX Item "gsl_sf_exp($x)"
.PD
.Vb 1
\& These routines provide an exponential function \eexp(x) using GSL semantics and error checking.
.Ve
.ie n .IP """gsl_sf_exp_e10_e"" \-" 4
.el .IP "\f(CWgsl_sf_exp_e10_e\fR \-" 4
.IX Item "gsl_sf_exp_e10_e -"
.PD 0
.ie n .IP """gsl_sf_exp_mult_e """ 4
.el .IP "\f(CWgsl_sf_exp_mult_e \fR" 4
.IX Item "gsl_sf_exp_mult_e "
.ie n .IP """gsl_sf_exp_mult""" 4
.el .IP "\f(CWgsl_sf_exp_mult\fR" 4
.IX Item "gsl_sf_exp_mult"
.ie n .IP """gsl_sf_exp_mult_e10_e"" \-" 4
.el .IP "\f(CWgsl_sf_exp_mult_e10_e\fR \-" 4
.IX Item "gsl_sf_exp_mult_e10_e -"
.ie n .IP """gsl_sf_expm1_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_expm1_e($x, $result)\fR" 4
.IX Item "gsl_sf_expm1_e($x, $result)"
.ie n .IP """gsl_sf_expm1($x)""" 4
.el .IP "\f(CWgsl_sf_expm1($x)\fR" 4
.IX Item "gsl_sf_expm1($x)"
.PD
These routines compute the quantity \eexp(x)\-1 using an algorithm that is accurate for small x.
.ie n .IP """gsl_sf_exprel_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_exprel_e($x, $result)\fR" 4
.IX Item "gsl_sf_exprel_e($x, $result)"
.PD 0
.ie n .IP """gsl_sf_exprel($x)""" 4
.el .IP "\f(CWgsl_sf_exprel($x)\fR" 4
.IX Item "gsl_sf_exprel($x)"
.PD
These routines compute the quantity (\eexp(x)\-1)/x using an algorithm that is accurate for small x. For small x the algorithm is based on the expansion (\eexp(x)\-1)/x = 1 + x/2 + x^2/(2*3) + x^3/(2*3*4) + \edots.
.ie n .IP """gsl_sf_exprel_2_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_exprel_2_e($x, $result)\fR" 4
.IX Item "gsl_sf_exprel_2_e($x, $result)"
.PD 0
.ie n .IP """gsl_sf_exprel_2($x)""" 4
.el .IP "\f(CWgsl_sf_exprel_2($x)\fR" 4
.IX Item "gsl_sf_exprel_2($x)"
.PD
These routines compute the quantity 2(\eexp(x)\-1\-x)/x^2 using an algorithm that is accurate for small x. For small x the algorithm is based on the expansion 2(\eexp(x)\-1\-x)/x^2 = 1 + x/3 + x^2/(3*4) + x^3/(3*4*5) + \edots.
.ie n .IP """gsl_sf_exprel_n_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_exprel_n_e($x, $result)\fR" 4
.IX Item "gsl_sf_exprel_n_e($x, $result)"
.PD 0
.ie n .IP """gsl_sf_exprel_n($x)""" 4
.el .IP "\f(CWgsl_sf_exprel_n($x)\fR" 4
.IX Item "gsl_sf_exprel_n($x)"
.PD
These routines compute the N\-relative exponential, which is the n\-th generalization of the functions gsl_sf_exprel and gsl_sf_exprel2. The N\-relative exponential is given by, 
 exprel_N(x) = N!/x^N (\eexp(x) \- \esum_{k=0}^{N\-1} x^k/k!)
  = 1 + x/(N+1) + x^2/((N+1)(N+2)) + ...
  = 1F1 (1,1+N,x)
.ie n .IP """gsl_sf_exp_err_e($x, $dx, $result)"" \- This function exponentiates $x with an associated absolute error $dx." 4
.el .IP "\f(CWgsl_sf_exp_err_e($x, $dx, $result)\fR \- This function exponentiates \f(CW$x\fR with an associated absolute error \f(CW$dx\fR." 4
.IX Item "gsl_sf_exp_err_e($x, $dx, $result) - This function exponentiates $x with an associated absolute error $dx."
.PD 0
.ie n .IP """gsl_sf_exp_err_e10_e"" \-" 4
.el .IP "\f(CWgsl_sf_exp_err_e10_e\fR \-" 4
.IX Item "gsl_sf_exp_err_e10_e -"
.ie n .IP """gsl_sf_exp_mult_err_e($x, $dx, $y, $dy, $result)"" \-" 4
.el .IP "\f(CWgsl_sf_exp_mult_err_e($x, $dx, $y, $dy, $result)\fR \-" 4
.IX Item "gsl_sf_exp_mult_err_e($x, $dx, $y, $dy, $result) -"
.ie n .IP """gsl_sf_exp_mult_err_e10_e"" \-" 4
.el .IP "\f(CWgsl_sf_exp_mult_err_e10_e\fR \-" 4
.IX Item "gsl_sf_exp_mult_err_e10_e -"
.ie n .IP """gsl_sf_expint_E1_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_expint_E1_e($x, $result)\fR" 4
.IX Item "gsl_sf_expint_E1_e($x, $result)"
.ie n .IP """gsl_sf_expint_E1($x)""" 4
.el .IP "\f(CWgsl_sf_expint_E1($x)\fR" 4
.IX Item "gsl_sf_expint_E1($x)"
.PD
These routines compute the exponential integral E_1(x), E_1(x) := \eRe \eint_1^\einfty dt \eexp(\-xt)/t.
.ie n .IP """gsl_sf_expint_E2_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_expint_E2_e($x, $result)\fR" 4
.IX Item "gsl_sf_expint_E2_e($x, $result)"
.PD 0
.ie n .IP """gsl_sf_expint_E2($x)""" 4
.el .IP "\f(CWgsl_sf_expint_E2($x)\fR" 4
.IX Item "gsl_sf_expint_E2($x)"
.PD
These routines compute the second-order exponential integral E_2(x),
  E_2(x) := \eRe \eint_1^\einfty dt \eexp(\-xt)/t^2.
.ie n .IP """gsl_sf_expint_En_e($n, $x, $result)""" 4
.el .IP "\f(CWgsl_sf_expint_En_e($n, $x, $result)\fR" 4
.IX Item "gsl_sf_expint_En_e($n, $x, $result)"
.PD 0
.ie n .IP """gsl_sf_expint_En($n, $x)""" 4
.el .IP "\f(CWgsl_sf_expint_En($n, $x)\fR" 4
.IX Item "gsl_sf_expint_En($n, $x)"
.PD
These routines compute the exponential integral E_n(x) of order n,
  E_n(x) := \eRe \eint_1^\einfty dt \eexp(\-xt)/t^n.
.ie n .IP """gsl_sf_expint_E1_scaled_e """ 4
.el .IP "\f(CWgsl_sf_expint_E1_scaled_e \fR" 4
.IX Item "gsl_sf_expint_E1_scaled_e "
.PD 0
.ie n .IP """gsl_sf_expint_E1_scaled""" 4
.el .IP "\f(CWgsl_sf_expint_E1_scaled\fR" 4
.IX Item "gsl_sf_expint_E1_scaled"
.ie n .IP """gsl_sf_expint_E2_scaled_e""" 4
.el .IP "\f(CWgsl_sf_expint_E2_scaled_e\fR" 4
.IX Item "gsl_sf_expint_E2_scaled_e"
.ie n .IP """gsl_sf_expint_E2_scaled """ 4
.el .IP "\f(CWgsl_sf_expint_E2_scaled \fR" 4
.IX Item "gsl_sf_expint_E2_scaled "
.ie n .IP """gsl_sf_expint_En_scaled_e""" 4
.el .IP "\f(CWgsl_sf_expint_En_scaled_e\fR" 4
.IX Item "gsl_sf_expint_En_scaled_e"
.ie n .IP """gsl_sf_expint_En_scaled""" 4
.el .IP "\f(CWgsl_sf_expint_En_scaled\fR" 4
.IX Item "gsl_sf_expint_En_scaled"
.ie n .IP """gsl_sf_expint_Ei_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_expint_Ei_e($x, $result)\fR" 4
.IX Item "gsl_sf_expint_Ei_e($x, $result)"
.ie n .IP """gsl_sf_expint_Ei($x)""" 4
.el .IP "\f(CWgsl_sf_expint_Ei($x)\fR" 4
.IX Item "gsl_sf_expint_Ei($x)"
.PD
These routines compute the exponential integral Ei(x), Ei(x) := \- \s-1PV\s0(\eint_{\-x}^\einfty dt \eexp(\-t)/t) where \s-1PV\s0 denotes the principal value of the integral.
.ie n .IP """gsl_sf_expint_Ei_scaled_e""" 4
.el .IP "\f(CWgsl_sf_expint_Ei_scaled_e\fR" 4
.IX Item "gsl_sf_expint_Ei_scaled_e"
.PD 0
.ie n .IP """gsl_sf_expint_Ei_scaled """ 4
.el .IP "\f(CWgsl_sf_expint_Ei_scaled \fR" 4
.IX Item "gsl_sf_expint_Ei_scaled "
.ie n .IP """gsl_sf_Shi_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_Shi_e($x, $result)\fR" 4
.IX Item "gsl_sf_Shi_e($x, $result)"
.ie n .IP """gsl_sf_Shi($x)""" 4
.el .IP "\f(CWgsl_sf_Shi($x)\fR" 4
.IX Item "gsl_sf_Shi($x)"
.PD
These routines compute the integral Shi(x) = \eint_0^x dt \esinh(t)/t.
.ie n .IP """gsl_sf_Chi_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_Chi_e($x, $result)\fR" 4
.IX Item "gsl_sf_Chi_e($x, $result)"
.PD 0
.ie n .IP """gsl_sf_Chi($x)""" 4
.el .IP "\f(CWgsl_sf_Chi($x)\fR" 4
.IX Item "gsl_sf_Chi($x)"
.PD
These routines compute the integral Chi(x) := \eRe[ \egamma_E + \elog(x) + \eint_0^x dt (\ecosh[t]\-1)/t] , where \egamma_E is the Euler constant (available as \f(CW$M_EULER\fR from the Math::GSL::Const module).
.ie n .IP """gsl_sf_expint_3_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_expint_3_e($x, $result)\fR" 4
.IX Item "gsl_sf_expint_3_e($x, $result)"
.PD 0
.ie n .IP """gsl_sf_expint_3($x)""" 4
.el .IP "\f(CWgsl_sf_expint_3($x)\fR" 4
.IX Item "gsl_sf_expint_3($x)"
.PD
These routines compute the third-order exponential integral Ei_3(x) = \eint_0^xdt \eexp(\-t^3) for x >= 0.
.ie n .IP """gsl_sf_Si_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_Si_e($x, $result)\fR" 4
.IX Item "gsl_sf_Si_e($x, $result)"
.PD 0
.ie n .IP """gsl_sf_Si($x)""" 4
.el .IP "\f(CWgsl_sf_Si($x)\fR" 4
.IX Item "gsl_sf_Si($x)"
.PD
These routines compute the Sine integral Si(x) = \eint_0^x dt \esin(t)/t.
.ie n .IP """gsl_sf_Ci_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_Ci_e($x, $result)\fR" 4
.IX Item "gsl_sf_Ci_e($x, $result)"
.PD 0
.ie n .IP """gsl_sf_Ci($x)""" 4
.el .IP "\f(CWgsl_sf_Ci($x)\fR" 4
.IX Item "gsl_sf_Ci($x)"
.PD
These routines compute the Cosine integral Ci(x) = \-\eint_x^\einfty dt \ecos(t)/t for x > 0.
.ie n .IP """gsl_sf_fermi_dirac_m1_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_fermi_dirac_m1_e($x, $result)\fR" 4
.IX Item "gsl_sf_fermi_dirac_m1_e($x, $result)"
.PD 0
.ie n .IP """gsl_sf_fermi_dirac_m1($x)""" 4
.el .IP "\f(CWgsl_sf_fermi_dirac_m1($x)\fR" 4
.IX Item "gsl_sf_fermi_dirac_m1($x)"
.PD
These routines compute the complete Fermi-Dirac integral with an index of \-1. This integral is given by F_{\-1}(x) = e^x / (1 + e^x).
.ie n .IP """gsl_sf_fermi_dirac_0_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_fermi_dirac_0_e($x, $result)\fR" 4
.IX Item "gsl_sf_fermi_dirac_0_e($x, $result)"
.PD 0
.ie n .IP """gsl_sf_fermi_dirac_0($x)""" 4
.el .IP "\f(CWgsl_sf_fermi_dirac_0($x)\fR" 4
.IX Item "gsl_sf_fermi_dirac_0($x)"
.PD
These routines compute the complete Fermi-Dirac integral with an index of 0. This integral is given by F_0(x) = \eln(1 + e^x).
.ie n .IP """gsl_sf_fermi_dirac_1_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_fermi_dirac_1_e($x, $result)\fR" 4
.IX Item "gsl_sf_fermi_dirac_1_e($x, $result)"
.PD 0
.ie n .IP """gsl_sf_fermi_dirac_1($x)""" 4
.el .IP "\f(CWgsl_sf_fermi_dirac_1($x)\fR" 4
.IX Item "gsl_sf_fermi_dirac_1($x)"
.PD
These routines compute the complete Fermi-Dirac integral with an index of 1, F_1(x) = \eint_0^\einfty dt (t /(\eexp(t\-x)+1)).
.ie n .IP """gsl_sf_fermi_dirac_2_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_fermi_dirac_2_e($x, $result)\fR" 4
.IX Item "gsl_sf_fermi_dirac_2_e($x, $result)"
.PD 0
.ie n .IP """gsl_sf_fermi_dirac_2($x)""" 4
.el .IP "\f(CWgsl_sf_fermi_dirac_2($x)\fR" 4
.IX Item "gsl_sf_fermi_dirac_2($x)"
.PD
These routines compute the complete Fermi-Dirac integral with an index of 2, F_2(x) = (1/2) \eint_0^\einfty dt (t^2 /(\eexp(t\-x)+1)).
.ie n .IP """gsl_sf_fermi_dirac_int_e($j, $x, $result)""" 4
.el .IP "\f(CWgsl_sf_fermi_dirac_int_e($j, $x, $result)\fR" 4
.IX Item "gsl_sf_fermi_dirac_int_e($j, $x, $result)"
.PD 0
.ie n .IP """gsl_sf_fermi_dirac_int($j, $x)""" 4
.el .IP "\f(CWgsl_sf_fermi_dirac_int($j, $x)\fR" 4
.IX Item "gsl_sf_fermi_dirac_int($j, $x)"
.PD
These routines compute the complete Fermi-Dirac integral with an integer index of j, F_j(x) = (1/\eGamma(j+1)) \eint_0^\einfty dt (t^j /(\eexp(t\-x)+1)).
.ie n .IP """gsl_sf_fermi_dirac_mhalf_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_fermi_dirac_mhalf_e($x, $result)\fR" 4
.IX Item "gsl_sf_fermi_dirac_mhalf_e($x, $result)"
.PD 0
.ie n .IP """gsl_sf_fermi_dirac_mhalf($x)""" 4
.el .IP "\f(CWgsl_sf_fermi_dirac_mhalf($x)\fR" 4
.IX Item "gsl_sf_fermi_dirac_mhalf($x)"
.PD
These routines compute the complete Fermi-Dirac integral F_{\-1/2}(x).
.ie n .IP """gsl_sf_fermi_dirac_half_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_fermi_dirac_half_e($x, $result)\fR" 4
.IX Item "gsl_sf_fermi_dirac_half_e($x, $result)"
.PD 0
.ie n .IP """gsl_sf_fermi_dirac_half($x)""" 4
.el .IP "\f(CWgsl_sf_fermi_dirac_half($x)\fR" 4
.IX Item "gsl_sf_fermi_dirac_half($x)"
.PD
These routines compute the complete Fermi-Dirac integral F_{1/2}(x).
.ie n .IP """gsl_sf_fermi_dirac_3half_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_fermi_dirac_3half_e($x, $result)\fR" 4
.IX Item "gsl_sf_fermi_dirac_3half_e($x, $result)"
.PD 0
.ie n .IP """gsl_sf_fermi_dirac_3half($x)""" 4
.el .IP "\f(CWgsl_sf_fermi_dirac_3half($x)\fR" 4
.IX Item "gsl_sf_fermi_dirac_3half($x)"
.PD
These routines compute the complete Fermi-Dirac integral F_{3/2}(x).
.ie n .IP """gsl_sf_fermi_dirac_inc_0_e($x, $b, $result)""" 4
.el .IP "\f(CWgsl_sf_fermi_dirac_inc_0_e($x, $b, $result)\fR" 4
.IX Item "gsl_sf_fermi_dirac_inc_0_e($x, $b, $result)"
.PD 0
.ie n .IP """gsl_sf_fermi_dirac_inc_0($x, $b, $result)""" 4
.el .IP "\f(CWgsl_sf_fermi_dirac_inc_0($x, $b, $result)\fR" 4
.IX Item "gsl_sf_fermi_dirac_inc_0($x, $b, $result)"
.PD
These routines compute the incomplete Fermi-Dirac integral with an index of zero, F_0(x,b) = \eln(1 + e^{b\-x}) \- (b\-x).
.ie n .IP """gsl_sf_legendre_Pl_e($l, $x, $result)""" 4
.el .IP "\f(CWgsl_sf_legendre_Pl_e($l, $x, $result)\fR" 4
.IX Item "gsl_sf_legendre_Pl_e($l, $x, $result)"
.PD 0
.ie n .IP """gsl_sf_legendre_Pl($l, $x)""" 4
.el .IP "\f(CWgsl_sf_legendre_Pl($l, $x)\fR" 4
.IX Item "gsl_sf_legendre_Pl($l, $x)"
.PD
These functions evaluate the Legendre polynomial P_l(x) for a specific value of l, x subject to l >= 0, |x| <= 1
.ie n .IP """gsl_sf_legendre_Pl_array""" 4
.el .IP "\f(CWgsl_sf_legendre_Pl_array\fR" 4
.IX Item "gsl_sf_legendre_Pl_array"
.PD 0
.ie n .IP """gsl_sf_legendre_Pl_deriv_array""" 4
.el .IP "\f(CWgsl_sf_legendre_Pl_deriv_array\fR" 4
.IX Item "gsl_sf_legendre_Pl_deriv_array"
.ie n .IP """gsl_sf_legendre_P1_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_legendre_P1_e($x, $result)\fR" 4
.IX Item "gsl_sf_legendre_P1_e($x, $result)"
.ie n .IP """gsl_sf_legendre_P2_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_legendre_P2_e($x, $result)\fR" 4
.IX Item "gsl_sf_legendre_P2_e($x, $result)"
.ie n .IP """gsl_sf_legendre_P3_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_legendre_P3_e($x, $result)\fR" 4
.IX Item "gsl_sf_legendre_P3_e($x, $result)"
.ie n .IP """gsl_sf_legendre_P1($x)""" 4
.el .IP "\f(CWgsl_sf_legendre_P1($x)\fR" 4
.IX Item "gsl_sf_legendre_P1($x)"
.ie n .IP """gsl_sf_legendre_P2($x)""" 4
.el .IP "\f(CWgsl_sf_legendre_P2($x)\fR" 4
.IX Item "gsl_sf_legendre_P2($x)"
.ie n .IP """gsl_sf_legendre_P3($x)""" 4
.el .IP "\f(CWgsl_sf_legendre_P3($x)\fR" 4
.IX Item "gsl_sf_legendre_P3($x)"
.PD
These functions evaluate the Legendre polynomials P_l(x) using explicit representations for l=1, 2, 3.
.ie n .IP """gsl_sf_legendre_Q0_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_legendre_Q0_e($x, $result)\fR" 4
.IX Item "gsl_sf_legendre_Q0_e($x, $result)"
.PD 0
.ie n .IP """gsl_sf_legendre_Q0($x)""" 4
.el .IP "\f(CWgsl_sf_legendre_Q0($x)\fR" 4
.IX Item "gsl_sf_legendre_Q0($x)"
.PD
These routines compute the Legendre function Q_0(x) for x > \-1, x != 1.
.ie n .IP """gsl_sf_legendre_Q1_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_legendre_Q1_e($x, $result)\fR" 4
.IX Item "gsl_sf_legendre_Q1_e($x, $result)"
.PD 0
.ie n .IP """gsl_sf_legendre_Q1($x)""" 4
.el .IP "\f(CWgsl_sf_legendre_Q1($x)\fR" 4
.IX Item "gsl_sf_legendre_Q1($x)"
.PD
These routines compute the Legendre function Q_1(x) for x > \-1, x != 1.
.ie n .IP """gsl_sf_legendre_Ql_e($l, $x, $result)""" 4
.el .IP "\f(CWgsl_sf_legendre_Ql_e($l, $x, $result)\fR" 4
.IX Item "gsl_sf_legendre_Ql_e($l, $x, $result)"
.PD 0
.ie n .IP """gsl_sf_legendre_Ql($l, $x)""" 4
.el .IP "\f(CWgsl_sf_legendre_Ql($l, $x)\fR" 4
.IX Item "gsl_sf_legendre_Ql($l, $x)"
.PD
These routines compute the Legendre function Q_l(x) for x > \-1, x != 1 and l >= 0.
.ie n .IP """gsl_sf_legendre_Plm_e($l, $m, $x, $result)""" 4
.el .IP "\f(CWgsl_sf_legendre_Plm_e($l, $m, $x, $result)\fR" 4
.IX Item "gsl_sf_legendre_Plm_e($l, $m, $x, $result)"
.PD 0
.ie n .IP """gsl_sf_legendre_Plm($l, $m, $x)""" 4
.el .IP "\f(CWgsl_sf_legendre_Plm($l, $m, $x)\fR" 4
.IX Item "gsl_sf_legendre_Plm($l, $m, $x)"
.PD
These routines compute the associated Legendre polynomial P_l^m(x) for m >= 0, l >= m, |x| <= 1.
.ie n .IP """gsl_sf_legendre_Plm_array""" 4
.el .IP "\f(CWgsl_sf_legendre_Plm_array\fR" 4
.IX Item "gsl_sf_legendre_Plm_array"
.PD 0
.ie n .IP """gsl_sf_legendre_Plm_deriv_array """ 4
.el .IP "\f(CWgsl_sf_legendre_Plm_deriv_array \fR" 4
.IX Item "gsl_sf_legendre_Plm_deriv_array "
.ie n .IP """gsl_sf_legendre_sphPlm_e($l, $m, $x, $result)""" 4
.el .IP "\f(CWgsl_sf_legendre_sphPlm_e($l, $m, $x, $result)\fR" 4
.IX Item "gsl_sf_legendre_sphPlm_e($l, $m, $x, $result)"
.ie n .IP """gsl_sf_legendre_sphPlm($l, $m, $x)""" 4
.el .IP "\f(CWgsl_sf_legendre_sphPlm($l, $m, $x)\fR" 4
.IX Item "gsl_sf_legendre_sphPlm($l, $m, $x)"
.PD
These routines compute the normalized associated Legendre polynomial $\esqrt{(2l+1)/(4\epi)} \esqrt{(l\-m)!/(l+m)!} P_l^m(x)$ suitable for use in spherical harmonics. The parameters must satisfy m >= 0, l >= m, |x| <= 1. Theses routines avoid the overflows that occur for the standard normalization of P_l^m(x).
.ie n .IP """gsl_sf_legendre_sphPlm_array """ 4
.el .IP "\f(CWgsl_sf_legendre_sphPlm_array \fR" 4
.IX Item "gsl_sf_legendre_sphPlm_array "
.PD 0
.ie n .IP """gsl_sf_legendre_sphPlm_deriv_array""" 4
.el .IP "\f(CWgsl_sf_legendre_sphPlm_deriv_array\fR" 4
.IX Item "gsl_sf_legendre_sphPlm_deriv_array"
.ie n .IP """gsl_sf_legendre_array_size"" \-" 4
.el .IP "\f(CWgsl_sf_legendre_array_size\fR \-" 4
.IX Item "gsl_sf_legendre_array_size -"
.ie n .IP """gsl_sf_lngamma_e($x, $result)""" 4
.el .IP "\f(CWgsl_sf_lngamma_e($x, $result)\fR" 4
.IX Item "gsl_sf_lngamma_e($x, $result)"
.ie n .IP """gsl_sf_lngamma($x)""" 4
.el .IP "\f(CWgsl_sf_lngamma($x)\fR" 4
.IX Item "gsl_sf_lngamma($x)"
.PD
These routines compute the logarithm of the Gamma function, \elog(\eGamma(x)), subject to x not being a negative integer or zero. For x<0 the real part of \elog(\eGamma(x)) is returned, which is equivalent to \elog(|\eGamma(x)|). The function is computed using the real Lanczos method.
.ie n .IP """gsl_sf_lngamma_sgn_e($x, $result_lg)"" \- This routine returns the sign of the gamma function and the logarithm of its magnitude into this order, subject to $x not being a negative integer or zero. The function is computed using the real Lanczos method. The value of the gamma function can be reconstructed using the relation \eGamma(x) = sgn * \eexp(resultlg)." 4
.el .IP "\f(CWgsl_sf_lngamma_sgn_e($x, $result_lg)\fR \- This routine returns the sign of the gamma function and the logarithm of its magnitude into this order, subject to \f(CW$x\fR not being a negative integer or zero. The function is computed using the real Lanczos method. The value of the gamma function can be reconstructed using the relation \eGamma(x) = sgn * \eexp(resultlg)." 4
.IX Item "gsl_sf_lngamma_sgn_e($x, $result_lg) - This routine returns the sign of the gamma function and the logarithm of its magnitude into this order, subject to $x not being a negative integer or zero. The function is computed using the real Lanczos method. The value of the gamma function can be reconstructed using the relation Gamma(x) = sgn * exp(resultlg)."
.PD 0
.ie n .IP """gsl_sf_gamma_e """ 4
.el .IP "\f(CWgsl_sf_gamma_e \fR" 4
.IX Item "gsl_sf_gamma_e "
.ie n .IP """gsl_sf_gamma""" 4
.el .IP "\f(CWgsl_sf_gamma\fR" 4
.IX Item "gsl_sf_gamma"
.ie n .IP """gsl_sf_gammastar_e""" 4
.el .IP "\f(CWgsl_sf_gammastar_e\fR" 4
.IX Item "gsl_sf_gammastar_e"
.ie n .IP """gsl_sf_gammastar """ 4
.el .IP "\f(CWgsl_sf_gammastar \fR" 4
.IX Item "gsl_sf_gammastar "
.ie n .IP """gsl_sf_gammainv_e""" 4
.el .IP "\f(CWgsl_sf_gammainv_e\fR" 4
.IX Item "gsl_sf_gammainv_e"
.ie n .IP """gsl_sf_gammainv""" 4
.el .IP "\f(CWgsl_sf_gammainv\fR" 4
.IX Item "gsl_sf_gammainv"
.ie n .IP """gsl_sf_lngamma_complex_e """ 4
.el .IP "\f(CWgsl_sf_lngamma_complex_e \fR" 4
.IX Item "gsl_sf_lngamma_complex_e "
.ie n .IP """gsl_sf_gamma_inc_Q_e""" 4
.el .IP "\f(CWgsl_sf_gamma_inc_Q_e\fR" 4
.IX Item "gsl_sf_gamma_inc_Q_e"
.ie n .IP """gsl_sf_gamma_inc_Q""" 4
.el .IP "\f(CWgsl_sf_gamma_inc_Q\fR" 4
.IX Item "gsl_sf_gamma_inc_Q"
.ie n .IP """gsl_sf_gamma_inc_P_e """ 4
.el .IP "\f(CWgsl_sf_gamma_inc_P_e \fR" 4
.IX Item "gsl_sf_gamma_inc_P_e "
.ie n .IP """gsl_sf_gamma_inc_P""" 4
.el .IP "\f(CWgsl_sf_gamma_inc_P\fR" 4
.IX Item "gsl_sf_gamma_inc_P"
.ie n .IP """gsl_sf_gamma_inc_e""" 4
.el .IP "\f(CWgsl_sf_gamma_inc_e\fR" 4
.IX Item "gsl_sf_gamma_inc_e"
.ie n .IP """gsl_sf_gamma_inc """ 4
.el .IP "\f(CWgsl_sf_gamma_inc \fR" 4
.IX Item "gsl_sf_gamma_inc "
.ie n .IP """gsl_sf_taylorcoeff_e""" 4
.el .IP "\f(CWgsl_sf_taylorcoeff_e\fR" 4
.IX Item "gsl_sf_taylorcoeff_e"
.ie n .IP """gsl_sf_taylorcoeff""" 4
.el .IP "\f(CWgsl_sf_taylorcoeff\fR" 4
.IX Item "gsl_sf_taylorcoeff"
.ie n .IP """gsl_sf_fact_e """ 4
.el .IP "\f(CWgsl_sf_fact_e \fR" 4
.IX Item "gsl_sf_fact_e "
.ie n .IP """gsl_sf_fact""" 4
.el .IP "\f(CWgsl_sf_fact\fR" 4
.IX Item "gsl_sf_fact"
.ie n .IP """gsl_sf_doublefact_e""" 4
.el .IP "\f(CWgsl_sf_doublefact_e\fR" 4
.IX Item "gsl_sf_doublefact_e"
.ie n .IP """gsl_sf_doublefact """ 4
.el .IP "\f(CWgsl_sf_doublefact \fR" 4
.IX Item "gsl_sf_doublefact "
.ie n .IP """gsl_sf_lnfact_e""" 4
.el .IP "\f(CWgsl_sf_lnfact_e\fR" 4
.IX Item "gsl_sf_lnfact_e"
.ie n .IP """gsl_sf_lnfact""" 4
.el .IP "\f(CWgsl_sf_lnfact\fR" 4
.IX Item "gsl_sf_lnfact"
.ie n .IP """gsl_sf_lndoublefact_e """ 4
.el .IP "\f(CWgsl_sf_lndoublefact_e \fR" 4
.IX Item "gsl_sf_lndoublefact_e "
.ie n .IP """gsl_sf_lndoublefact""" 4
.el .IP "\f(CWgsl_sf_lndoublefact\fR" 4
.IX Item "gsl_sf_lndoublefact"
.ie n .IP """gsl_sf_lnchoose_e""" 4
.el .IP "\f(CWgsl_sf_lnchoose_e\fR" 4
.IX Item "gsl_sf_lnchoose_e"
.ie n .IP """gsl_sf_lnchoose """ 4
.el .IP "\f(CWgsl_sf_lnchoose \fR" 4
.IX Item "gsl_sf_lnchoose "
.ie n .IP """gsl_sf_choose_e""" 4
.el .IP "\f(CWgsl_sf_choose_e\fR" 4
.IX Item "gsl_sf_choose_e"
.ie n .IP """gsl_sf_choose""" 4
.el .IP "\f(CWgsl_sf_choose\fR" 4
.IX Item "gsl_sf_choose"
.ie n .IP """gsl_sf_lnpoch_e """ 4
.el .IP "\f(CWgsl_sf_lnpoch_e \fR" 4
.IX Item "gsl_sf_lnpoch_e "
.ie n .IP """gsl_sf_lnpoch""" 4
.el .IP "\f(CWgsl_sf_lnpoch\fR" 4
.IX Item "gsl_sf_lnpoch"
.ie n .IP """gsl_sf_lnpoch_sgn_e""" 4
.el .IP "\f(CWgsl_sf_lnpoch_sgn_e\fR" 4
.IX Item "gsl_sf_lnpoch_sgn_e"
.ie n .IP """gsl_sf_poch_e """ 4
.el .IP "\f(CWgsl_sf_poch_e \fR" 4
.IX Item "gsl_sf_poch_e "
.ie n .IP """gsl_sf_poch""" 4
.el .IP "\f(CWgsl_sf_poch\fR" 4
.IX Item "gsl_sf_poch"
.ie n .IP """gsl_sf_pochrel_e""" 4
.el .IP "\f(CWgsl_sf_pochrel_e\fR" 4
.IX Item "gsl_sf_pochrel_e"
.ie n .IP """gsl_sf_pochrel """ 4
.el .IP "\f(CWgsl_sf_pochrel \fR" 4
.IX Item "gsl_sf_pochrel "
.ie n .IP """gsl_sf_lnbeta_e""" 4
.el .IP "\f(CWgsl_sf_lnbeta_e\fR" 4
.IX Item "gsl_sf_lnbeta_e"
.ie n .IP """gsl_sf_lnbeta""" 4
.el .IP "\f(CWgsl_sf_lnbeta\fR" 4
.IX Item "gsl_sf_lnbeta"
.ie n .IP """gsl_sf_lnbeta_sgn_e """ 4
.el .IP "\f(CWgsl_sf_lnbeta_sgn_e \fR" 4
.IX Item "gsl_sf_lnbeta_sgn_e "
.ie n .IP """gsl_sf_beta_e""" 4
.el .IP "\f(CWgsl_sf_beta_e\fR" 4
.IX Item "gsl_sf_beta_e"
.ie n .IP """gsl_sf_beta""" 4
.el .IP "\f(CWgsl_sf_beta\fR" 4
.IX Item "gsl_sf_beta"
.ie n .IP """gsl_sf_beta_inc_e """ 4
.el .IP "\f(CWgsl_sf_beta_inc_e \fR" 4
.IX Item "gsl_sf_beta_inc_e "
.ie n .IP """gsl_sf_beta_inc""" 4
.el .IP "\f(CWgsl_sf_beta_inc\fR" 4
.IX Item "gsl_sf_beta_inc"
.ie n .IP """gsl_sf_gegenpoly_1_e""" 4
.el .IP "\f(CWgsl_sf_gegenpoly_1_e\fR" 4
.IX Item "gsl_sf_gegenpoly_1_e"
.ie n .IP """gsl_sf_gegenpoly_2_e """ 4
.el .IP "\f(CWgsl_sf_gegenpoly_2_e \fR" 4
.IX Item "gsl_sf_gegenpoly_2_e "
.ie n .IP """gsl_sf_gegenpoly_3_e""" 4
.el .IP "\f(CWgsl_sf_gegenpoly_3_e\fR" 4
.IX Item "gsl_sf_gegenpoly_3_e"
.ie n .IP """gsl_sf_gegenpoly_1""" 4
.el .IP "\f(CWgsl_sf_gegenpoly_1\fR" 4
.IX Item "gsl_sf_gegenpoly_1"
.ie n .IP """gsl_sf_gegenpoly_2 """ 4
.el .IP "\f(CWgsl_sf_gegenpoly_2 \fR" 4
.IX Item "gsl_sf_gegenpoly_2 "
.ie n .IP """gsl_sf_gegenpoly_3""" 4
.el .IP "\f(CWgsl_sf_gegenpoly_3\fR" 4
.IX Item "gsl_sf_gegenpoly_3"
.ie n .IP """gsl_sf_gegenpoly_n_e""" 4
.el .IP "\f(CWgsl_sf_gegenpoly_n_e\fR" 4
.IX Item "gsl_sf_gegenpoly_n_e"
.ie n .IP """gsl_sf_gegenpoly_n """ 4
.el .IP "\f(CWgsl_sf_gegenpoly_n \fR" 4
.IX Item "gsl_sf_gegenpoly_n "
.ie n .IP """gsl_sf_gegenpoly_array""" 4
.el .IP "\f(CWgsl_sf_gegenpoly_array\fR" 4
.IX Item "gsl_sf_gegenpoly_array"
.ie n .IP """gsl_sf_hyperg_0F1_e""" 4
.el .IP "\f(CWgsl_sf_hyperg_0F1_e\fR" 4
.IX Item "gsl_sf_hyperg_0F1_e"
.ie n .IP """gsl_sf_hyperg_0F1 """ 4
.el .IP "\f(CWgsl_sf_hyperg_0F1 \fR" 4
.IX Item "gsl_sf_hyperg_0F1 "
.ie n .IP """gsl_sf_hyperg_1F1_int_e""" 4
.el .IP "\f(CWgsl_sf_hyperg_1F1_int_e\fR" 4
.IX Item "gsl_sf_hyperg_1F1_int_e"
.ie n .IP """gsl_sf_hyperg_1F1_int""" 4
.el .IP "\f(CWgsl_sf_hyperg_1F1_int\fR" 4
.IX Item "gsl_sf_hyperg_1F1_int"
.ie n .IP """gsl_sf_hyperg_1F1_e """ 4
.el .IP "\f(CWgsl_sf_hyperg_1F1_e \fR" 4
.IX Item "gsl_sf_hyperg_1F1_e "
.ie n .IP """gsl_sf_hyperg_1F1""" 4
.el .IP "\f(CWgsl_sf_hyperg_1F1\fR" 4
.IX Item "gsl_sf_hyperg_1F1"
.ie n .IP """gsl_sf_hyperg_U_int_e""" 4
.el .IP "\f(CWgsl_sf_hyperg_U_int_e\fR" 4
.IX Item "gsl_sf_hyperg_U_int_e"
.ie n .IP """gsl_sf_hyperg_U_int """ 4
.el .IP "\f(CWgsl_sf_hyperg_U_int \fR" 4
.IX Item "gsl_sf_hyperg_U_int "
.ie n .IP """gsl_sf_hyperg_U_int_e10_e""" 4
.el .IP "\f(CWgsl_sf_hyperg_U_int_e10_e\fR" 4
.IX Item "gsl_sf_hyperg_U_int_e10_e"
.ie n .IP """gsl_sf_hyperg_U_e""" 4
.el .IP "\f(CWgsl_sf_hyperg_U_e\fR" 4
.IX Item "gsl_sf_hyperg_U_e"
.ie n .IP """gsl_sf_hyperg_U """ 4
.el .IP "\f(CWgsl_sf_hyperg_U \fR" 4
.IX Item "gsl_sf_hyperg_U "
.ie n .IP """gsl_sf_hyperg_U_e10_e""" 4
.el .IP "\f(CWgsl_sf_hyperg_U_e10_e\fR" 4
.IX Item "gsl_sf_hyperg_U_e10_e"
.ie n .IP """gsl_sf_hyperg_2F1_e""" 4
.el .IP "\f(CWgsl_sf_hyperg_2F1_e\fR" 4
.IX Item "gsl_sf_hyperg_2F1_e"
.ie n .IP """gsl_sf_hyperg_2F1 """ 4
.el .IP "\f(CWgsl_sf_hyperg_2F1 \fR" 4
.IX Item "gsl_sf_hyperg_2F1 "
.ie n .IP """gsl_sf_hyperg_2F1_conj_e""" 4
.el .IP "\f(CWgsl_sf_hyperg_2F1_conj_e\fR" 4
.IX Item "gsl_sf_hyperg_2F1_conj_e"
.ie n .IP """gsl_sf_hyperg_2F1_conj""" 4
.el .IP "\f(CWgsl_sf_hyperg_2F1_conj\fR" 4
.IX Item "gsl_sf_hyperg_2F1_conj"
.ie n .IP """gsl_sf_hyperg_2F1_renorm_e """ 4
.el .IP "\f(CWgsl_sf_hyperg_2F1_renorm_e \fR" 4
.IX Item "gsl_sf_hyperg_2F1_renorm_e "
.ie n .IP """gsl_sf_hyperg_2F1_renorm""" 4
.el .IP "\f(CWgsl_sf_hyperg_2F1_renorm\fR" 4
.IX Item "gsl_sf_hyperg_2F1_renorm"
.ie n .IP """gsl_sf_hyperg_2F1_conj_renorm_e""" 4
.el .IP "\f(CWgsl_sf_hyperg_2F1_conj_renorm_e\fR" 4
.IX Item "gsl_sf_hyperg_2F1_conj_renorm_e"
.ie n .IP """gsl_sf_hyperg_2F1_conj_renorm """ 4
.el .IP "\f(CWgsl_sf_hyperg_2F1_conj_renorm \fR" 4
.IX Item "gsl_sf_hyperg_2F1_conj_renorm "
.ie n .IP """gsl_sf_hyperg_2F0_e""" 4
.el .IP "\f(CWgsl_sf_hyperg_2F0_e\fR" 4
.IX Item "gsl_sf_hyperg_2F0_e"
.ie n .IP """gsl_sf_hyperg_2F0""" 4
.el .IP "\f(CWgsl_sf_hyperg_2F0\fR" 4
.IX Item "gsl_sf_hyperg_2F0"
.ie n .IP """gsl_sf_laguerre_1_e """ 4
.el .IP "\f(CWgsl_sf_laguerre_1_e \fR" 4
.IX Item "gsl_sf_laguerre_1_e "
.ie n .IP """gsl_sf_laguerre_2_e""" 4
.el .IP "\f(CWgsl_sf_laguerre_2_e\fR" 4
.IX Item "gsl_sf_laguerre_2_e"
.ie n .IP """gsl_sf_laguerre_3_e""" 4
.el .IP "\f(CWgsl_sf_laguerre_3_e\fR" 4
.IX Item "gsl_sf_laguerre_3_e"
.ie n .IP """gsl_sf_laguerre_1 """ 4
.el .IP "\f(CWgsl_sf_laguerre_1 \fR" 4
.IX Item "gsl_sf_laguerre_1 "
.ie n .IP """gsl_sf_laguerre_2""" 4
.el .IP "\f(CWgsl_sf_laguerre_2\fR" 4
.IX Item "gsl_sf_laguerre_2"
.ie n .IP """gsl_sf_laguerre_3""" 4
.el .IP "\f(CWgsl_sf_laguerre_3\fR" 4
.IX Item "gsl_sf_laguerre_3"
.ie n .IP """gsl_sf_laguerre_n_e """ 4
.el .IP "\f(CWgsl_sf_laguerre_n_e \fR" 4
.IX Item "gsl_sf_laguerre_n_e "
.ie n .IP """gsl_sf_laguerre_n""" 4
.el .IP "\f(CWgsl_sf_laguerre_n\fR" 4
.IX Item "gsl_sf_laguerre_n"
.ie n .IP """gsl_sf_lambert_W0_e""" 4
.el .IP "\f(CWgsl_sf_lambert_W0_e\fR" 4
.IX Item "gsl_sf_lambert_W0_e"
.ie n .IP """gsl_sf_lambert_W0 """ 4
.el .IP "\f(CWgsl_sf_lambert_W0 \fR" 4
.IX Item "gsl_sf_lambert_W0 "
.ie n .IP """gsl_sf_lambert_Wm1_e""" 4
.el .IP "\f(CWgsl_sf_lambert_Wm1_e\fR" 4
.IX Item "gsl_sf_lambert_Wm1_e"
.ie n .IP """gsl_sf_lambert_Wm1""" 4
.el .IP "\f(CWgsl_sf_lambert_Wm1\fR" 4
.IX Item "gsl_sf_lambert_Wm1"
.ie n .IP """gsl_sf_conicalP_half_e """ 4
.el .IP "\f(CWgsl_sf_conicalP_half_e \fR" 4
.IX Item "gsl_sf_conicalP_half_e "
.ie n .IP """gsl_sf_conicalP_half""" 4
.el .IP "\f(CWgsl_sf_conicalP_half\fR" 4
.IX Item "gsl_sf_conicalP_half"
.ie n .IP """gsl_sf_conicalP_mhalf_e""" 4
.el .IP "\f(CWgsl_sf_conicalP_mhalf_e\fR" 4
.IX Item "gsl_sf_conicalP_mhalf_e"
.ie n .IP """gsl_sf_conicalP_mhalf """ 4
.el .IP "\f(CWgsl_sf_conicalP_mhalf \fR" 4
.IX Item "gsl_sf_conicalP_mhalf "
.ie n .IP """gsl_sf_conicalP_0_e""" 4
.el .IP "\f(CWgsl_sf_conicalP_0_e\fR" 4
.IX Item "gsl_sf_conicalP_0_e"
.ie n .IP """gsl_sf_conicalP_0""" 4
.el .IP "\f(CWgsl_sf_conicalP_0\fR" 4
.IX Item "gsl_sf_conicalP_0"
.ie n .IP """gsl_sf_conicalP_1_e """ 4
.el .IP "\f(CWgsl_sf_conicalP_1_e \fR" 4
.IX Item "gsl_sf_conicalP_1_e "
.ie n .IP """gsl_sf_conicalP_1""" 4
.el .IP "\f(CWgsl_sf_conicalP_1\fR" 4
.IX Item "gsl_sf_conicalP_1"
.ie n .IP """gsl_sf_conicalP_sph_reg_e""" 4
.el .IP "\f(CWgsl_sf_conicalP_sph_reg_e\fR" 4
.IX Item "gsl_sf_conicalP_sph_reg_e"
.ie n .IP """gsl_sf_conicalP_sph_reg """ 4
.el .IP "\f(CWgsl_sf_conicalP_sph_reg \fR" 4
.IX Item "gsl_sf_conicalP_sph_reg "
.ie n .IP """gsl_sf_conicalP_cyl_reg_e""" 4
.el .IP "\f(CWgsl_sf_conicalP_cyl_reg_e\fR" 4
.IX Item "gsl_sf_conicalP_cyl_reg_e"
.ie n .IP """gsl_sf_conicalP_cyl_reg""" 4
.el .IP "\f(CWgsl_sf_conicalP_cyl_reg\fR" 4
.IX Item "gsl_sf_conicalP_cyl_reg"
.ie n .IP """gsl_sf_legendre_H3d_0_e """ 4
.el .IP "\f(CWgsl_sf_legendre_H3d_0_e \fR" 4
.IX Item "gsl_sf_legendre_H3d_0_e "
.ie n .IP """gsl_sf_legendre_H3d_0""" 4
.el .IP "\f(CWgsl_sf_legendre_H3d_0\fR" 4
.IX Item "gsl_sf_legendre_H3d_0"
.ie n .IP """gsl_sf_legendre_H3d_1_e""" 4
.el .IP "\f(CWgsl_sf_legendre_H3d_1_e\fR" 4
.IX Item "gsl_sf_legendre_H3d_1_e"
.ie n .IP """gsl_sf_legendre_H3d_1 """ 4
.el .IP "\f(CWgsl_sf_legendre_H3d_1 \fR" 4
.IX Item "gsl_sf_legendre_H3d_1 "
.ie n .IP """gsl_sf_legendre_H3d_e""" 4
.el .IP "\f(CWgsl_sf_legendre_H3d_e\fR" 4
.IX Item "gsl_sf_legendre_H3d_e"
.ie n .IP """gsl_sf_legendre_H3d""" 4
.el .IP "\f(CWgsl_sf_legendre_H3d\fR" 4
.IX Item "gsl_sf_legendre_H3d"
.ie n .IP """gsl_sf_legendre_H3d_array """ 4
.el .IP "\f(CWgsl_sf_legendre_H3d_array \fR" 4
.IX Item "gsl_sf_legendre_H3d_array "
.ie n .IP """gsl_sf_log_e""" 4
.el .IP "\f(CWgsl_sf_log_e\fR" 4
.IX Item "gsl_sf_log_e"
.ie n .IP """gsl_sf_log""" 4
.el .IP "\f(CWgsl_sf_log\fR" 4
.IX Item "gsl_sf_log"
.ie n .IP """gsl_sf_log_abs_e """ 4
.el .IP "\f(CWgsl_sf_log_abs_e \fR" 4
.IX Item "gsl_sf_log_abs_e "
.ie n .IP """gsl_sf_log_abs""" 4
.el .IP "\f(CWgsl_sf_log_abs\fR" 4
.IX Item "gsl_sf_log_abs"
.ie n .IP """gsl_sf_complex_log_e""" 4
.el .IP "\f(CWgsl_sf_complex_log_e\fR" 4
.IX Item "gsl_sf_complex_log_e"
.ie n .IP """gsl_sf_log_1plusx_e """ 4
.el .IP "\f(CWgsl_sf_log_1plusx_e \fR" 4
.IX Item "gsl_sf_log_1plusx_e "
.ie n .IP """gsl_sf_log_1plusx""" 4
.el .IP "\f(CWgsl_sf_log_1plusx\fR" 4
.IX Item "gsl_sf_log_1plusx"
.ie n .IP """gsl_sf_log_1plusx_mx_e""" 4
.el .IP "\f(CWgsl_sf_log_1plusx_mx_e\fR" 4
.IX Item "gsl_sf_log_1plusx_mx_e"
.ie n .IP """gsl_sf_log_1plusx_mx """ 4
.el .IP "\f(CWgsl_sf_log_1plusx_mx \fR" 4
.IX Item "gsl_sf_log_1plusx_mx "
.ie n .IP """gsl_sf_mathieu_a_array""" 4
.el .IP "\f(CWgsl_sf_mathieu_a_array\fR" 4
.IX Item "gsl_sf_mathieu_a_array"
.ie n .IP """gsl_sf_mathieu_b_array""" 4
.el .IP "\f(CWgsl_sf_mathieu_b_array\fR" 4
.IX Item "gsl_sf_mathieu_b_array"
.ie n .IP """gsl_sf_mathieu_a """ 4
.el .IP "\f(CWgsl_sf_mathieu_a \fR" 4
.IX Item "gsl_sf_mathieu_a "
.ie n .IP """gsl_sf_mathieu_b""" 4
.el .IP "\f(CWgsl_sf_mathieu_b\fR" 4
.IX Item "gsl_sf_mathieu_b"
.ie n .IP """gsl_sf_mathieu_a_coeff""" 4
.el .IP "\f(CWgsl_sf_mathieu_a_coeff\fR" 4
.IX Item "gsl_sf_mathieu_a_coeff"
.ie n .IP """gsl_sf_mathieu_b_coeff """ 4
.el .IP "\f(CWgsl_sf_mathieu_b_coeff \fR" 4
.IX Item "gsl_sf_mathieu_b_coeff "
.ie n .IP """gsl_sf_mathieu_alloc""" 4
.el .IP "\f(CWgsl_sf_mathieu_alloc\fR" 4
.IX Item "gsl_sf_mathieu_alloc"
.ie n .IP """gsl_sf_mathieu_free""" 4
.el .IP "\f(CWgsl_sf_mathieu_free\fR" 4
.IX Item "gsl_sf_mathieu_free"
.ie n .IP """gsl_sf_mathieu_ce """ 4
.el .IP "\f(CWgsl_sf_mathieu_ce \fR" 4
.IX Item "gsl_sf_mathieu_ce "
.ie n .IP """gsl_sf_mathieu_se""" 4
.el .IP "\f(CWgsl_sf_mathieu_se\fR" 4
.IX Item "gsl_sf_mathieu_se"
.ie n .IP """gsl_sf_mathieu_ce_array""" 4
.el .IP "\f(CWgsl_sf_mathieu_ce_array\fR" 4
.IX Item "gsl_sf_mathieu_ce_array"
.ie n .IP """gsl_sf_mathieu_se_array """ 4
.el .IP "\f(CWgsl_sf_mathieu_se_array \fR" 4
.IX Item "gsl_sf_mathieu_se_array "
.ie n .IP """gsl_sf_mathieu_Mc""" 4
.el .IP "\f(CWgsl_sf_mathieu_Mc\fR" 4
.IX Item "gsl_sf_mathieu_Mc"
.ie n .IP """gsl_sf_mathieu_Ms""" 4
.el .IP "\f(CWgsl_sf_mathieu_Ms\fR" 4
.IX Item "gsl_sf_mathieu_Ms"
.ie n .IP """gsl_sf_mathieu_Mc_array """ 4
.el .IP "\f(CWgsl_sf_mathieu_Mc_array \fR" 4
.IX Item "gsl_sf_mathieu_Mc_array "
.ie n .IP """gsl_sf_mathieu_Ms_array""" 4
.el .IP "\f(CWgsl_sf_mathieu_Ms_array\fR" 4
.IX Item "gsl_sf_mathieu_Ms_array"
.ie n .IP """gsl_sf_pow_int_e""" 4
.el .IP "\f(CWgsl_sf_pow_int_e\fR" 4
.IX Item "gsl_sf_pow_int_e"
.ie n .IP """gsl_sf_pow_int """ 4
.el .IP "\f(CWgsl_sf_pow_int \fR" 4
.IX Item "gsl_sf_pow_int "
.ie n .IP """gsl_sf_psi_int_e""" 4
.el .IP "\f(CWgsl_sf_psi_int_e\fR" 4
.IX Item "gsl_sf_psi_int_e"
.ie n .IP """gsl_sf_psi_int""" 4
.el .IP "\f(CWgsl_sf_psi_int\fR" 4
.IX Item "gsl_sf_psi_int"
.ie n .IP """gsl_sf_psi_e """ 4
.el .IP "\f(CWgsl_sf_psi_e \fR" 4
.IX Item "gsl_sf_psi_e "
.ie n .IP """gsl_sf_psi""" 4
.el .IP "\f(CWgsl_sf_psi\fR" 4
.IX Item "gsl_sf_psi"
.ie n .IP """gsl_sf_psi_1piy_e""" 4
.el .IP "\f(CWgsl_sf_psi_1piy_e\fR" 4
.IX Item "gsl_sf_psi_1piy_e"
.ie n .IP """gsl_sf_psi_1piy """ 4
.el .IP "\f(CWgsl_sf_psi_1piy \fR" 4
.IX Item "gsl_sf_psi_1piy "
.ie n .IP """gsl_sf_complex_psi_e""" 4
.el .IP "\f(CWgsl_sf_complex_psi_e\fR" 4
.IX Item "gsl_sf_complex_psi_e"
.ie n .IP """gsl_sf_psi_1_int_e""" 4
.el .IP "\f(CWgsl_sf_psi_1_int_e\fR" 4
.IX Item "gsl_sf_psi_1_int_e"
.ie n .IP """gsl_sf_psi_1_int """ 4
.el .IP "\f(CWgsl_sf_psi_1_int \fR" 4
.IX Item "gsl_sf_psi_1_int "
.ie n .IP """gsl_sf_psi_1_e """ 4
.el .IP "\f(CWgsl_sf_psi_1_e \fR" 4
.IX Item "gsl_sf_psi_1_e "
.ie n .IP """gsl_sf_psi_1""" 4
.el .IP "\f(CWgsl_sf_psi_1\fR" 4
.IX Item "gsl_sf_psi_1"
.ie n .IP """gsl_sf_psi_n_e """ 4
.el .IP "\f(CWgsl_sf_psi_n_e \fR" 4
.IX Item "gsl_sf_psi_n_e "
.ie n .IP """gsl_sf_psi_n""" 4
.el .IP "\f(CWgsl_sf_psi_n\fR" 4
.IX Item "gsl_sf_psi_n"
.ie n .IP """gsl_sf_result_smash_e""" 4
.el .IP "\f(CWgsl_sf_result_smash_e\fR" 4
.IX Item "gsl_sf_result_smash_e"
.ie n .IP """gsl_sf_synchrotron_1_e """ 4
.el .IP "\f(CWgsl_sf_synchrotron_1_e \fR" 4
.IX Item "gsl_sf_synchrotron_1_e "
.ie n .IP """gsl_sf_synchrotron_1""" 4
.el .IP "\f(CWgsl_sf_synchrotron_1\fR" 4
.IX Item "gsl_sf_synchrotron_1"
.ie n .IP """gsl_sf_synchrotron_2_e""" 4
.el .IP "\f(CWgsl_sf_synchrotron_2_e\fR" 4
.IX Item "gsl_sf_synchrotron_2_e"
.ie n .IP """gsl_sf_synchrotron_2 """ 4
.el .IP "\f(CWgsl_sf_synchrotron_2 \fR" 4
.IX Item "gsl_sf_synchrotron_2 "
.ie n .IP """gsl_sf_transport_2_e""" 4
.el .IP "\f(CWgsl_sf_transport_2_e\fR" 4
.IX Item "gsl_sf_transport_2_e"
.ie n .IP """gsl_sf_transport_2""" 4
.el .IP "\f(CWgsl_sf_transport_2\fR" 4
.IX Item "gsl_sf_transport_2"
.ie n .IP """gsl_sf_transport_3_e """ 4
.el .IP "\f(CWgsl_sf_transport_3_e \fR" 4
.IX Item "gsl_sf_transport_3_e "
.ie n .IP """gsl_sf_transport_3""" 4
.el .IP "\f(CWgsl_sf_transport_3\fR" 4
.IX Item "gsl_sf_transport_3"
.ie n .IP """gsl_sf_transport_4_e""" 4
.el .IP "\f(CWgsl_sf_transport_4_e\fR" 4
.IX Item "gsl_sf_transport_4_e"
.ie n .IP """gsl_sf_transport_4 """ 4
.el .IP "\f(CWgsl_sf_transport_4 \fR" 4
.IX Item "gsl_sf_transport_4 "
.ie n .IP """gsl_sf_transport_5_e""" 4
.el .IP "\f(CWgsl_sf_transport_5_e\fR" 4
.IX Item "gsl_sf_transport_5_e"
.ie n .IP """gsl_sf_transport_5""" 4
.el .IP "\f(CWgsl_sf_transport_5\fR" 4
.IX Item "gsl_sf_transport_5"
.ie n .IP """gsl_sf_sin_e """ 4
.el .IP "\f(CWgsl_sf_sin_e \fR" 4
.IX Item "gsl_sf_sin_e "
.ie n .IP """gsl_sf_sin""" 4
.el .IP "\f(CWgsl_sf_sin\fR" 4
.IX Item "gsl_sf_sin"
.ie n .IP """gsl_sf_cos_e""" 4
.el .IP "\f(CWgsl_sf_cos_e\fR" 4
.IX Item "gsl_sf_cos_e"
.ie n .IP """gsl_sf_cos """ 4
.el .IP "\f(CWgsl_sf_cos \fR" 4
.IX Item "gsl_sf_cos "
.ie n .IP """gsl_sf_hypot_e""" 4
.el .IP "\f(CWgsl_sf_hypot_e\fR" 4
.IX Item "gsl_sf_hypot_e"
.ie n .IP """gsl_sf_hypot""" 4
.el .IP "\f(CWgsl_sf_hypot\fR" 4
.IX Item "gsl_sf_hypot"
.ie n .IP """gsl_sf_complex_sin_e """ 4
.el .IP "\f(CWgsl_sf_complex_sin_e \fR" 4
.IX Item "gsl_sf_complex_sin_e "
.ie n .IP """gsl_sf_complex_cos_e""" 4
.el .IP "\f(CWgsl_sf_complex_cos_e\fR" 4
.IX Item "gsl_sf_complex_cos_e"
.ie n .IP """gsl_sf_complex_logsin_e""" 4
.el .IP "\f(CWgsl_sf_complex_logsin_e\fR" 4
.IX Item "gsl_sf_complex_logsin_e"
.ie n .IP """gsl_sf_sinc_e """ 4
.el .IP "\f(CWgsl_sf_sinc_e \fR" 4
.IX Item "gsl_sf_sinc_e "
.ie n .IP """gsl_sf_sinc""" 4
.el .IP "\f(CWgsl_sf_sinc\fR" 4
.IX Item "gsl_sf_sinc"
.ie n .IP """gsl_sf_lnsinh_e""" 4
.el .IP "\f(CWgsl_sf_lnsinh_e\fR" 4
.IX Item "gsl_sf_lnsinh_e"
.ie n .IP """gsl_sf_lnsinh """ 4
.el .IP "\f(CWgsl_sf_lnsinh \fR" 4
.IX Item "gsl_sf_lnsinh "
.ie n .IP """gsl_sf_lncosh_e""" 4
.el .IP "\f(CWgsl_sf_lncosh_e\fR" 4
.IX Item "gsl_sf_lncosh_e"
.ie n .IP """gsl_sf_lncosh""" 4
.el .IP "\f(CWgsl_sf_lncosh\fR" 4
.IX Item "gsl_sf_lncosh"
.ie n .IP """gsl_sf_polar_to_rect """ 4
.el .IP "\f(CWgsl_sf_polar_to_rect \fR" 4
.IX Item "gsl_sf_polar_to_rect "
.ie n .IP """gsl_sf_rect_to_polar""" 4
.el .IP "\f(CWgsl_sf_rect_to_polar\fR" 4
.IX Item "gsl_sf_rect_to_polar"
.ie n .IP """gsl_sf_sin_err_e""" 4
.el .IP "\f(CWgsl_sf_sin_err_e\fR" 4
.IX Item "gsl_sf_sin_err_e"
.ie n .IP """gsl_sf_cos_err_e """ 4
.el .IP "\f(CWgsl_sf_cos_err_e \fR" 4
.IX Item "gsl_sf_cos_err_e "
.ie n .IP """gsl_sf_angle_restrict_symm_e""" 4
.el .IP "\f(CWgsl_sf_angle_restrict_symm_e\fR" 4
.IX Item "gsl_sf_angle_restrict_symm_e"
.ie n .IP """gsl_sf_angle_restrict_symm""" 4
.el .IP "\f(CWgsl_sf_angle_restrict_symm\fR" 4
.IX Item "gsl_sf_angle_restrict_symm"
.ie n .IP """gsl_sf_angle_restrict_pos_e """ 4
.el .IP "\f(CWgsl_sf_angle_restrict_pos_e \fR" 4
.IX Item "gsl_sf_angle_restrict_pos_e "
.ie n .IP """gsl_sf_angle_restrict_pos""" 4
.el .IP "\f(CWgsl_sf_angle_restrict_pos\fR" 4
.IX Item "gsl_sf_angle_restrict_pos"
.ie n .IP """gsl_sf_angle_restrict_symm_err_e""" 4
.el .IP "\f(CWgsl_sf_angle_restrict_symm_err_e\fR" 4
.IX Item "gsl_sf_angle_restrict_symm_err_e"
.ie n .IP """gsl_sf_angle_restrict_pos_err_e """ 4
.el .IP "\f(CWgsl_sf_angle_restrict_pos_err_e \fR" 4
.IX Item "gsl_sf_angle_restrict_pos_err_e "
.RS 4
.ie n .IP """gsl_sf_atanint_e""" 4
.el .IP "\f(CWgsl_sf_atanint_e\fR" 4
.IX Item "gsl_sf_atanint_e"
.ie n .IP """gsl_sf_atanint""" 4
.el .IP "\f(CWgsl_sf_atanint\fR" 4
.IX Item "gsl_sf_atanint"
.PD
These routines compute the Arctangent integral, which is defined as AtanInt(x) = \eint_0^x dt \earctan(t)/t.
.RE
.RS 4
.RE
.ie n .IP """gsl_sf_zeta_int_e """ 4
.el .IP "\f(CWgsl_sf_zeta_int_e \fR" 4
.IX Item "gsl_sf_zeta_int_e "
.PD 0
.ie n .IP """gsl_sf_zeta_int""" 4
.el .IP "\f(CWgsl_sf_zeta_int\fR" 4
.IX Item "gsl_sf_zeta_int"
.ie n .IP """gsl_sf_zeta_e gsl_sf_zeta """ 4
.el .IP "\f(CWgsl_sf_zeta_e gsl_sf_zeta \fR" 4
.IX Item "gsl_sf_zeta_e gsl_sf_zeta "
.ie n .IP """gsl_sf_zetam1_e""" 4
.el .IP "\f(CWgsl_sf_zetam1_e\fR" 4
.IX Item "gsl_sf_zetam1_e"
.ie n .IP """gsl_sf_zetam1""" 4
.el .IP "\f(CWgsl_sf_zetam1\fR" 4
.IX Item "gsl_sf_zetam1"
.ie n .IP """gsl_sf_zetam1_int_e """ 4
.el .IP "\f(CWgsl_sf_zetam1_int_e \fR" 4
.IX Item "gsl_sf_zetam1_int_e "
.ie n .IP """gsl_sf_zetam1_int""" 4
.el .IP "\f(CWgsl_sf_zetam1_int\fR" 4
.IX Item "gsl_sf_zetam1_int"
.ie n .IP """gsl_sf_hzeta_e""" 4
.el .IP "\f(CWgsl_sf_hzeta_e\fR" 4
.IX Item "gsl_sf_hzeta_e"
.ie n .IP """gsl_sf_hzeta """ 4
.el .IP "\f(CWgsl_sf_hzeta \fR" 4
.IX Item "gsl_sf_hzeta "
.ie n .IP """gsl_sf_eta_int_e""" 4
.el .IP "\f(CWgsl_sf_eta_int_e\fR" 4
.IX Item "gsl_sf_eta_int_e"
.ie n .IP """gsl_sf_eta_int""" 4
.el .IP "\f(CWgsl_sf_eta_int\fR" 4
.IX Item "gsl_sf_eta_int"
.ie n .IP """gsl_sf_eta_e""" 4
.el .IP "\f(CWgsl_sf_eta_e\fR" 4
.IX Item "gsl_sf_eta_e"
.ie n .IP """gsl_sf_eta """ 4
.el .IP "\f(CWgsl_sf_eta \fR" 4
.IX Item "gsl_sf_eta "
.PD
.PP
This module also contains the following constants used as mode in various of those functions :
.IP "\(bu" 4
\&\s-1GSL_PREC_DOUBLE\s0 \- Double-precision, a relative accuracy of approximately 2 * 10^\-16.
.IP "\(bu" 4
\&\s-1GSL_PREC_SINGLE\s0 \- Single-precision, a relative accuracy of approximately 10^\-7.
.IP "\(bu" 4
\&\s-1GSL_PREC_APPROX\s0 \- Approximate values, a relative accuracy of approximately 5 * 10^\-4.
.PP
.Vb 6
\& You can import the functions that you want to use by giving a space separated
\& list to Math::GSL::SF when you use the package.  You can also write 
\& use Math::GSL::SF qw/:all/ 
\& to use all avaible functions of the module. Note that
\& the tag names begin with a colon.  Other tags are also available, here is a
\& complete list of all tags for this module :
.Ve
.ie n .IP """airy""" 4
.el .IP "\f(CWairy\fR" 4
.IX Item "airy"
.PD 0
.ie n .IP """bessel""" 4
.el .IP "\f(CWbessel\fR" 4
.IX Item "bessel"
.ie n .IP """clausen""" 4
.el .IP "\f(CWclausen\fR" 4
.IX Item "clausen"
.ie n .IP """hydrogenic""" 4
.el .IP "\f(CWhydrogenic\fR" 4
.IX Item "hydrogenic"
.ie n .IP """coulumb""" 4
.el .IP "\f(CWcoulumb\fR" 4
.IX Item "coulumb"
.ie n .IP """coupling""" 4
.el .IP "\f(CWcoupling\fR" 4
.IX Item "coupling"
.ie n .IP """dawson""" 4
.el .IP "\f(CWdawson\fR" 4
.IX Item "dawson"
.ie n .IP """debye""" 4
.el .IP "\f(CWdebye\fR" 4
.IX Item "debye"
.ie n .IP """dilog""" 4
.el .IP "\f(CWdilog\fR" 4
.IX Item "dilog"
.ie n .IP """factorial""" 4
.el .IP "\f(CWfactorial\fR" 4
.IX Item "factorial"
.ie n .IP """misc""" 4
.el .IP "\f(CWmisc\fR" 4
.IX Item "misc"
.ie n .IP """elliptic""" 4
.el .IP "\f(CWelliptic\fR" 4
.IX Item "elliptic"
.ie n .IP """error""" 4
.el .IP "\f(CWerror\fR" 4
.IX Item "error"
.ie n .IP """hypergeometric""" 4
.el .IP "\f(CWhypergeometric\fR" 4
.IX Item "hypergeometric"
.ie n .IP """laguerre""" 4
.el .IP "\f(CWlaguerre\fR" 4
.IX Item "laguerre"
.ie n .IP """legendre""" 4
.el .IP "\f(CWlegendre\fR" 4
.IX Item "legendre"
.ie n .IP """gamma""" 4
.el .IP "\f(CWgamma\fR" 4
.IX Item "gamma"
.ie n .IP """transport""" 4
.el .IP "\f(CWtransport\fR" 4
.IX Item "transport"
.ie n .IP """trig""" 4
.el .IP "\f(CWtrig\fR" 4
.IX Item "trig"
.ie n .IP """zeta""" 4
.el .IP "\f(CWzeta\fR" 4
.IX Item "zeta"
.ie n .IP """eta""" 4
.el .IP "\f(CWeta\fR" 4
.IX Item "eta"
.ie n .IP """vars""" 4
.el .IP "\f(CWvars\fR" 4
.IX Item "vars"
.PD
.PP
For more informations on the functions, we refer you to the \s-1GSL\s0 offcial
documentation: <http://www.gnu.org/software/gsl/manual/html_node/>
.SH "EXAMPLES"
.IX Header "EXAMPLES"
This example computes the dilogarithm of 1/10 :
.PP
.Vb 3
\&    use Math::GSL::SF qw/dilog/;
\&    my $x = gsl_sf_dilog(0.1);
\&    print "gsl_sf_dilog(0.1) = $x\en";
.Ve
.PP
An example using Math::GSL::SF and gnuplot is in the \fBexamples/sf\fR folder of the source code.
.SH "AUTHORS"
.IX Header "AUTHORS"
Jonathan \*(L"Duke\*(R" Leto <jonathan@leto.net> and Thierry Moisan <thierry.moisan@gmail.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2008\-2011 Jonathan \*(L"Duke\*(R" Leto and Thierry Moisan
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
