.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Math::GSL::Sum 3pm"
.TH Math::GSL::Sum 3pm "2012-08-21" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::GSL::Sum \- Sum series with the Levin u\-transform
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Math::GSL::Sum qw/:all/;
\&
\&    my $w = gsl_sum_levin_u_alloc(5);
\&    $values = [8,2,3,4,6];
\&    my ($status, $sum_accel, $abserr) = gsl_sum_levin_u_accel($values, 5, $w); 
\&    gsl_sum_levin_u_free($w);
\&
\&    my $w2 = gsl_sum_levin_utrunc_alloc(5);
\&    my ($status2, $sum_accel2, $abserr_trunc) = gsl_sum_levin_utrunc_accel($values, 5, $w2);
\&    gsl_sum_levin_utrunc_free($w);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
These functions accelerate the convergence of a series using the Levin u\-transform.
.IP "\(bu" 4
gsl_sum_levin_u_alloc($n)
.Sp
This function allocates a workspace for a Levin u\-transform of \f(CW$n\fR terms.
.IP "\(bu" 4
gsl_sum_levin_u_free($w)
.Sp
\&\- This function frees the memory associated with the workspace \f(CW$w\fR.
.IP "\(bu" 4
gsl_sum_levin_u_accel($array, \f(CW$array_size\fR, \f(CW$w\fR)
.Sp
This function takes the terms of a series in the array reference \f(CW$array\fR of size
\&\f(CW$array_size\fR and computes the extrapolated limit of the series using a Levin
u\-transform. Additional working space must be provided in \f(CW$w\fR. The function
returns multiple values in this order : 0 if the operation succeeded, 1
otherwise, the extrapolated sum and an estimate of the absolute error. The
actual term-by-term sum is returned in \f(CW$w\fR\->{sum_plain}. The algorithm
calculates the truncation error (the difference between two successive
extrapolations) and round-off error (propagated from the individual terms) to
choose an optimal number of terms for the extrapolation. All the terms of the
series passed in through array should be non-zero.
.IP "\(bu" 4
gsl_sum_levin_u_minmax
.IP "\(bu" 4
gsl_sum_levin_u_step
.IP "\(bu" 4
gsl_sum_levin_utrunc_alloc($n)
.Sp
This function allocates a workspace for a Levin u\-transform of \f(CW$n\fR terms,
without error estimation.
.IP "\(bu" 4
gsl_sum_levin_utrunc_free($w)
.Sp
This function frees the memory associated with the workspace \f(CW$w\fR.
.IP "\(bu" 4
gsl_sum_levin_utrunc_accel($array, \f(CW$array_size\fR, \f(CW$w\fR)
.Sp
This function takes the terms of a series in the array reference \f(CW$array\fR of size
\&\f(CW$array_size\fR and computes the extrapolated limit of the series using a Levin
u\-transform. Additional working space must be provided in \f(CW$w\fR. The function
returns multiple values in this order : 0 if the operation succeeded, 1
otherwise, the extrapolated sum and an estimate of the error. The actual
term-by-term sum is returned in \f(CW$w\fR\->{sum_plain}. The algorithm terminates when
the difference between two successive extrapolations reaches a minimum or is
sufficiently small. To improve the reliability of the algorithm the
extrapolated values are replaced by moving averages when calculating the
truncation error, smoothing out any fluctuations.
.IP "\(bu" 4
gsl_sum_levin_utrunc_minmax
.IP "\(bu" 4
gsl_sum_levin_utrunc_step
.SH "AUTHORS"
.IX Header "AUTHORS"
Jonathan \*(L"Duke\*(R" Leto <jonathan@leto.net> and Thierry Moisan <thierry.moisan@gmail.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2008\-2011 Jonathan \*(L"Duke\*(R" Leto and Thierry Moisan
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
