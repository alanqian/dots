.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Math::GSL::RNG 3pm"
.TH Math::GSL::RNG 3pm "2012-08-21" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::GSL::RNG \- Random Number Generators
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    use Math::GSL::RNG;
\&    my $rng     = Math::GSL::RNG\->new;
\&    my @random  = $rng\->get(100);
.Ve
.ie n .SS "Math::GSL::RNG\->new($type, $seed)"
.el .SS "Math::GSL::RNG\->new($type, \f(CW$seed\fP)"
.IX Subsection "Math::GSL::RNG->new($type, $seed)"
.Vb 2
\&    my $rng = Math::GSL::RNG\->new;
\&    my $rng = Math::GSL::RNG\->new($gsl_rng_knuthran,5);
.Ve
.PP
Creates a new \s-1RNG\s0 object of type \f(CW$type\fR, seeded with \f(CW$seed\fR. Both of these
parameters are optional. The type \f(CW$gsl_rng_default\fR is used when no \f(CW$type\fR
is given.
.SS "\fIcopy()\fP"
.IX Subsection "copy()"
.Vb 1
\&    my $copy = $rng\->copy;
.Ve
.PP
Make a copy of a \s-1RNG\s0 object.
.SS "\fIfree()\fP"
.IX Subsection "free()"
.Vb 1
\&    $rng\->free();
.Ve
.PP
Free memory associated with \s-1RNG\s0 object.
.SS "\fIname()\fP"
.IX Subsection "name()"
.Vb 1
\&   my $name = $rng\->name();
.Ve
.PP
Get the name of the \s-1RNG\s0 object as a string.
.SS "\fIget()\fP"
.IX Subsection "get()"
.Vb 2
\&    my $nextval  = $rng\->get;
\&    my (@values) = $rng\->get(100);
.Ve
.PP
Get the next random value from the \s-1RNG\s0 object. If given an integer N, returns the next N values.
.SS "\fIraw()\fP"
.IX Subsection "raw()"
.Vb 1
\&    my $raw = $rng\->raw();
.Ve
.PP
Return the raw \s-1GSL\s0 \s-1RNG\s0 object, useful for functions which take a \s-1RNG\s0, such as the Monte Carlo integration functions or the random number distribution functions in Math::GSL::Randist.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.ie n .IP "gsl_rng_alloc($T) \- This function returns a pointer to a newly-created instance of a random number generator of type $T. $T must be one of the constants below. The generator is automatically initialized with the default seed, $gsl_rng_default." 1
.el .IP "gsl_rng_alloc($T) \- This function returns a pointer to a newly-created instance of a random number generator of type \f(CW$T\fR. \f(CW$T\fR must be one of the constants below. The generator is automatically initialized with the default seed, \f(CW$gsl_rng_default\fR." 1
.IX Item "gsl_rng_alloc($T) - This function returns a pointer to a newly-created instance of a random number generator of type $T. $T must be one of the constants below. The generator is automatically initialized with the default seed, $gsl_rng_default."
.PD 0
.ie n .IP "gsl_rng_set($r, $s) \- This function initializes (or `seeds') the random number generator. If the generator is seeded with the same value of $s on two different runs, the same stream of random numbers will be generated by successive calls to the routines below. If different values of $s are supplied, then the generated streams of random numbers should be completely different. If the seed $s is zero then the standard seed from the original implementation is used instead. For example, the original Fortran source code for the ranlux generator used a seed of 314159265, and so choosing $s equal to zero reproduces this when using $gsl_rng_ranlux." 1
.el .IP "gsl_rng_set($r, \f(CW$s\fR) \- This function initializes (or `seeds') the random number generator. If the generator is seeded with the same value of \f(CW$s\fR on two different runs, the same stream of random numbers will be generated by successive calls to the routines below. If different values of \f(CW$s\fR are supplied, then the generated streams of random numbers should be completely different. If the seed \f(CW$s\fR is zero then the standard seed from the original implementation is used instead. For example, the original Fortran source code for the ranlux generator used a seed of 314159265, and so choosing \f(CW$s\fR equal to zero reproduces this when using \f(CW$gsl_rng_ranlux\fR." 1
.IX Item "gsl_rng_set($r, $s) - This function initializes (or `seeds') the random number generator. If the generator is seeded with the same value of $s on two different runs, the same stream of random numbers will be generated by successive calls to the routines below. If different values of $s are supplied, then the generated streams of random numbers should be completely different. If the seed $s is zero then the standard seed from the original implementation is used instead. For example, the original Fortran source code for the ranlux generator used a seed of 314159265, and so choosing $s equal to zero reproduces this when using $gsl_rng_ranlux."
.ie n .IP "gsl_rng_get($r) \- This function returns a random integer from the generator $r. The minimum and maximum values depend on the algorithm used, but all integers in the range [min,max] are equally likely. The values of min and max can determined using the auxiliary functions gsl_rng_max($r) and gsl_rng_min($r)." 1
.el .IP "gsl_rng_get($r) \- This function returns a random integer from the generator \f(CW$r\fR. The minimum and maximum values depend on the algorithm used, but all integers in the range [min,max] are equally likely. The values of min and max can determined using the auxiliary functions gsl_rng_max($r) and gsl_rng_min($r)." 1
.IX Item "gsl_rng_get($r) - This function returns a random integer from the generator $r. The minimum and maximum values depend on the algorithm used, but all integers in the range [min,max] are equally likely. The values of min and max can determined using the auxiliary functions gsl_rng_max($r) and gsl_rng_min($r)."
.ie n .IP "gsl_rng_free($r) \- This function frees all the memory associated with the generator $r." 1
.el .IP "gsl_rng_free($r) \- This function frees all the memory associated with the generator \f(CW$r\fR." 1
.IX Item "gsl_rng_free($r) - This function frees all the memory associated with the generator $r."
.ie n .IP "gsl_rng_memcpy($dest, $src) \- This function copies the random number generator $src into the pre-existing generator $dest, making $dest into an exact copy of $src. The two generators must be of the same type." 1
.el .IP "gsl_rng_memcpy($dest, \f(CW$src\fR) \- This function copies the random number generator \f(CW$src\fR into the pre-existing generator \f(CW$dest\fR, making \f(CW$dest\fR into an exact copy of \f(CW$src\fR. The two generators must be of the same type." 1
.IX Item "gsl_rng_memcpy($dest, $src) - This function copies the random number generator $src into the pre-existing generator $dest, making $dest into an exact copy of $src. The two generators must be of the same type."
.IP "gsl_rng_uniform($r) \- This function returns a double precision floating point number uniformly distributed in the range [0,1). The range includes 0.0 but excludes 1.0. The value is typically obtained by dividing the result of gsl_rng_get($r) by gsl_rng_max($r) + 1.0 in double precision. Some generators compute this ratio internally so that they can provide floating point numbers with more than 32 bits of randomness (the maximum number of bits that can be portably represented in a single unsigned long int)." 1
.IX Item "gsl_rng_uniform($r) - This function returns a double precision floating point number uniformly distributed in the range [0,1). The range includes 0.0 but excludes 1.0. The value is typically obtained by dividing the result of gsl_rng_get($r) by gsl_rng_max($r) + 1.0 in double precision. Some generators compute this ratio internally so that they can provide floating point numbers with more than 32 bits of randomness (the maximum number of bits that can be portably represented in a single unsigned long int)."
.IP "gsl_rng_uniform_pos($r) \- This function returns a positive double precision floating point number uniformly distributed in the range (0,1), excluding both 0.0 and 1.0. The number is obtained by sampling the generator with the algorithm of gsl_rng_uniform until a non-zero value is obtained. You can use this function if you need to avoid a singularity at 0.0." 1
.IX Item "gsl_rng_uniform_pos($r) - This function returns a positive double precision floating point number uniformly distributed in the range (0,1), excluding both 0.0 and 1.0. The number is obtained by sampling the generator with the algorithm of gsl_rng_uniform until a non-zero value is obtained. You can use this function if you need to avoid a singularity at 0.0."
.ie n .IP "gsl_rng_uniform_int($r, $n) \- This function returns a random integer from 0 to $n\-1 inclusive by scaling down and/or discarding samples from the generator $r. All integers in the range [0,$n\-1] are produced with equal probability. For generators with a non-zero minimum value an offset is applied so that zero is returned with the correct probability. Note that this function is designed for sampling from ranges smaller than the range of the underlying generator. The parameter $n must be less than or equal to the range of the generator $r. If $n is larger than the range of the generator then the function calls the error handler with an error code of $GSL_EINVAL and returns zero. In particular, this function is not intended for generating the full range of unsigned integer values [0,2^32\-1]. Instead choose a generator with the maximal integer range and zero mimimum value, such as $gsl_rng_ranlxd1, $gsl_rng_mt19937 or $gsl_rng_taus, and sample it directly using gsl_rng_get. The range of each generator can be found using the auxiliary functions described in the next section." 1
.el .IP "gsl_rng_uniform_int($r, \f(CW$n\fR) \- This function returns a random integer from 0 to \f(CW$n\fR\-1 inclusive by scaling down and/or discarding samples from the generator \f(CW$r\fR. All integers in the range [0,$n\-1] are produced with equal probability. For generators with a non-zero minimum value an offset is applied so that zero is returned with the correct probability. Note that this function is designed for sampling from ranges smaller than the range of the underlying generator. The parameter \f(CW$n\fR must be less than or equal to the range of the generator \f(CW$r\fR. If \f(CW$n\fR is larger than the range of the generator then the function calls the error handler with an error code of \f(CW$GSL_EINVAL\fR and returns zero. In particular, this function is not intended for generating the full range of unsigned integer values [0,2^32\-1]. Instead choose a generator with the maximal integer range and zero mimimum value, such as \f(CW$gsl_rng_ranlxd1\fR, \f(CW$gsl_rng_mt19937\fR or \f(CW$gsl_rng_taus\fR, and sample it directly using gsl_rng_get. The range of each generator can be found using the auxiliary functions described in the next section." 1
.IX Item "gsl_rng_uniform_int($r, $n) - This function returns a random integer from 0 to $n-1 inclusive by scaling down and/or discarding samples from the generator $r. All integers in the range [0,$n-1] are produced with equal probability. For generators with a non-zero minimum value an offset is applied so that zero is returned with the correct probability. Note that this function is designed for sampling from ranges smaller than the range of the underlying generator. The parameter $n must be less than or equal to the range of the generator $r. If $n is larger than the range of the generator then the function calls the error handler with an error code of $GSL_EINVAL and returns zero. In particular, this function is not intended for generating the full range of unsigned integer values [0,2^32-1]. Instead choose a generator with the maximal integer range and zero mimimum value, such as $gsl_rng_ranlxd1, $gsl_rng_mt19937 or $gsl_rng_taus, and sample it directly using gsl_rng_get. The range of each generator can be found using the auxiliary functions described in the next section."
.ie n .IP "gsl_rng_fwrite($stream, $r) \- This function writes the random number state of the random number generator $r to the stream $stream (opened with the gsl_fopen function from the Math::GSL module) in binary format. The return value is 0 for success and $GSL_EFAILED if there was a problem writing to the file. Since the data is written in the native binary format it may not be portable between different architectures." 1
.el .IP "gsl_rng_fwrite($stream, \f(CW$r\fR) \- This function writes the random number state of the random number generator \f(CW$r\fR to the stream \f(CW$stream\fR (opened with the gsl_fopen function from the Math::GSL module) in binary format. The return value is 0 for success and \f(CW$GSL_EFAILED\fR if there was a problem writing to the file. Since the data is written in the native binary format it may not be portable between different architectures." 1
.IX Item "gsl_rng_fwrite($stream, $r) - This function writes the random number state of the random number generator $r to the stream $stream (opened with the gsl_fopen function from the Math::GSL module) in binary format. The return value is 0 for success and $GSL_EFAILED if there was a problem writing to the file. Since the data is written in the native binary format it may not be portable between different architectures."
.ie n .IP "gsl_rng_fread($stream, $r) \- This function reads the random number state into the random number generator $r from the open stream $stream (opened with the gsl_fopen function from the Math::GSL module) in binary format. The random number generator $r must be preinitialized with the correct random number generator type since type information is not saved. The return value is 0 for success and $GSL_EFAILED if there was a problem reading from the file. The data is assumed to have been written in the native binary format on the same architecture." 1
.el .IP "gsl_rng_fread($stream, \f(CW$r\fR) \- This function reads the random number state into the random number generator \f(CW$r\fR from the open stream \f(CW$stream\fR (opened with the gsl_fopen function from the Math::GSL module) in binary format. The random number generator \f(CW$r\fR must be preinitialized with the correct random number generator type since type information is not saved. The return value is 0 for success and \f(CW$GSL_EFAILED\fR if there was a problem reading from the file. The data is assumed to have been written in the native binary format on the same architecture." 1
.IX Item "gsl_rng_fread($stream, $r) - This function reads the random number state into the random number generator $r from the open stream $stream (opened with the gsl_fopen function from the Math::GSL module) in binary format. The random number generator $r must be preinitialized with the correct random number generator type since type information is not saved. The return value is 0 for success and $GSL_EFAILED if there was a problem reading from the file. The data is assumed to have been written in the native binary format on the same architecture."
.ie n .IP "gsl_rng_clone($r) \- This function returns a pointer to a newly created generator which is an exact copy of the generator $r." 1
.el .IP "gsl_rng_clone($r) \- This function returns a pointer to a newly created generator which is an exact copy of the generator \f(CW$r\fR." 1
.IX Item "gsl_rng_clone($r) - This function returns a pointer to a newly created generator which is an exact copy of the generator $r."
.IP "gsl_rng_max($r) \- This function returns the largest value that gsl_rng_get can return." 1
.IX Item "gsl_rng_max($r) - This function returns the largest value that gsl_rng_get can return."
.IP "gsl_rng_min($r) \- gsl_rng_min returns the smallest value that gsl_rng_get can return. Usually this value is zero. There are some generators with algorithms that cannot return zero, and for these generators the minimum value is 1." 1
.IX Item "gsl_rng_min($r) - gsl_rng_min returns the smallest value that gsl_rng_get can return. Usually this value is zero. There are some generators with algorithms that cannot return zero, and for these generators the minimum value is 1."
.IP "gsl_rng_name($r) \- This function returns a pointer to the name of the generator. For example," 1
.IX Item "gsl_rng_name($r) - This function returns a pointer to the name of the generator. For example,"
.RS 1
.ie n .IP "print ""r is a "" . gsl_rng_name($r) . ""generator\en"";" 4
.el .IP "print ``r is a '' . gsl_rng_name($r) . ``generator\en'';" 4
.IX Item "print r is a  . gsl_rng_name($r) . generatorn;"
.IP "would print something like r is a 'taus' generator." 4
.IX Item "would print something like r is a 'taus' generator."
.RE
.RS 1
.RE
.ie n .IP "gsl_rng_size($r) \- This function returns the size of the state of generator $r. You can use this information to access the state directly." 1
.el .IP "gsl_rng_size($r) \- This function returns the size of the state of generator \f(CW$r\fR. You can use this information to access the state directly." 1
.IX Item "gsl_rng_size($r) - This function returns the size of the state of generator $r. You can use this information to access the state directly."
.ie n .IP "gsl_rng_state($r) \- This function returns a pointer to the state of generator $r. You can use this information to access the state directly." 1
.el .IP "gsl_rng_state($r) \- This function returns a pointer to the state of generator \f(CW$r\fR. You can use this information to access the state directly." 1
.IX Item "gsl_rng_state($r) - This function returns a pointer to the state of generator $r. You can use this information to access the state directly."
.IP "gsl_rng_print_state($r)" 1
.IX Item "gsl_rng_print_state($r)"
.PD
.SH "Random Number Generator Types"
.IX Header "Random Number Generator Types"
.ie n .IP "$gsl_rng_default" 1
.el .IP "\f(CW$gsl_rng_default\fR" 1
.IX Item "$gsl_rng_default"
.PD 0
.ie n .IP "$gsl_rng_knuthran" 1
.el .IP "\f(CW$gsl_rng_knuthran\fR" 1
.IX Item "$gsl_rng_knuthran"
.ie n .IP "$gsl_rng_ran0" 1
.el .IP "\f(CW$gsl_rng_ran0\fR" 1
.IX Item "$gsl_rng_ran0"
.ie n .IP "$gsl_rng_borosh13" 1
.el .IP "\f(CW$gsl_rng_borosh13\fR" 1
.IX Item "$gsl_rng_borosh13"
.ie n .IP "$gsl_rng_coveyou" 1
.el .IP "\f(CW$gsl_rng_coveyou\fR" 1
.IX Item "$gsl_rng_coveyou"
.ie n .IP "$gsl_rng_cmrg" 1
.el .IP "\f(CW$gsl_rng_cmrg\fR" 1
.IX Item "$gsl_rng_cmrg"
.ie n .IP "$gsl_rng_fishman18" 1
.el .IP "\f(CW$gsl_rng_fishman18\fR" 1
.IX Item "$gsl_rng_fishman18"
.ie n .IP "$gsl_rng_fishman20" 1
.el .IP "\f(CW$gsl_rng_fishman20\fR" 1
.IX Item "$gsl_rng_fishman20"
.ie n .IP "$gsl_rng_fishman2x \- This is the L'Ecuyer-Fishman random number generator. It is taken from Knuth's Seminumerical Algorithms, 3rd Ed., page 108. Its sequence is, z_{n+1} = (x_n \- y_n) mod m with m = 2^31 \- 1. x_n and y_n are given by the fishman20 and lecuyer21 algorithms. The seed specifies the initial value, x_1." 1
.el .IP "\f(CW$gsl_rng_fishman2x\fR \- This is the L'Ecuyer-Fishman random number generator. It is taken from Knuth's Seminumerical Algorithms, 3rd Ed., page 108. Its sequence is, z_{n+1} = (x_n \- y_n) mod m with m = 2^31 \- 1. x_n and y_n are given by the fishman20 and lecuyer21 algorithms. The seed specifies the initial value, x_1." 1
.IX Item "$gsl_rng_fishman2x - This is the L'Ecuyer-Fishman random number generator. It is taken from Knuth's Seminumerical Algorithms, 3rd Ed., page 108. Its sequence is, z_{n+1} = (x_n - y_n) mod m with m = 2^31 - 1. x_n and y_n are given by the fishman20 and lecuyer21 algorithms. The seed specifies the initial value, x_1."
.ie n .IP "$gsl_rng_gfsr4" 1
.el .IP "\f(CW$gsl_rng_gfsr4\fR" 1
.IX Item "$gsl_rng_gfsr4"
.ie n .IP "$gsl_rng_knuthran" 1
.el .IP "\f(CW$gsl_rng_knuthran\fR" 1
.IX Item "$gsl_rng_knuthran"
.ie n .IP "$gsl_rng_knuthran2" 1
.el .IP "\f(CW$gsl_rng_knuthran2\fR" 1
.IX Item "$gsl_rng_knuthran2"
.ie n .IP "$gsl_rng_knuthran2002" 1
.el .IP "\f(CW$gsl_rng_knuthran2002\fR" 1
.IX Item "$gsl_rng_knuthran2002"
.ie n .IP "$gsl_rng_lecuyer21" 1
.el .IP "\f(CW$gsl_rng_lecuyer21\fR" 1
.IX Item "$gsl_rng_lecuyer21"
.ie n .IP "$gsl_rng_minstd" 1
.el .IP "\f(CW$gsl_rng_minstd\fR" 1
.IX Item "$gsl_rng_minstd"
.ie n .IP "$gsl_rng_mrg" 1
.el .IP "\f(CW$gsl_rng_mrg\fR" 1
.IX Item "$gsl_rng_mrg"
.ie n .IP "$gsl_rng_mt19937" 1
.el .IP "\f(CW$gsl_rng_mt19937\fR" 1
.IX Item "$gsl_rng_mt19937"
.ie n .IP "$gsl_rng_mt19937_1999" 1
.el .IP "\f(CW$gsl_rng_mt19937_1999\fR" 1
.IX Item "$gsl_rng_mt19937_1999"
.ie n .IP "$gsl_rng_mt19937_1998" 1
.el .IP "\f(CW$gsl_rng_mt19937_1998\fR" 1
.IX Item "$gsl_rng_mt19937_1998"
.ie n .IP "$gsl_rng_r250" 1
.el .IP "\f(CW$gsl_rng_r250\fR" 1
.IX Item "$gsl_rng_r250"
.ie n .IP "$gsl_rng_ran0" 1
.el .IP "\f(CW$gsl_rng_ran0\fR" 1
.IX Item "$gsl_rng_ran0"
.ie n .IP "$gsl_rng_ran1" 1
.el .IP "\f(CW$gsl_rng_ran1\fR" 1
.IX Item "$gsl_rng_ran1"
.ie n .IP "$gsl_rng_ran2" 1
.el .IP "\f(CW$gsl_rng_ran2\fR" 1
.IX Item "$gsl_rng_ran2"
.ie n .IP "$gsl_rng_ran3" 1
.el .IP "\f(CW$gsl_rng_ran3\fR" 1
.IX Item "$gsl_rng_ran3"
.ie n .IP "$gsl_rng_rand \- This is the \s-1BSD\s0 rand generator. Its sequence is x_{n+1} = (a x_n + c) mod m with a = 1103515245, c = 12345 and m = 2^31. The seed specifies the initial value, x_1. The period of this generator is 2^31, and it uses 1 word of storage per generator." 1
.el .IP "\f(CW$gsl_rng_rand\fR \- This is the \s-1BSD\s0 rand generator. Its sequence is x_{n+1} = (a x_n + c) mod m with a = 1103515245, c = 12345 and m = 2^31. The seed specifies the initial value, x_1. The period of this generator is 2^31, and it uses 1 word of storage per generator." 1
.IX Item "$gsl_rng_rand - This is the BSD rand generator. Its sequence is x_{n+1} = (a x_n + c) mod m with a = 1103515245, c = 12345 and m = 2^31. The seed specifies the initial value, x_1. The period of this generator is 2^31, and it uses 1 word of storage per generator."
.ie n .IP "$gsl_rng_rand48" 1
.el .IP "\f(CW$gsl_rng_rand48\fR" 1
.IX Item "$gsl_rng_rand48"
.ie n .IP "$gsl_rng_random128_bsd" 1
.el .IP "\f(CW$gsl_rng_random128_bsd\fR" 1
.IX Item "$gsl_rng_random128_bsd"
.ie n .IP "$gsl_rng_random128_gli" 1
.el .IP "\f(CW$gsl_rng_random128_gli\fR" 1
.IX Item "$gsl_rng_random128_gli"
.ie n .IP "$gsl_rng_random128_lib" 1
.el .IP "\f(CW$gsl_rng_random128_lib\fR" 1
.IX Item "$gsl_rng_random128_lib"
.ie n .IP "$gsl_rng_random256_bsd" 1
.el .IP "\f(CW$gsl_rng_random256_bsd\fR" 1
.IX Item "$gsl_rng_random256_bsd"
.ie n .IP "$gsl_rng_random256_gli" 1
.el .IP "\f(CW$gsl_rng_random256_gli\fR" 1
.IX Item "$gsl_rng_random256_gli"
.ie n .IP "$gsl_rng_random256_lib" 1
.el .IP "\f(CW$gsl_rng_random256_lib\fR" 1
.IX Item "$gsl_rng_random256_lib"
.ie n .IP "$gsl_rng_random32_bsd" 1
.el .IP "\f(CW$gsl_rng_random32_bsd\fR" 1
.IX Item "$gsl_rng_random32_bsd"
.ie n .IP "$gsl_rng_random32_glib" 1
.el .IP "\f(CW$gsl_rng_random32_glib\fR" 1
.IX Item "$gsl_rng_random32_glib"
.ie n .IP "$gsl_rng_random32_libc" 1
.el .IP "\f(CW$gsl_rng_random32_libc\fR" 1
.IX Item "$gsl_rng_random32_libc"
.ie n .IP "$gsl_rng_random64_bsd" 1
.el .IP "\f(CW$gsl_rng_random64_bsd\fR" 1
.IX Item "$gsl_rng_random64_bsd"
.ie n .IP "$gsl_rng_random64_glib" 1
.el .IP "\f(CW$gsl_rng_random64_glib\fR" 1
.IX Item "$gsl_rng_random64_glib"
.ie n .IP "$gsl_rng_random64_libc" 1
.el .IP "\f(CW$gsl_rng_random64_libc\fR" 1
.IX Item "$gsl_rng_random64_libc"
.ie n .IP "$gsl_rng_random8_bsd" 1
.el .IP "\f(CW$gsl_rng_random8_bsd\fR" 1
.IX Item "$gsl_rng_random8_bsd"
.ie n .IP "$gsl_rng_random8_glibc" 1
.el .IP "\f(CW$gsl_rng_random8_glibc\fR" 1
.IX Item "$gsl_rng_random8_glibc"
.ie n .IP "$gsl_rng_random8_libc5" 1
.el .IP "\f(CW$gsl_rng_random8_libc5\fR" 1
.IX Item "$gsl_rng_random8_libc5"
.ie n .IP "$gsl_rng_random_bsd" 1
.el .IP "\f(CW$gsl_rng_random_bsd\fR" 1
.IX Item "$gsl_rng_random_bsd"
.ie n .IP "$gsl_rng_random_glibc2" 1
.el .IP "\f(CW$gsl_rng_random_glibc2\fR" 1
.IX Item "$gsl_rng_random_glibc2"
.ie n .IP "$gsl_rng_random_libc5" 1
.el .IP "\f(CW$gsl_rng_random_libc5\fR" 1
.IX Item "$gsl_rng_random_libc5"
.ie n .IP "$gsl_rng_randu" 1
.el .IP "\f(CW$gsl_rng_randu\fR" 1
.IX Item "$gsl_rng_randu"
.ie n .IP "$gsl_rng_ranf" 1
.el .IP "\f(CW$gsl_rng_ranf\fR" 1
.IX Item "$gsl_rng_ranf"
.ie n .IP "$gsl_rng_ranlux" 1
.el .IP "\f(CW$gsl_rng_ranlux\fR" 1
.IX Item "$gsl_rng_ranlux"
.ie n .IP "$gsl_rng_ranlux389" 1
.el .IP "\f(CW$gsl_rng_ranlux389\fR" 1
.IX Item "$gsl_rng_ranlux389"
.ie n .IP "$gsl_rng_ranlxd1" 1
.el .IP "\f(CW$gsl_rng_ranlxd1\fR" 1
.IX Item "$gsl_rng_ranlxd1"
.ie n .IP "$gsl_rng_ranlxd2" 1
.el .IP "\f(CW$gsl_rng_ranlxd2\fR" 1
.IX Item "$gsl_rng_ranlxd2"
.ie n .IP "$gsl_rng_ranlxs0" 1
.el .IP "\f(CW$gsl_rng_ranlxs0\fR" 1
.IX Item "$gsl_rng_ranlxs0"
.ie n .IP "$gsl_rng_ranlxs1" 1
.el .IP "\f(CW$gsl_rng_ranlxs1\fR" 1
.IX Item "$gsl_rng_ranlxs1"
.ie n .IP "$gsl_rng_ranlxs2" 1
.el .IP "\f(CW$gsl_rng_ranlxs2\fR" 1
.IX Item "$gsl_rng_ranlxs2"
.ie n .IP "$gsl_rng_ranmar \- This is the \s-1RANMAR\s0 lagged-fibonacci generator of Marsaglia, Zaman and Tsang. It is a 24\-bit generator, originally designed for single-precision \s-1IEEE\s0 floating point numbers. It was included in the \s-1CERNLIB\s0 high-energy physics library." 1
.el .IP "\f(CW$gsl_rng_ranmar\fR \- This is the \s-1RANMAR\s0 lagged-fibonacci generator of Marsaglia, Zaman and Tsang. It is a 24\-bit generator, originally designed for single-precision \s-1IEEE\s0 floating point numbers. It was included in the \s-1CERNLIB\s0 high-energy physics library." 1
.IX Item "$gsl_rng_ranmar - This is the RANMAR lagged-fibonacci generator of Marsaglia, Zaman and Tsang. It is a 24-bit generator, originally designed for single-precision IEEE floating point numbers. It was included in the CERNLIB high-energy physics library."
.ie n .IP "$gsl_rng_slatec \- This is the \s-1SLATEC\s0 random number generator \s-1RAND\s0. It is ancient. The original source code is available from \s-1NETLIB\s0." 1
.el .IP "\f(CW$gsl_rng_slatec\fR \- This is the \s-1SLATEC\s0 random number generator \s-1RAND\s0. It is ancient. The original source code is available from \s-1NETLIB\s0." 1
.IX Item "$gsl_rng_slatec - This is the SLATEC random number generator RAND. It is ancient. The original source code is available from NETLIB."
.ie n .IP "$gsl_rng_taus" 1
.el .IP "\f(CW$gsl_rng_taus\fR" 1
.IX Item "$gsl_rng_taus"
.ie n .IP "$gsl_rng_taus2" 1
.el .IP "\f(CW$gsl_rng_taus2\fR" 1
.IX Item "$gsl_rng_taus2"
.ie n .IP "$gsl_rng_taus113" 1
.el .IP "\f(CW$gsl_rng_taus113\fR" 1
.IX Item "$gsl_rng_taus113"
.ie n .IP "$gsl_rng_transputer" 1
.el .IP "\f(CW$gsl_rng_transputer\fR" 1
.IX Item "$gsl_rng_transputer"
.ie n .IP "$gsl_rng_tt800" 1
.el .IP "\f(CW$gsl_rng_tt800\fR" 1
.IX Item "$gsl_rng_tt800"
.ie n .IP "$gsl_rng_uni" 1
.el .IP "\f(CW$gsl_rng_uni\fR" 1
.IX Item "$gsl_rng_uni"
.ie n .IP "$gsl_rng_uni32" 1
.el .IP "\f(CW$gsl_rng_uni32\fR" 1
.IX Item "$gsl_rng_uni32"
.ie n .IP "$gsl_rng_vax \- This is the \s-1VAX\s0 generator \s-1MTH$RANDOM\s0. Its sequence is, x_{n+1} = (a x_n + c) mod m with a = 69069, c = 1 and m = 2^32. The seed specifies the initial value, x_1. The period of this generator is 2^32 and it uses 1 word of storage per generator." 1
.el .IP "\f(CW$gsl_rng_vax\fR \- This is the \s-1VAX\s0 generator \s-1MTH$RANDOM\s0. Its sequence is, x_{n+1} = (a x_n + c) mod m with a = 69069, c = 1 and m = 2^32. The seed specifies the initial value, x_1. The period of this generator is 2^32 and it uses 1 word of storage per generator." 1
.IX Item "$gsl_rng_vax - This is the VAX generator MTH$RANDOM. Its sequence is, x_{n+1} = (a x_n + c) mod m with a = 69069, c = 1 and m = 2^32. The seed specifies the initial value, x_1. The period of this generator is 2^32 and it uses 1 word of storage per generator."
.ie n .IP "$gsl_rng_waterman14" 1
.el .IP "\f(CW$gsl_rng_waterman14\fR" 1
.IX Item "$gsl_rng_waterman14"
.ie n .IP "$gsl_rng_zuf \- This is the \s-1ZUFALL\s0 lagged Fibonacci series generator of Peterson. Its sequence is," 1
.el .IP "\f(CW$gsl_rng_zuf\fR \- This is the \s-1ZUFALL\s0 lagged Fibonacci series generator of Peterson. Its sequence is," 1
.IX Item "$gsl_rng_zuf - This is the ZUFALL lagged Fibonacci series generator of Peterson. Its sequence is,"
.RS 1
.IP "t = u_{n\-273} + u_{n\-607}" 4
.IX Item "t = u_{n-273} + u_{n-607}"
.IP "u_n  = t \- floor(t)" 4
.IX Item "u_n  = t - floor(t)"
.RE
.RS 1
.PD
.Sp
.Vb 1
\& The original source code is available from NETLIB. For more information see,
\&
\& * W. Petersen, a\*^XXLagged Fibonacci Random Number Generators for the NEC SX\-3a\*^XX, International Journal of High Speed Computing (1994).
.Ve
.RE
.PP
For more informations on the functions, we refer you to the \s-1GSL\s0 offcial documentation:
.PP
<http://www.gnu.org/software/gsl/manual/html_node/>
.SH "EXAMPLES"
.IX Header "EXAMPLES"
The following example will print out a list a random integers between certain
minimum and maximum values. The command line arguments are first the number of
random numbers wanted, the minimum and then maximum. The defaults are 10, 0 and
100, respectively.
.PP
.Vb 9
\&    use Math::GSL::RNG qw/:all/;
\&    my $seed = int rand(100);
\&    my $rng  = Math::GSL::RNG\->new($gsl_rng_knuthran, $seed );
\&    my ($num,$min,$max) = @ARGV;
\&    $num ||= 10;
\&    $min ||= 0;
\&    $max ||= 100;
\&    print join "\en", map { $min + $rng\->get % ($max\-$min+1)  } (1..$num);
\&    print "\en";
.Ve
.PP
The \f(CW$seed\fR argument is optional but encouraged. This program is available in
the \fBexamples/\fR directory that comes with the source of this module.
.PP
If you would like a series of random non-integer numbers, then you can generate one \*(L"scaling factor\*(R" 
and multiple by that, such as
.PP
.Vb 7
\&    use Math::GSL::RNG qw/:all/;
\&    my $scale= rand(10);
\&    my $seed = int rand(100);
\&    my $rng  = Math::GSL::RNG\->new($gsl_rng_knuthran, $seed );
\&    my ($num,$min,$max) = (10,0,100);
\&    print join "\en", map { $scale*($min + $rng\->get % ($max\-$min+1))  } (1..$num);
\&    print "\en";
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
Jonathan \*(L"Duke\*(R" Leto <jonathan@leto.net> and Thierry Moisan <thierry.moisan@gmail.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2008\-2011 Jonathan \*(L"Duke\*(R" Leto and Thierry Moisan
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
