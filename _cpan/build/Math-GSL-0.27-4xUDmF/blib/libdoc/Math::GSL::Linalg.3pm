.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Math::GSL::Linalg 3pm"
.TH Math::GSL::Linalg 3pm "2012-08-21" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::GSL::Linalg \- Functions for solving linear systems
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Math::GSL::Linalg qw/:all/;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Here is a list of all the functions included in this module :
.IP "gsl_linalg_matmult" 4
.IX Item "gsl_linalg_matmult"
.PD 0
.IP "gsl_linalg_matmult_mod" 4
.IX Item "gsl_linalg_matmult_mod"
.IP "gsl_linalg_exponential_ss" 4
.IX Item "gsl_linalg_exponential_ss"
.IP "gsl_linalg_householder_transform" 4
.IX Item "gsl_linalg_householder_transform"
.IP "gsl_linalg_complex_householder_transform" 4
.IX Item "gsl_linalg_complex_householder_transform"
.ie n .IP "gsl_linalg_householder_hm($tau, $v, $A) \- This function applies the Householder matrix P defined by the scalar $tau and the vector $v to the left-hand side of the matrix $A. On output the result P A is stored in $A. The function returns 0 if it succeded, 1 otherwise." 4
.el .IP "gsl_linalg_householder_hm($tau, \f(CW$v\fR, \f(CW$A\fR) \- This function applies the Householder matrix P defined by the scalar \f(CW$tau\fR and the vector \f(CW$v\fR to the left-hand side of the matrix \f(CW$A\fR. On output the result P A is stored in \f(CW$A\fR. The function returns 0 if it succeded, 1 otherwise." 4
.IX Item "gsl_linalg_householder_hm($tau, $v, $A) - This function applies the Householder matrix P defined by the scalar $tau and the vector $v to the left-hand side of the matrix $A. On output the result P A is stored in $A. The function returns 0 if it succeded, 1 otherwise."
.ie n .IP "gsl_linalg_householder_mh($tau, $v, $A) \- This function applies the Householder matrix P defined by the scalar $tau and the vector $v to the right-hand side of the matrix $A. On output the result A P is stored in $A." 4
.el .IP "gsl_linalg_householder_mh($tau, \f(CW$v\fR, \f(CW$A\fR) \- This function applies the Householder matrix P defined by the scalar \f(CW$tau\fR and the vector \f(CW$v\fR to the right-hand side of the matrix \f(CW$A\fR. On output the result A P is stored in \f(CW$A\fR." 4
.IX Item "gsl_linalg_householder_mh($tau, $v, $A) - This function applies the Householder matrix P defined by the scalar $tau and the vector $v to the right-hand side of the matrix $A. On output the result A P is stored in $A."
.ie n .IP "gsl_linalg_householder_hv($tau, $v, $w) \- This function applies the Householder transformation P defined by the scalar $tau and the vector $v to the vector $w. On output the result P w is stored in $w." 4
.el .IP "gsl_linalg_householder_hv($tau, \f(CW$v\fR, \f(CW$w\fR) \- This function applies the Householder transformation P defined by the scalar \f(CW$tau\fR and the vector \f(CW$v\fR to the vector \f(CW$w\fR. On output the result P w is stored in \f(CW$w\fR." 4
.IX Item "gsl_linalg_householder_hv($tau, $v, $w) - This function applies the Householder transformation P defined by the scalar $tau and the vector $v to the vector $w. On output the result P w is stored in $w."
.IP "gsl_linalg_householder_hm1" 4
.IX Item "gsl_linalg_householder_hm1"
.ie n .IP "gsl_linalg_complex_householder_hm($tau, $v, $A) \- Does the same operation than gsl_linalg_householder_hm but with the complex matrix $A, the complex value $tau and the complex vector $v." 4
.el .IP "gsl_linalg_complex_householder_hm($tau, \f(CW$v\fR, \f(CW$A\fR) \- Does the same operation than gsl_linalg_householder_hm but with the complex matrix \f(CW$A\fR, the complex value \f(CW$tau\fR and the complex vector \f(CW$v\fR." 4
.IX Item "gsl_linalg_complex_householder_hm($tau, $v, $A) - Does the same operation than gsl_linalg_householder_hm but with the complex matrix $A, the complex value $tau and the complex vector $v."
.ie n .IP "gsl_linalg_complex_householder_mh($tau, $v, $A) \- Does the same operation than gsl_linalg_householder_mh but with the complex matrix $A, the complex value $tau and the complex vector $v." 4
.el .IP "gsl_linalg_complex_householder_mh($tau, \f(CW$v\fR, \f(CW$A\fR) \- Does the same operation than gsl_linalg_householder_mh but with the complex matrix \f(CW$A\fR, the complex value \f(CW$tau\fR and the complex vector \f(CW$v\fR." 4
.IX Item "gsl_linalg_complex_householder_mh($tau, $v, $A) - Does the same operation than gsl_linalg_householder_mh but with the complex matrix $A, the complex value $tau and the complex vector $v."
.ie n .IP "gsl_linalg_complex_householder_hv($tau, $v, $w) \- Does the same operation than gsl_linalg_householder_hv but with the complex value $tau and the complex vectors $v and $w." 4
.el .IP "gsl_linalg_complex_householder_hv($tau, \f(CW$v\fR, \f(CW$w\fR) \- Does the same operation than gsl_linalg_householder_hv but with the complex value \f(CW$tau\fR and the complex vectors \f(CW$v\fR and \f(CW$w\fR." 4
.IX Item "gsl_linalg_complex_householder_hv($tau, $v, $w) - Does the same operation than gsl_linalg_householder_hv but with the complex value $tau and the complex vectors $v and $w."
.ie n .IP "gsl_linalg_hessenberg_decomp($A, $tau) \- This function computes the Hessenberg decomposition of the matrix $A by applying the similarity transformation H = U^T A U. On output, H is stored in the upper portion of $A. The information required to construct the matrix U is stored in the lower triangular portion of $A. U is a product of N \- 2 Householder matrices. The Householder vectors are stored in the lower portion of $A (below the subdiagonal) and the Householder coefficients are stored in the vector $tau. tau must be of length N. The function returns 0 if it succeded, 1 otherwise." 4
.el .IP "gsl_linalg_hessenberg_decomp($A, \f(CW$tau\fR) \- This function computes the Hessenberg decomposition of the matrix \f(CW$A\fR by applying the similarity transformation H = U^T A U. On output, H is stored in the upper portion of \f(CW$A\fR. The information required to construct the matrix U is stored in the lower triangular portion of \f(CW$A\fR. U is a product of N \- 2 Householder matrices. The Householder vectors are stored in the lower portion of \f(CW$A\fR (below the subdiagonal) and the Householder coefficients are stored in the vector \f(CW$tau\fR. tau must be of length N. The function returns 0 if it succeded, 1 otherwise." 4
.IX Item "gsl_linalg_hessenberg_decomp($A, $tau) - This function computes the Hessenberg decomposition of the matrix $A by applying the similarity transformation H = U^T A U. On output, H is stored in the upper portion of $A. The information required to construct the matrix U is stored in the lower triangular portion of $A. U is a product of N - 2 Householder matrices. The Householder vectors are stored in the lower portion of $A (below the subdiagonal) and the Householder coefficients are stored in the vector $tau. tau must be of length N. The function returns 0 if it succeded, 1 otherwise."
.ie n .IP "gsl_linalg_hessenberg_unpack($H, $tau, $U) \- This function constructs the orthogonal matrix $U from the information stored in the Hessenberg matrix $H along with the vector $tau. $H and $tau are outputs from gsl_linalg_hessenberg_decomp." 4
.el .IP "gsl_linalg_hessenberg_unpack($H, \f(CW$tau\fR, \f(CW$U\fR) \- This function constructs the orthogonal matrix \f(CW$U\fR from the information stored in the Hessenberg matrix \f(CW$H\fR along with the vector \f(CW$tau\fR. \f(CW$H\fR and \f(CW$tau\fR are outputs from gsl_linalg_hessenberg_decomp." 4
.IX Item "gsl_linalg_hessenberg_unpack($H, $tau, $U) - This function constructs the orthogonal matrix $U from the information stored in the Hessenberg matrix $H along with the vector $tau. $H and $tau are outputs from gsl_linalg_hessenberg_decomp."
.ie n .IP "gsl_linalg_hessenberg_unpack_accum($H, $tau, $V) \- This function is similar to gsl_linalg_hessenberg_unpack, except it accumulates the matrix U into $V, so that V' = \s-1VU\s0. The matrix $V must be initialized prior to calling this function. Setting $V to the identity matrix provides the same result as gsl_linalg_hessenberg_unpack. If $H is order N, then $V must have N columns but may have any number of rows." 4
.el .IP "gsl_linalg_hessenberg_unpack_accum($H, \f(CW$tau\fR, \f(CW$V\fR) \- This function is similar to gsl_linalg_hessenberg_unpack, except it accumulates the matrix U into \f(CW$V\fR, so that V' = \s-1VU\s0. The matrix \f(CW$V\fR must be initialized prior to calling this function. Setting \f(CW$V\fR to the identity matrix provides the same result as gsl_linalg_hessenberg_unpack. If \f(CW$H\fR is order N, then \f(CW$V\fR must have N columns but may have any number of rows." 4
.IX Item "gsl_linalg_hessenberg_unpack_accum($H, $tau, $V) - This function is similar to gsl_linalg_hessenberg_unpack, except it accumulates the matrix U into $V, so that V' = VU. The matrix $V must be initialized prior to calling this function. Setting $V to the identity matrix provides the same result as gsl_linalg_hessenberg_unpack. If $H is order N, then $V must have N columns but may have any number of rows."
.ie n .IP "gsl_linalg_hessenberg_set_zero($H) \- This function sets the lower triangular portion of $H, below the subdiagonal, to zero. It is useful for clearing out the Householder vectors after calling gsl_linalg_hessenberg_decomp." 4
.el .IP "gsl_linalg_hessenberg_set_zero($H) \- This function sets the lower triangular portion of \f(CW$H\fR, below the subdiagonal, to zero. It is useful for clearing out the Householder vectors after calling gsl_linalg_hessenberg_decomp." 4
.IX Item "gsl_linalg_hessenberg_set_zero($H) - This function sets the lower triangular portion of $H, below the subdiagonal, to zero. It is useful for clearing out the Householder vectors after calling gsl_linalg_hessenberg_decomp."
.IP "gsl_linalg_hessenberg_submatrix" 4
.IX Item "gsl_linalg_hessenberg_submatrix"
.IP "gsl_linalg_hessenberg" 4
.IX Item "gsl_linalg_hessenberg"
.ie n .IP "gsl_linalg_hesstri_decomp($A, $B, $U, $V, $work) \- This function computes the Hessenberg-Triangular decomposition of the matrix pair ($A, $B). On output, H is stored in $A, and R is stored in $B. If $U and $V are provided (they may be null), the similarity transformations are stored in them. Additional workspace of length N is needed in the vector $work." 4
.el .IP "gsl_linalg_hesstri_decomp($A, \f(CW$B\fR, \f(CW$U\fR, \f(CW$V\fR, \f(CW$work\fR) \- This function computes the Hessenberg-Triangular decomposition of the matrix pair ($A, \f(CW$B\fR). On output, H is stored in \f(CW$A\fR, and R is stored in \f(CW$B\fR. If \f(CW$U\fR and \f(CW$V\fR are provided (they may be null), the similarity transformations are stored in them. Additional workspace of length N is needed in the vector \f(CW$work\fR." 4
.IX Item "gsl_linalg_hesstri_decomp($A, $B, $U, $V, $work) - This function computes the Hessenberg-Triangular decomposition of the matrix pair ($A, $B). On output, H is stored in $A, and R is stored in $B. If $U and $V are provided (they may be null), the similarity transformations are stored in them. Additional workspace of length N is needed in the vector $work."
.ie n .IP "gsl_linalg_SV_decomp($A, $V, $S, $work) \- This function factorizes the M\-by-N matrix $A into the singular value decomposition A = U S V^T for M >= N. On output the matrix $A is replaced by U. The diagonal elements of the singular value matrix S are stored in the vector $S. The singular values are non-negative and form a non-increasing sequence from S_1 to S_N. The matrix $V contains the elements of V in untransposed form. To form the product U S V^T it is necessary to take the transpose of V. A workspace of length N is required in vector $work. This routine uses the Golub-Reinsch \s-1SVD\s0 algorithm." 4
.el .IP "gsl_linalg_SV_decomp($A, \f(CW$V\fR, \f(CW$S\fR, \f(CW$work\fR) \- This function factorizes the M\-by-N matrix \f(CW$A\fR into the singular value decomposition A = U S V^T for M >= N. On output the matrix \f(CW$A\fR is replaced by U. The diagonal elements of the singular value matrix S are stored in the vector \f(CW$S\fR. The singular values are non-negative and form a non-increasing sequence from S_1 to S_N. The matrix \f(CW$V\fR contains the elements of V in untransposed form. To form the product U S V^T it is necessary to take the transpose of V. A workspace of length N is required in vector \f(CW$work\fR. This routine uses the Golub-Reinsch \s-1SVD\s0 algorithm." 4
.IX Item "gsl_linalg_SV_decomp($A, $V, $S, $work) - This function factorizes the M-by-N matrix $A into the singular value decomposition A = U S V^T for M >= N. On output the matrix $A is replaced by U. The diagonal elements of the singular value matrix S are stored in the vector $S. The singular values are non-negative and form a non-increasing sequence from S_1 to S_N. The matrix $V contains the elements of V in untransposed form. To form the product U S V^T it is necessary to take the transpose of V. A workspace of length N is required in vector $work. This routine uses the Golub-Reinsch SVD algorithm."
.ie n .IP "gsl_linalg_SV_decomp_mod($A, $X, $V, $S, $work) \- This function computes the \s-1SVD\s0 using the modified Golub-Reinsch algorithm, which is faster for M>>N. It requires the vector $work of length N and the N\-by-N matrix $X as additional working space. $A and $V are matrices while $S is a vector." 4
.el .IP "gsl_linalg_SV_decomp_mod($A, \f(CW$X\fR, \f(CW$V\fR, \f(CW$S\fR, \f(CW$work\fR) \- This function computes the \s-1SVD\s0 using the modified Golub-Reinsch algorithm, which is faster for M>>N. It requires the vector \f(CW$work\fR of length N and the N\-by-N matrix \f(CW$X\fR as additional working space. \f(CW$A\fR and \f(CW$V\fR are matrices while \f(CW$S\fR is a vector." 4
.IX Item "gsl_linalg_SV_decomp_mod($A, $X, $V, $S, $work) - This function computes the SVD using the modified Golub-Reinsch algorithm, which is faster for M>>N. It requires the vector $work of length N and the N-by-N matrix $X as additional working space. $A and $V are matrices while $S is a vector."
.ie n .IP "gsl_linalg_SV_decomp_jacobi($A, $V, $S) \- This function computes the \s-1SVD\s0 of the M\-by-N matrix $A using one-sided Jacobi orthogonalization for M >= N. The Jacobi method can compute singular values to higher relative accuracy than Golub-Reinsch algorithms. $V is a matrix while $S is a vector." 4
.el .IP "gsl_linalg_SV_decomp_jacobi($A, \f(CW$V\fR, \f(CW$S\fR) \- This function computes the \s-1SVD\s0 of the M\-by-N matrix \f(CW$A\fR using one-sided Jacobi orthogonalization for M >= N. The Jacobi method can compute singular values to higher relative accuracy than Golub-Reinsch algorithms. \f(CW$V\fR is a matrix while \f(CW$S\fR is a vector." 4
.IX Item "gsl_linalg_SV_decomp_jacobi($A, $V, $S) - This function computes the SVD of the M-by-N matrix $A using one-sided Jacobi orthogonalization for M >= N. The Jacobi method can compute singular values to higher relative accuracy than Golub-Reinsch algorithms. $V is a matrix while $S is a vector."
.ie n .IP "gsl_linalg_SV_solve($U, $V, $S, $b, $x) \- This function solves the system A x = b using the singular value decomposition ($U, $S, $V) of A given by gsl_linalg_SV_decomp. Only non-zero singular values are used in computing the solution. The parts of the solution corresponding to singular values of zero are ignored. Other singular values can be edited out by setting them to zero before calling this function. In the over-determined case where A has more rows than columns the system is solved in the least squares sense, returning the solution x which minimizes ||A x \- b||_2." 4
.el .IP "gsl_linalg_SV_solve($U, \f(CW$V\fR, \f(CW$S\fR, \f(CW$b\fR, \f(CW$x\fR) \- This function solves the system A x = b using the singular value decomposition ($U, \f(CW$S\fR, \f(CW$V\fR) of A given by gsl_linalg_SV_decomp. Only non-zero singular values are used in computing the solution. The parts of the solution corresponding to singular values of zero are ignored. Other singular values can be edited out by setting them to zero before calling this function. In the over-determined case where A has more rows than columns the system is solved in the least squares sense, returning the solution x which minimizes ||A x \- b||_2." 4
.IX Item "gsl_linalg_SV_solve($U, $V, $S, $b, $x) - This function solves the system A x = b using the singular value decomposition ($U, $S, $V) of A given by gsl_linalg_SV_decomp. Only non-zero singular values are used in computing the solution. The parts of the solution corresponding to singular values of zero are ignored. Other singular values can be edited out by setting them to zero before calling this function. In the over-determined case where A has more rows than columns the system is solved in the least squares sense, returning the solution x which minimizes ||A x - b||_2."
.ie n .IP "gsl_linalg_LU_decomp($a, $p) \- factorize the matrix $a into the \s-1LU\s0 decomposition \s-1PA\s0 = \s-1LU\s0. On output the diagonal and upper triangular part of the input matrix A contain the matrix U. The lower triangular part of the input matrix (excluding the diagonal) contains L. The diagonal elements of L are unity, and are not stored. The function returns two value, the first is 0 if the operation succeeded, 1 otherwise, and the second is the sign of the permutation." 4
.el .IP "gsl_linalg_LU_decomp($a, \f(CW$p\fR) \- factorize the matrix \f(CW$a\fR into the \s-1LU\s0 decomposition \s-1PA\s0 = \s-1LU\s0. On output the diagonal and upper triangular part of the input matrix A contain the matrix U. The lower triangular part of the input matrix (excluding the diagonal) contains L. The diagonal elements of L are unity, and are not stored. The function returns two value, the first is 0 if the operation succeeded, 1 otherwise, and the second is the sign of the permutation." 4
.IX Item "gsl_linalg_LU_decomp($a, $p) - factorize the matrix $a into the LU decomposition PA = LU. On output the diagonal and upper triangular part of the input matrix A contain the matrix U. The lower triangular part of the input matrix (excluding the diagonal) contains L. The diagonal elements of L are unity, and are not stored. The function returns two value, the first is 0 if the operation succeeded, 1 otherwise, and the second is the sign of the permutation."
.ie n .IP "gsl_linalg_LU_solve($LU, $p, $b, $x) \- This function solves the square system A x = b using the \s-1LU\s0 decomposition of the matrix A into (\s-1LU\s0, p) given by gsl_linalg_LU_decomp. $LU is a matrix, $p a permutation and $b and $x are vectors. The function returns 1 if the operation succeded, 0 otherwise." 4
.el .IP "gsl_linalg_LU_solve($LU, \f(CW$p\fR, \f(CW$b\fR, \f(CW$x\fR) \- This function solves the square system A x = b using the \s-1LU\s0 decomposition of the matrix A into (\s-1LU\s0, p) given by gsl_linalg_LU_decomp. \f(CW$LU\fR is a matrix, \f(CW$p\fR a permutation and \f(CW$b\fR and \f(CW$x\fR are vectors. The function returns 1 if the operation succeded, 0 otherwise." 4
.IX Item "gsl_linalg_LU_solve($LU, $p, $b, $x) - This function solves the square system A x = b using the LU decomposition of the matrix A into (LU, p) given by gsl_linalg_LU_decomp. $LU is a matrix, $p a permutation and $b and $x are vectors. The function returns 1 if the operation succeded, 0 otherwise."
.ie n .IP "gsl_linalg_LU_svx($LU, $p, $x) \- This function solves the square system A x = b in-place using the \s-1LU\s0 decomposition of A into (\s-1LU\s0,p). On input $x should contain the right-hand side b, which is replaced by the solution on output. $LU is a matrix, $p a permutation and $x is a vector. The function returns 1 if the operation succeded, 0 otherwise." 4
.el .IP "gsl_linalg_LU_svx($LU, \f(CW$p\fR, \f(CW$x\fR) \- This function solves the square system A x = b in-place using the \s-1LU\s0 decomposition of A into (\s-1LU\s0,p). On input \f(CW$x\fR should contain the right-hand side b, which is replaced by the solution on output. \f(CW$LU\fR is a matrix, \f(CW$p\fR a permutation and \f(CW$x\fR is a vector. The function returns 1 if the operation succeded, 0 otherwise." 4
.IX Item "gsl_linalg_LU_svx($LU, $p, $x) - This function solves the square system A x = b in-place using the LU decomposition of A into (LU,p). On input $x should contain the right-hand side b, which is replaced by the solution on output. $LU is a matrix, $p a permutation and $x is a vector. The function returns 1 if the operation succeded, 0 otherwise."
.ie n .IP "gsl_linalg_LU_refine($A, $LU, $p, $b, $x, $residual) \- This function apply an iterative improvement to $x, the solution of $A $x = $b, using the \s-1LU\s0 decomposition of $A into ($LU,$p). The initial residual $r = $A $x \- $b (where $x and $b are vectors) is also computed and stored in the vector $residual." 4
.el .IP "gsl_linalg_LU_refine($A, \f(CW$LU\fR, \f(CW$p\fR, \f(CW$b\fR, \f(CW$x\fR, \f(CW$residual\fR) \- This function apply an iterative improvement to \f(CW$x\fR, the solution of \f(CW$A\fR \f(CW$x\fR = \f(CW$b\fR, using the \s-1LU\s0 decomposition of \f(CW$A\fR into ($LU,$p). The initial residual \f(CW$r\fR = \f(CW$A\fR \f(CW$x\fR \- \f(CW$b\fR (where \f(CW$x\fR and \f(CW$b\fR are vectors) is also computed and stored in the vector \f(CW$residual\fR." 4
.IX Item "gsl_linalg_LU_refine($A, $LU, $p, $b, $x, $residual) - This function apply an iterative improvement to $x, the solution of $A $x = $b, using the LU decomposition of $A into ($LU,$p). The initial residual $r = $A $x - $b (where $x and $b are vectors) is also computed and stored in the vector $residual."
.ie n .IP "gsl_linalg_LU_invert($LU, $p, $inverse) \- This function computes the inverse of a matrix A from its \s-1LU\s0 decomposition stored in the matrix $LU and the permutation $p, storing the result in the matrix $inverse." 4
.el .IP "gsl_linalg_LU_invert($LU, \f(CW$p\fR, \f(CW$inverse\fR) \- This function computes the inverse of a matrix A from its \s-1LU\s0 decomposition stored in the matrix \f(CW$LU\fR and the permutation \f(CW$p\fR, storing the result in the matrix \f(CW$inverse\fR." 4
.IX Item "gsl_linalg_LU_invert($LU, $p, $inverse) - This function computes the inverse of a matrix A from its LU decomposition stored in the matrix $LU and the permutation $p, storing the result in the matrix $inverse."
.ie n .IP "gsl_linalg_LU_det($LU, $signum) \- This function returns the determinant of a matrix A from its \s-1LU\s0 decomposition stored in the $LU matrix. It needs the integer $signum which is the sign of the permutation returned by gsl_linalg_LU_decomp." 4
.el .IP "gsl_linalg_LU_det($LU, \f(CW$signum\fR) \- This function returns the determinant of a matrix A from its \s-1LU\s0 decomposition stored in the \f(CW$LU\fR matrix. It needs the integer \f(CW$signum\fR which is the sign of the permutation returned by gsl_linalg_LU_decomp." 4
.IX Item "gsl_linalg_LU_det($LU, $signum) - This function returns the determinant of a matrix A from its LU decomposition stored in the $LU matrix. It needs the integer $signum which is the sign of the permutation returned by gsl_linalg_LU_decomp."
.ie n .IP "gsl_linalg_LU_lndet($LU) \- This function returns the logarithm of the absolute value of the determinant of a matrix A, from its \s-1LU\s0 decomposition stored in the $LU matrix." 4
.el .IP "gsl_linalg_LU_lndet($LU) \- This function returns the logarithm of the absolute value of the determinant of a matrix A, from its \s-1LU\s0 decomposition stored in the \f(CW$LU\fR matrix." 4
.IX Item "gsl_linalg_LU_lndet($LU) - This function returns the logarithm of the absolute value of the determinant of a matrix A, from its LU decomposition stored in the $LU matrix."
.ie n .IP "gsl_linalg_LU_sgndet($LU, $signum) \- This functions computes the sign or phase factor of the determinant of a matrix A, det(A)/|det(A)|, from its \s-1LU\s0 decomposition, $LU." 4
.el .IP "gsl_linalg_LU_sgndet($LU, \f(CW$signum\fR) \- This functions computes the sign or phase factor of the determinant of a matrix A, det(A)/|det(A)|, from its \s-1LU\s0 decomposition, \f(CW$LU\fR." 4
.IX Item "gsl_linalg_LU_sgndet($LU, $signum) - This functions computes the sign or phase factor of the determinant of a matrix A, det(A)/|det(A)|, from its LU decomposition, $LU."
.ie n .IP "gsl_linalg_complex_LU_decomp($A, $p) \- Does the same operation than gsl_linalg_LU_decomp but on the complex matrix $A." 4
.el .IP "gsl_linalg_complex_LU_decomp($A, \f(CW$p\fR) \- Does the same operation than gsl_linalg_LU_decomp but on the complex matrix \f(CW$A\fR." 4
.IX Item "gsl_linalg_complex_LU_decomp($A, $p) - Does the same operation than gsl_linalg_LU_decomp but on the complex matrix $A."
.ie n .IP "gsl_linalg_complex_LU_solve($LU, $p, $b, $x) \- This functions solve the square system A x = b using the \s-1LU\s0 decomposition of A into ($LU, $p) given by  gsl_linalg_complex_LU_decomp." 4
.el .IP "gsl_linalg_complex_LU_solve($LU, \f(CW$p\fR, \f(CW$b\fR, \f(CW$x\fR) \- This functions solve the square system A x = b using the \s-1LU\s0 decomposition of A into ($LU, \f(CW$p\fR) given by  gsl_linalg_complex_LU_decomp." 4
.IX Item "gsl_linalg_complex_LU_solve($LU, $p, $b, $x) - This functions solve the square system A x = b using the LU decomposition of A into ($LU, $p) given by  gsl_linalg_complex_LU_decomp."
.ie n .IP "gsl_linalg_complex_LU_svx($LU, $p, $x) \- Does the same operation than gsl_linalg_LU_svx but on the complex matrix $LU and the complex vector $x." 4
.el .IP "gsl_linalg_complex_LU_svx($LU, \f(CW$p\fR, \f(CW$x\fR) \- Does the same operation than gsl_linalg_LU_svx but on the complex matrix \f(CW$LU\fR and the complex vector \f(CW$x\fR." 4
.IX Item "gsl_linalg_complex_LU_svx($LU, $p, $x) - Does the same operation than gsl_linalg_LU_svx but on the complex matrix $LU and the complex vector $x."
.ie n .IP "gsl_linalg_complex_LU_refine($A, $LU, $p, $b, $x, $residual) \- Does the same operation than gsl_linalg_LU_refine but on the complex matrices $A and $LU and with the complex vectors $b, $x and $residual." 4
.el .IP "gsl_linalg_complex_LU_refine($A, \f(CW$LU\fR, \f(CW$p\fR, \f(CW$b\fR, \f(CW$x\fR, \f(CW$residual\fR) \- Does the same operation than gsl_linalg_LU_refine but on the complex matrices \f(CW$A\fR and \f(CW$LU\fR and with the complex vectors \f(CW$b\fR, \f(CW$x\fR and \f(CW$residual\fR." 4
.IX Item "gsl_linalg_complex_LU_refine($A, $LU, $p, $b, $x, $residual) - Does the same operation than gsl_linalg_LU_refine but on the complex matrices $A and $LU and with the complex vectors $b, $x and $residual."
.ie n .IP "gsl_linalg_complex_LU_invert($LU, $p, $inverse) \- Does the same operation than gsl_linalg_LU_invert but on the complex matrces $LU and $inverse." 4
.el .IP "gsl_linalg_complex_LU_invert($LU, \f(CW$p\fR, \f(CW$inverse\fR) \- Does the same operation than gsl_linalg_LU_invert but on the complex matrces \f(CW$LU\fR and \f(CW$inverse\fR." 4
.IX Item "gsl_linalg_complex_LU_invert($LU, $p, $inverse) - Does the same operation than gsl_linalg_LU_invert but on the complex matrces $LU and $inverse."
.ie n .IP "gsl_linalg_complex_LU_det($LU, $signum) \- Does the same operation than gsl_linalg_LU_det but on the complex matrix $LU." 4
.el .IP "gsl_linalg_complex_LU_det($LU, \f(CW$signum\fR) \- Does the same operation than gsl_linalg_LU_det but on the complex matrix \f(CW$LU\fR." 4
.IX Item "gsl_linalg_complex_LU_det($LU, $signum) - Does the same operation than gsl_linalg_LU_det but on the complex matrix $LU."
.ie n .IP "gsl_linalg_complex_LU_lndet($LU) \- Does the same operation than gsl_linalg_LU_det but on the complex matrix $LU." 4
.el .IP "gsl_linalg_complex_LU_lndet($LU) \- Does the same operation than gsl_linalg_LU_det but on the complex matrix \f(CW$LU\fR." 4
.IX Item "gsl_linalg_complex_LU_lndet($LU) - Does the same operation than gsl_linalg_LU_det but on the complex matrix $LU."
.ie n .IP "gsl_linalg_complex_LU_sgndet($LU, $signum) \- Does the same operation than gsl_linalg_LU_sgndet but on the complex matrix $LU." 4
.el .IP "gsl_linalg_complex_LU_sgndet($LU, \f(CW$signum\fR) \- Does the same operation than gsl_linalg_LU_sgndet but on the complex matrix \f(CW$LU\fR." 4
.IX Item "gsl_linalg_complex_LU_sgndet($LU, $signum) - Does the same operation than gsl_linalg_LU_sgndet but on the complex matrix $LU."
.ie n .IP "gsl_linalg_QR_decomp($a, $tau) \- factorize the M\-by-N matrix A into the \s-1QR\s0 decomposition A = Q R. On output the diagonal and upper triangular part of the input matrix $a contain the matrix R. The vector $tau and the columns of the lower triangular part of the matrix $a contain the Householder coefficients and Householder vectors which encode the orthogonal matrix Q. The vector tau must be of length k= min(M,N)." 4
.el .IP "gsl_linalg_QR_decomp($a, \f(CW$tau\fR) \- factorize the M\-by-N matrix A into the \s-1QR\s0 decomposition A = Q R. On output the diagonal and upper triangular part of the input matrix \f(CW$a\fR contain the matrix R. The vector \f(CW$tau\fR and the columns of the lower triangular part of the matrix \f(CW$a\fR contain the Householder coefficients and Householder vectors which encode the orthogonal matrix Q. The vector tau must be of length k= min(M,N)." 4
.IX Item "gsl_linalg_QR_decomp($a, $tau) - factorize the M-by-N matrix A into the QR decomposition A = Q R. On output the diagonal and upper triangular part of the input matrix $a contain the matrix R. The vector $tau and the columns of the lower triangular part of the matrix $a contain the Householder coefficients and Householder vectors which encode the orthogonal matrix Q. The vector tau must be of length k= min(M,N)."
.ie n .IP "gsl_linalg_QR_solve($QR, $tau, $b, $x) \- This function solves the square system A x = b using the \s-1QR\s0 decomposition of A into (\s-1QR\s0, tau) given by gsl_linalg_QR_decomp. $QR is matrix, and $tau, $b and $x are vectors." 4
.el .IP "gsl_linalg_QR_solve($QR, \f(CW$tau\fR, \f(CW$b\fR, \f(CW$x\fR) \- This function solves the square system A x = b using the \s-1QR\s0 decomposition of A into (\s-1QR\s0, tau) given by gsl_linalg_QR_decomp. \f(CW$QR\fR is matrix, and \f(CW$tau\fR, \f(CW$b\fR and \f(CW$x\fR are vectors." 4
.IX Item "gsl_linalg_QR_solve($QR, $tau, $b, $x) - This function solves the square system A x = b using the QR decomposition of A into (QR, tau) given by gsl_linalg_QR_decomp. $QR is matrix, and $tau, $b and $x are vectors."
.ie n .IP "gsl_linalg_QR_svx($QR, $tau, $x) \- This function solves the square system A x = b in-place using the \s-1QR\s0 decomposition of A into the matrix $QR and the vector $tau given by gsl_linalg_QR_decomp. On input, the vector $x should contain the right-hand side b, which is replaced by the solution on output." 4
.el .IP "gsl_linalg_QR_svx($QR, \f(CW$tau\fR, \f(CW$x\fR) \- This function solves the square system A x = b in-place using the \s-1QR\s0 decomposition of A into the matrix \f(CW$QR\fR and the vector \f(CW$tau\fR given by gsl_linalg_QR_decomp. On input, the vector \f(CW$x\fR should contain the right-hand side b, which is replaced by the solution on output." 4
.IX Item "gsl_linalg_QR_svx($QR, $tau, $x) - This function solves the square system A x = b in-place using the QR decomposition of A into the matrix $QR and the vector $tau given by gsl_linalg_QR_decomp. On input, the vector $x should contain the right-hand side b, which is replaced by the solution on output."
.ie n .IP "gsl_linalg_QR_lssolve($QR, $tau, $b, $x, $residual) \- This function finds the least squares solution to the overdetermined system $A $x = $b where the matrix $A has more rows than columns. The least squares solution minimizes the Euclidean norm of the residual, ||Ax \- b||.The routine uses the $QR decomposition of $A into ($QR, $tau) given by gsl_linalg_QR_decomp. The solution is returned in $x. The residual is computed as a by-product and stored in residual. The function returns 0 if it succeded, 1 otherwise." 4
.el .IP "gsl_linalg_QR_lssolve($QR, \f(CW$tau\fR, \f(CW$b\fR, \f(CW$x\fR, \f(CW$residual\fR) \- This function finds the least squares solution to the overdetermined system \f(CW$A\fR \f(CW$x\fR = \f(CW$b\fR where the matrix \f(CW$A\fR has more rows than columns. The least squares solution minimizes the Euclidean norm of the residual, ||Ax \- b||.The routine uses the \f(CW$QR\fR decomposition of \f(CW$A\fR into ($QR, \f(CW$tau\fR) given by gsl_linalg_QR_decomp. The solution is returned in \f(CW$x\fR. The residual is computed as a by-product and stored in residual. The function returns 0 if it succeded, 1 otherwise." 4
.IX Item "gsl_linalg_QR_lssolve($QR, $tau, $b, $x, $residual) - This function finds the least squares solution to the overdetermined system $A $x = $b where the matrix $A has more rows than columns. The least squares solution minimizes the Euclidean norm of the residual, ||Ax - b||.The routine uses the $QR decomposition of $A into ($QR, $tau) given by gsl_linalg_QR_decomp. The solution is returned in $x. The residual is computed as a by-product and stored in residual. The function returns 0 if it succeded, 1 otherwise."
.ie n .IP "gsl_linalg_QR_QRsolve($Q, $R, $b, $x) \- This function solves the system $R $x = $Q**T $b for $x. It can be used when the $QR decomposition of a matrix is available in unpacked form as ($Q, $R). The function returns 0 if it succeded, 1 otherwise." 4
.el .IP "gsl_linalg_QR_QRsolve($Q, \f(CW$R\fR, \f(CW$b\fR, \f(CW$x\fR) \- This function solves the system \f(CW$R\fR \f(CW$x\fR = \f(CW$Q\fR**T \f(CW$b\fR for \f(CW$x\fR. It can be used when the \f(CW$QR\fR decomposition of a matrix is available in unpacked form as ($Q, \f(CW$R\fR). The function returns 0 if it succeded, 1 otherwise." 4
.IX Item "gsl_linalg_QR_QRsolve($Q, $R, $b, $x) - This function solves the system $R $x = $Q**T $b for $x. It can be used when the $QR decomposition of a matrix is available in unpacked form as ($Q, $R). The function returns 0 if it succeded, 1 otherwise."
.ie n .IP "gsl_linalg_QR_Rsolve($QR, $b, $x) \- This function solves the triangular system R $x = $b for $x. It may be useful if the product b' = Q^T b has already been computed using gsl_linalg_QR_QTvec." 4
.el .IP "gsl_linalg_QR_Rsolve($QR, \f(CW$b\fR, \f(CW$x\fR) \- This function solves the triangular system R \f(CW$x\fR = \f(CW$b\fR for \f(CW$x\fR. It may be useful if the product b' = Q^T b has already been computed using gsl_linalg_QR_QTvec." 4
.IX Item "gsl_linalg_QR_Rsolve($QR, $b, $x) - This function solves the triangular system R $x = $b for $x. It may be useful if the product b' = Q^T b has already been computed using gsl_linalg_QR_QTvec."
.ie n .IP "gsl_linalg_QR_Rsvx($QR, $x) \- This function solves the triangular system R $x = b for $x in-place. On input $x should contain the right-hand side b and is replaced by the solution on output. This function may be useful if the product b' = Q^T b has already been computed using gsl_linalg_QR_QTvec. The function returns 0 if it succeded, 1 otherwise." 4
.el .IP "gsl_linalg_QR_Rsvx($QR, \f(CW$x\fR) \- This function solves the triangular system R \f(CW$x\fR = b for \f(CW$x\fR in-place. On input \f(CW$x\fR should contain the right-hand side b and is replaced by the solution on output. This function may be useful if the product b' = Q^T b has already been computed using gsl_linalg_QR_QTvec. The function returns 0 if it succeded, 1 otherwise." 4
.IX Item "gsl_linalg_QR_Rsvx($QR, $x) - This function solves the triangular system R $x = b for $x in-place. On input $x should contain the right-hand side b and is replaced by the solution on output. This function may be useful if the product b' = Q^T b has already been computed using gsl_linalg_QR_QTvec. The function returns 0 if it succeded, 1 otherwise."
.ie n .IP "gsl_linalg_QR_update($Q, $R, $b, $x) \- This function performs a rank\-1 update $w $v**T of the \s-1QR\s0 decomposition ($Q, $R). The update is given by Q'R' = Q R + w v^T where the output matrices Q' and R' are also orthogonal and right triangular. Note that w is destroyed by the update. The function returns 0 if it succeded, 1 otherwise." 4
.el .IP "gsl_linalg_QR_update($Q, \f(CW$R\fR, \f(CW$b\fR, \f(CW$x\fR) \- This function performs a rank\-1 update \f(CW$w\fR \f(CW$v\fR**T of the \s-1QR\s0 decomposition ($Q, \f(CW$R\fR). The update is given by Q'R' = Q R + w v^T where the output matrices Q' and R' are also orthogonal and right triangular. Note that w is destroyed by the update. The function returns 0 if it succeded, 1 otherwise." 4
.IX Item "gsl_linalg_QR_update($Q, $R, $b, $x) - This function performs a rank-1 update $w $v**T of the QR decomposition ($Q, $R). The update is given by Q'R' = Q R + w v^T where the output matrices Q' and R' are also orthogonal and right triangular. Note that w is destroyed by the update. The function returns 0 if it succeded, 1 otherwise."
.ie n .IP "gsl_linalg_QR_QTvec($QR, $tau, $v) \- This function applies the matrix Q^T encoded in the decomposition ($QR,$tau) to the vector $v, storing the result Q^T v in $v. The matrix multiplication is carried out directly using the encoding of the Householder vectors without needing to form the full matrix Q^T. The function returns 0 if it succeded, 1 otherwise." 4
.el .IP "gsl_linalg_QR_QTvec($QR, \f(CW$tau\fR, \f(CW$v\fR) \- This function applies the matrix Q^T encoded in the decomposition ($QR,$tau) to the vector \f(CW$v\fR, storing the result Q^T v in \f(CW$v\fR. The matrix multiplication is carried out directly using the encoding of the Householder vectors without needing to form the full matrix Q^T. The function returns 0 if it succeded, 1 otherwise." 4
.IX Item "gsl_linalg_QR_QTvec($QR, $tau, $v) - This function applies the matrix Q^T encoded in the decomposition ($QR,$tau) to the vector $v, storing the result Q^T v in $v. The matrix multiplication is carried out directly using the encoding of the Householder vectors without needing to form the full matrix Q^T. The function returns 0 if it succeded, 1 otherwise."
.ie n .IP "gsl_linalg_QR_Qvec($QR, $tau, $v) \- This function applies the matrix Q encoded in the decomposition ($QR,$tau) to the vector $v, storing the result Q v in $v. The matrix multiplication is carried out directly using the encoding of the Householder vectors without needing to form the full matrix Q. The function returns 0 if it succeded, 1 otherwise." 4
.el .IP "gsl_linalg_QR_Qvec($QR, \f(CW$tau\fR, \f(CW$v\fR) \- This function applies the matrix Q encoded in the decomposition ($QR,$tau) to the vector \f(CW$v\fR, storing the result Q v in \f(CW$v\fR. The matrix multiplication is carried out directly using the encoding of the Householder vectors without needing to form the full matrix Q. The function returns 0 if it succeded, 1 otherwise." 4
.IX Item "gsl_linalg_QR_Qvec($QR, $tau, $v) - This function applies the matrix Q encoded in the decomposition ($QR,$tau) to the vector $v, storing the result Q v in $v. The matrix multiplication is carried out directly using the encoding of the Householder vectors without needing to form the full matrix Q. The function returns 0 if it succeded, 1 otherwise."
.ie n .IP "gsl_linalg_QR_QTmat($QR, $tau, $A) \- This function applies the matrix Q^T encoded in the decomposition ($QR,$tau) to the matrix $A, storing the result Q^T A in $A. The matrix multiplication is carried out directly using the encoding of the Householder vectors without needing to form the full matrix Q^T. The function returns 0 if it succeded, 1 otherwise." 4
.el .IP "gsl_linalg_QR_QTmat($QR, \f(CW$tau\fR, \f(CW$A\fR) \- This function applies the matrix Q^T encoded in the decomposition ($QR,$tau) to the matrix \f(CW$A\fR, storing the result Q^T A in \f(CW$A\fR. The matrix multiplication is carried out directly using the encoding of the Householder vectors without needing to form the full matrix Q^T. The function returns 0 if it succeded, 1 otherwise." 4
.IX Item "gsl_linalg_QR_QTmat($QR, $tau, $A) - This function applies the matrix Q^T encoded in the decomposition ($QR,$tau) to the matrix $A, storing the result Q^T A in $A. The matrix multiplication is carried out directly using the encoding of the Householder vectors without needing to form the full matrix Q^T. The function returns 0 if it succeded, 1 otherwise."
.ie n .IP "gsl_linalg_QR_unpack($QR, $tau, $Q, $R) \- This function unpacks the encoded \s-1QR\s0 decomposition ($QR,$tau) into the matrices $Q and $R, where $Q is M\-by-M and $R is M\-by-N. The function returns 0 if it succeded, 1 otherwise." 4
.el .IP "gsl_linalg_QR_unpack($QR, \f(CW$tau\fR, \f(CW$Q\fR, \f(CW$R\fR) \- This function unpacks the encoded \s-1QR\s0 decomposition ($QR,$tau) into the matrices \f(CW$Q\fR and \f(CW$R\fR, where \f(CW$Q\fR is M\-by-M and \f(CW$R\fR is M\-by-N. The function returns 0 if it succeded, 1 otherwise." 4
.IX Item "gsl_linalg_QR_unpack($QR, $tau, $Q, $R) - This function unpacks the encoded QR decomposition ($QR,$tau) into the matrices $Q and $R, where $Q is M-by-M and $R is M-by-N. The function returns 0 if it succeded, 1 otherwise."
.ie n .IP "gsl_linalg_R_solve($R, $b, $x) \- This function solves the triangular system $R $x = $b for the N\-by-N matrix $R. The function returns 0 if it succeded, 1 otherwise." 4
.el .IP "gsl_linalg_R_solve($R, \f(CW$b\fR, \f(CW$x\fR) \- This function solves the triangular system \f(CW$R\fR \f(CW$x\fR = \f(CW$b\fR for the N\-by-N matrix \f(CW$R\fR. The function returns 0 if it succeded, 1 otherwise." 4
.IX Item "gsl_linalg_R_solve($R, $b, $x) - This function solves the triangular system $R $x = $b for the N-by-N matrix $R. The function returns 0 if it succeded, 1 otherwise."
.ie n .IP "gsl_linalg_R_svx($R, $x) \- This function solves the triangular system $R $x = b in-place. On input $x should contain the right-hand side b, which is replaced by the solution on output. The function returns 0 if it succeded, 1 otherwise." 4
.el .IP "gsl_linalg_R_svx($R, \f(CW$x\fR) \- This function solves the triangular system \f(CW$R\fR \f(CW$x\fR = b in-place. On input \f(CW$x\fR should contain the right-hand side b, which is replaced by the solution on output. The function returns 0 if it succeded, 1 otherwise." 4
.IX Item "gsl_linalg_R_svx($R, $x) - This function solves the triangular system $R $x = b in-place. On input $x should contain the right-hand side b, which is replaced by the solution on output. The function returns 0 if it succeded, 1 otherwise."
.ie n .IP "gsl_linalg_QRPT_decomp($A, $tau, $p, $norm) \- This function factorizes the M\-by-N matrix $A into the QRP^T decomposition A = Q R P^T. On output the diagonal and upper triangular part of the input matrix contain the matrix R. The permutation matrix P is stored in the permutation $p. There's two value returned by this function : the first is 0 if the operation succeeded, 1 otherwise. The second is sign of the permutation. It has the value (\-1)^n, where n is the number of interchanges in the permutation. The vector $tau and the columns of the lower triangular part of the matrix $A contain the Householder coefficients and vectors which encode the orthogonal matrix Q. The vector tau must be of length k=\emin(M,N). The matrix Q is related to these components by, Q = Q_k ... Q_2 Q_1 where Q_i = I \- \etau_i v_i v_i^T and v_i is the Householder vector v_i = (0,...,1,A(i+1,i),A(i+2,i),...,A(m,i)). This is the same storage scheme as used by lapack. The vector norm is a workspace of length N used for column pivoting. The algorithm used to perform the decomposition is Householder \s-1QR\s0 with column pivoting (Golub & Van Loan, Matrix Computations, Algorithm 5.4.1)." 4
.el .IP "gsl_linalg_QRPT_decomp($A, \f(CW$tau\fR, \f(CW$p\fR, \f(CW$norm\fR) \- This function factorizes the M\-by-N matrix \f(CW$A\fR into the QRP^T decomposition A = Q R P^T. On output the diagonal and upper triangular part of the input matrix contain the matrix R. The permutation matrix P is stored in the permutation \f(CW$p\fR. There's two value returned by this function : the first is 0 if the operation succeeded, 1 otherwise. The second is sign of the permutation. It has the value (\-1)^n, where n is the number of interchanges in the permutation. The vector \f(CW$tau\fR and the columns of the lower triangular part of the matrix \f(CW$A\fR contain the Householder coefficients and vectors which encode the orthogonal matrix Q. The vector tau must be of length k=\emin(M,N). The matrix Q is related to these components by, Q = Q_k ... Q_2 Q_1 where Q_i = I \- \etau_i v_i v_i^T and v_i is the Householder vector v_i = (0,...,1,A(i+1,i),A(i+2,i),...,A(m,i)). This is the same storage scheme as used by lapack. The vector norm is a workspace of length N used for column pivoting. The algorithm used to perform the decomposition is Householder \s-1QR\s0 with column pivoting (Golub & Van Loan, Matrix Computations, Algorithm 5.4.1)." 4
.IX Item "gsl_linalg_QRPT_decomp($A, $tau, $p, $norm) - This function factorizes the M-by-N matrix $A into the QRP^T decomposition A = Q R P^T. On output the diagonal and upper triangular part of the input matrix contain the matrix R. The permutation matrix P is stored in the permutation $p. There's two value returned by this function : the first is 0 if the operation succeeded, 1 otherwise. The second is sign of the permutation. It has the value (-1)^n, where n is the number of interchanges in the permutation. The vector $tau and the columns of the lower triangular part of the matrix $A contain the Householder coefficients and vectors which encode the orthogonal matrix Q. The vector tau must be of length k=min(M,N). The matrix Q is related to these components by, Q = Q_k ... Q_2 Q_1 where Q_i = I - tau_i v_i v_i^T and v_i is the Householder vector v_i = (0,...,1,A(i+1,i),A(i+2,i),...,A(m,i)). This is the same storage scheme as used by lapack. The vector norm is a workspace of length N used for column pivoting. The algorithm used to perform the decomposition is Householder QR with column pivoting (Golub & Van Loan, Matrix Computations, Algorithm 5.4.1)."
.ie n .IP "gsl_linalg_QRPT_decomp2($A, $q, $r, $tau, $p, $norm)  \- This function factorizes the matrix $A into the decomposition A = Q R P^T without modifying $A itself and storing the output in the separate matrices $q and $r. For the rest, it operates exactly like gsl_linalg_QRPT_decomp" 4
.el .IP "gsl_linalg_QRPT_decomp2($A, \f(CW$q\fR, \f(CW$r\fR, \f(CW$tau\fR, \f(CW$p\fR, \f(CW$norm\fR)  \- This function factorizes the matrix \f(CW$A\fR into the decomposition A = Q R P^T without modifying \f(CW$A\fR itself and storing the output in the separate matrices \f(CW$q\fR and \f(CW$r\fR. For the rest, it operates exactly like gsl_linalg_QRPT_decomp" 4
.IX Item "gsl_linalg_QRPT_decomp2($A, $q, $r, $tau, $p, $norm)  - This function factorizes the matrix $A into the decomposition A = Q R P^T without modifying $A itself and storing the output in the separate matrices $q and $r. For the rest, it operates exactly like gsl_linalg_QRPT_decomp"
.IP "gsl_linalg_QRPT_solve" 4
.IX Item "gsl_linalg_QRPT_solve"
.IP "gsl_linalg_QRPT_svx" 4
.IX Item "gsl_linalg_QRPT_svx"
.IP "gsl_linalg_QRPT_QRsolve" 4
.IX Item "gsl_linalg_QRPT_QRsolve"
.IP "gsl_linalg_QRPT_Rsolve" 4
.IX Item "gsl_linalg_QRPT_Rsolve"
.IP "gsl_linalg_QRPT_Rsvx" 4
.IX Item "gsl_linalg_QRPT_Rsvx"
.IP "gsl_linalg_QRPT_update" 4
.IX Item "gsl_linalg_QRPT_update"
.IP "gsl_linalg_LQ_decomp" 4
.IX Item "gsl_linalg_LQ_decomp"
.IP "gsl_linalg_LQ_solve_T" 4
.IX Item "gsl_linalg_LQ_solve_T"
.IP "gsl_linalg_LQ_svx_T" 4
.IX Item "gsl_linalg_LQ_svx_T"
.IP "gsl_linalg_LQ_lssolve_T" 4
.IX Item "gsl_linalg_LQ_lssolve_T"
.IP "gsl_linalg_LQ_Lsolve_T" 4
.IX Item "gsl_linalg_LQ_Lsolve_T"
.IP "gsl_linalg_LQ_Lsvx_T" 4
.IX Item "gsl_linalg_LQ_Lsvx_T"
.IP "gsl_linalg_L_solve_T" 4
.IX Item "gsl_linalg_L_solve_T"
.IP "gsl_linalg_LQ_vecQ" 4
.IX Item "gsl_linalg_LQ_vecQ"
.IP "gsl_linalg_LQ_vecQT" 4
.IX Item "gsl_linalg_LQ_vecQT"
.IP "gsl_linalg_LQ_unpack" 4
.IX Item "gsl_linalg_LQ_unpack"
.IP "gsl_linalg_LQ_update" 4
.IX Item "gsl_linalg_LQ_update"
.IP "gsl_linalg_LQ_LQsolve" 4
.IX Item "gsl_linalg_LQ_LQsolve"
.IP "gsl_linalg_PTLQ_decomp" 4
.IX Item "gsl_linalg_PTLQ_decomp"
.IP "gsl_linalg_PTLQ_decomp2" 4
.IX Item "gsl_linalg_PTLQ_decomp2"
.IP "gsl_linalg_PTLQ_solve_T" 4
.IX Item "gsl_linalg_PTLQ_solve_T"
.IP "gsl_linalg_PTLQ_svx_T" 4
.IX Item "gsl_linalg_PTLQ_svx_T"
.IP "gsl_linalg_PTLQ_LQsolve_T" 4
.IX Item "gsl_linalg_PTLQ_LQsolve_T"
.IP "gsl_linalg_PTLQ_Lsolve_T" 4
.IX Item "gsl_linalg_PTLQ_Lsolve_T"
.IP "gsl_linalg_PTLQ_Lsvx_T" 4
.IX Item "gsl_linalg_PTLQ_Lsvx_T"
.IP "gsl_linalg_PTLQ_update" 4
.IX Item "gsl_linalg_PTLQ_update"
.ie n .IP "gsl_linalg_cholesky_decomp($A) \- Factorize the symmetric, positive-definite square matrix $A into the Cholesky decomposition A = L L^T and stores it into the matrix $A. The funtcion returns 0 if the operation succeeded, 0 otherwise." 4
.el .IP "gsl_linalg_cholesky_decomp($A) \- Factorize the symmetric, positive-definite square matrix \f(CW$A\fR into the Cholesky decomposition A = L L^T and stores it into the matrix \f(CW$A\fR. The funtcion returns 0 if the operation succeeded, 0 otherwise." 4
.IX Item "gsl_linalg_cholesky_decomp($A) - Factorize the symmetric, positive-definite square matrix $A into the Cholesky decomposition A = L L^T and stores it into the matrix $A. The funtcion returns 0 if the operation succeeded, 0 otherwise."
.ie n .IP "gsl_linalg_cholesky_solve($cholesky, $b, $x) \- This function solves the system A x = b using the Cholesky decomposition of A into the matrix $cholesky given by gsl_linalg_cholesky_decomp. $b and $x are vectors. The funtcion returns 0 if the operation succeeded, 0 otherwise." 4
.el .IP "gsl_linalg_cholesky_solve($cholesky, \f(CW$b\fR, \f(CW$x\fR) \- This function solves the system A x = b using the Cholesky decomposition of A into the matrix \f(CW$cholesky\fR given by gsl_linalg_cholesky_decomp. \f(CW$b\fR and \f(CW$x\fR are vectors. The funtcion returns 0 if the operation succeeded, 0 otherwise." 4
.IX Item "gsl_linalg_cholesky_solve($cholesky, $b, $x) - This function solves the system A x = b using the Cholesky decomposition of A into the matrix $cholesky given by gsl_linalg_cholesky_decomp. $b and $x are vectors. The funtcion returns 0 if the operation succeeded, 0 otherwise."
.ie n .IP "gsl_linalg_cholesky_svx($cholesky, $x) \- This function solves the system A x = b in-place using the Cholesky decomposition of A into the matrix $cholesky given by gsl_linalg_cholesky_decomp. On input the vector $x should contain the right-hand side b, which is replaced by the solution on output. The funtcion returns 0 if the operation succeeded, 0 otherwise." 4
.el .IP "gsl_linalg_cholesky_svx($cholesky, \f(CW$x\fR) \- This function solves the system A x = b in-place using the Cholesky decomposition of A into the matrix \f(CW$cholesky\fR given by gsl_linalg_cholesky_decomp. On input the vector \f(CW$x\fR should contain the right-hand side b, which is replaced by the solution on output. The funtcion returns 0 if the operation succeeded, 0 otherwise." 4
.IX Item "gsl_linalg_cholesky_svx($cholesky, $x) - This function solves the system A x = b in-place using the Cholesky decomposition of A into the matrix $cholesky given by gsl_linalg_cholesky_decomp. On input the vector $x should contain the right-hand side b, which is replaced by the solution on output. The funtcion returns 0 if the operation succeeded, 0 otherwise."
.IP "gsl_linalg_cholesky_decomp_unit" 4
.IX Item "gsl_linalg_cholesky_decomp_unit"
.ie n .IP "gsl_linalg_complex_cholesky_decomp($A) \- Factorize the symmetric, positive-definite square matrix $A which contains complex numbers into the Cholesky decomposition A = L L^T and stores it into the matrix $A. The funtcion returns 0 if the operation succeeded, 0 otherwise." 4
.el .IP "gsl_linalg_complex_cholesky_decomp($A) \- Factorize the symmetric, positive-definite square matrix \f(CW$A\fR which contains complex numbers into the Cholesky decomposition A = L L^T and stores it into the matrix \f(CW$A\fR. The funtcion returns 0 if the operation succeeded, 0 otherwise." 4
.IX Item "gsl_linalg_complex_cholesky_decomp($A) - Factorize the symmetric, positive-definite square matrix $A which contains complex numbers into the Cholesky decomposition A = L L^T and stores it into the matrix $A. The funtcion returns 0 if the operation succeeded, 0 otherwise."
.ie n .IP "gsl_linalg_complex_cholesky_solve($cholesky, $b, $x) \- This function solves the system A x = b using the Cholesky decomposition of A into the matrix $cholesky given by gsl_linalg_complex_cholesky_decomp. $b and $x are vectors. The funtcion returns 0 if the operation succeeded, 0 otherwise." 4
.el .IP "gsl_linalg_complex_cholesky_solve($cholesky, \f(CW$b\fR, \f(CW$x\fR) \- This function solves the system A x = b using the Cholesky decomposition of A into the matrix \f(CW$cholesky\fR given by gsl_linalg_complex_cholesky_decomp. \f(CW$b\fR and \f(CW$x\fR are vectors. The funtcion returns 0 if the operation succeeded, 0 otherwise." 4
.IX Item "gsl_linalg_complex_cholesky_solve($cholesky, $b, $x) - This function solves the system A x = b using the Cholesky decomposition of A into the matrix $cholesky given by gsl_linalg_complex_cholesky_decomp. $b and $x are vectors. The funtcion returns 0 if the operation succeeded, 0 otherwise."
.ie n .IP "gsl_linalg_complex_cholesky_svx($cholesky, $x) \- This function solves the system A x = b in-place using the Cholesky decomposition of A into the matrix $cholesky given by gsl_linalg_complex_cholesky_decomp. On input the vector $x should contain the right-hand side b, which is replaced by the solution on output. The funtcion returns 0 if the operation succeeded, 0 otherwise." 4
.el .IP "gsl_linalg_complex_cholesky_svx($cholesky, \f(CW$x\fR) \- This function solves the system A x = b in-place using the Cholesky decomposition of A into the matrix \f(CW$cholesky\fR given by gsl_linalg_complex_cholesky_decomp. On input the vector \f(CW$x\fR should contain the right-hand side b, which is replaced by the solution on output. The funtcion returns 0 if the operation succeeded, 0 otherwise." 4
.IX Item "gsl_linalg_complex_cholesky_svx($cholesky, $x) - This function solves the system A x = b in-place using the Cholesky decomposition of A into the matrix $cholesky given by gsl_linalg_complex_cholesky_decomp. On input the vector $x should contain the right-hand side b, which is replaced by the solution on output. The funtcion returns 0 if the operation succeeded, 0 otherwise."
.ie n .IP "gsl_linalg_symmtd_decomp($A, $tau) \- This function factorizes the symmetric square matrix $A into the symmetric tridiagonal decomposition Q T Q^T. On output the diagonal and subdiagonal part of the input matrix $A contain the tridiagonal matrix T. The remaining lower triangular part of the input matrix contains the Householder vectors which, together with the Householder coefficients $tau, encode the orthogonal matrix Q. This storage scheme is the same as used by lapack. The upper triangular part of $A is not referenced. $tau is a vector." 4
.el .IP "gsl_linalg_symmtd_decomp($A, \f(CW$tau\fR) \- This function factorizes the symmetric square matrix \f(CW$A\fR into the symmetric tridiagonal decomposition Q T Q^T. On output the diagonal and subdiagonal part of the input matrix \f(CW$A\fR contain the tridiagonal matrix T. The remaining lower triangular part of the input matrix contains the Householder vectors which, together with the Householder coefficients \f(CW$tau\fR, encode the orthogonal matrix Q. This storage scheme is the same as used by lapack. The upper triangular part of \f(CW$A\fR is not referenced. \f(CW$tau\fR is a vector." 4
.IX Item "gsl_linalg_symmtd_decomp($A, $tau) - This function factorizes the symmetric square matrix $A into the symmetric tridiagonal decomposition Q T Q^T. On output the diagonal and subdiagonal part of the input matrix $A contain the tridiagonal matrix T. The remaining lower triangular part of the input matrix contains the Householder vectors which, together with the Householder coefficients $tau, encode the orthogonal matrix Q. This storage scheme is the same as used by lapack. The upper triangular part of $A is not referenced. $tau is a vector."
.ie n .IP "gsl_linalg_symmtd_unpack($A, $tau, $Q, $diag, $subdiag) \- This function unpacks the encoded symmetric tridiagonal decomposition ($A, $tau) obtained from gsl_linalg_symmtd_decomp into the orthogonal matrix $Q, the vector of diagonal elements $diag and the vector of subdiagonal elements $subdiag." 4
.el .IP "gsl_linalg_symmtd_unpack($A, \f(CW$tau\fR, \f(CW$Q\fR, \f(CW$diag\fR, \f(CW$subdiag\fR) \- This function unpacks the encoded symmetric tridiagonal decomposition ($A, \f(CW$tau\fR) obtained from gsl_linalg_symmtd_decomp into the orthogonal matrix \f(CW$Q\fR, the vector of diagonal elements \f(CW$diag\fR and the vector of subdiagonal elements \f(CW$subdiag\fR." 4
.IX Item "gsl_linalg_symmtd_unpack($A, $tau, $Q, $diag, $subdiag) - This function unpacks the encoded symmetric tridiagonal decomposition ($A, $tau) obtained from gsl_linalg_symmtd_decomp into the orthogonal matrix $Q, the vector of diagonal elements $diag and the vector of subdiagonal elements $subdiag."
.ie n .IP "gsl_linalg_symmtd_unpack_T($A, $diag, $subdiag) \- This function unpacks the diagonal and subdiagonal of the encoded symmetric tridiagonal decomposition ($A, $tau) obtained from gsl_linalg_symmtd_decomp into the vectors $diag and $subdiag." 4
.el .IP "gsl_linalg_symmtd_unpack_T($A, \f(CW$diag\fR, \f(CW$subdiag\fR) \- This function unpacks the diagonal and subdiagonal of the encoded symmetric tridiagonal decomposition ($A, \f(CW$tau\fR) obtained from gsl_linalg_symmtd_decomp into the vectors \f(CW$diag\fR and \f(CW$subdiag\fR." 4
.IX Item "gsl_linalg_symmtd_unpack_T($A, $diag, $subdiag) - This function unpacks the diagonal and subdiagonal of the encoded symmetric tridiagonal decomposition ($A, $tau) obtained from gsl_linalg_symmtd_decomp into the vectors $diag and $subdiag."
.ie n .IP "gsl_linalg_hermtd_decomp($A, $tau) \- This function factorizes the hermitian matrix $A into the symmetric tridiagonal decomposition U T U^T. On output the real parts of the diagonal and subdiagonal part of the input matrix $A contain the tridiagonal matrix T. The remaining lower triangular part of the input matrix contains the Householder vectors which, together with the Householder coefficients $tau, encode the orthogonal matrix Q. This storage scheme is the same as used by lapack. The upper triangular part of $A and imaginary parts of the diagonal are not referenced. $A is a complex matrix and $tau a complex vector." 4
.el .IP "gsl_linalg_hermtd_decomp($A, \f(CW$tau\fR) \- This function factorizes the hermitian matrix \f(CW$A\fR into the symmetric tridiagonal decomposition U T U^T. On output the real parts of the diagonal and subdiagonal part of the input matrix \f(CW$A\fR contain the tridiagonal matrix T. The remaining lower triangular part of the input matrix contains the Householder vectors which, together with the Householder coefficients \f(CW$tau\fR, encode the orthogonal matrix Q. This storage scheme is the same as used by lapack. The upper triangular part of \f(CW$A\fR and imaginary parts of the diagonal are not referenced. \f(CW$A\fR is a complex matrix and \f(CW$tau\fR a complex vector." 4
.IX Item "gsl_linalg_hermtd_decomp($A, $tau) - This function factorizes the hermitian matrix $A into the symmetric tridiagonal decomposition U T U^T. On output the real parts of the diagonal and subdiagonal part of the input matrix $A contain the tridiagonal matrix T. The remaining lower triangular part of the input matrix contains the Householder vectors which, together with the Householder coefficients $tau, encode the orthogonal matrix Q. This storage scheme is the same as used by lapack. The upper triangular part of $A and imaginary parts of the diagonal are not referenced. $A is a complex matrix and $tau a complex vector."
.ie n .IP "gsl_linalg_hermtd_unpack($A, $tau, $U, $diag, $subdiag) \- This function unpacks the encoded tridiagonal decomposition ($A, $tau) obtained from gsl_linalg_hermtd_decomp into the unitary complex  matrix $U, the real vector of diagonal elements $diag and the real vector of subdiagonal elements $subdiag." 4
.el .IP "gsl_linalg_hermtd_unpack($A, \f(CW$tau\fR, \f(CW$U\fR, \f(CW$diag\fR, \f(CW$subdiag\fR) \- This function unpacks the encoded tridiagonal decomposition ($A, \f(CW$tau\fR) obtained from gsl_linalg_hermtd_decomp into the unitary complex  matrix \f(CW$U\fR, the real vector of diagonal elements \f(CW$diag\fR and the real vector of subdiagonal elements \f(CW$subdiag\fR." 4
.IX Item "gsl_linalg_hermtd_unpack($A, $tau, $U, $diag, $subdiag) - This function unpacks the encoded tridiagonal decomposition ($A, $tau) obtained from gsl_linalg_hermtd_decomp into the unitary complex  matrix $U, the real vector of diagonal elements $diag and the real vector of subdiagonal elements $subdiag."
.ie n .IP "gsl_linalg_hermtd_unpack_T($A, $diag, $subdiag) \- This function unpacks the diagonal and subdiagonal of the encoded tridiagonal decomposition (A, tau) obtained from the gsl_linalg_hermtd_decomp into the real vectors $diag and $subdiag." 4
.el .IP "gsl_linalg_hermtd_unpack_T($A, \f(CW$diag\fR, \f(CW$subdiag\fR) \- This function unpacks the diagonal and subdiagonal of the encoded tridiagonal decomposition (A, tau) obtained from the gsl_linalg_hermtd_decomp into the real vectors \f(CW$diag\fR and \f(CW$subdiag\fR." 4
.IX Item "gsl_linalg_hermtd_unpack_T($A, $diag, $subdiag) - This function unpacks the diagonal and subdiagonal of the encoded tridiagonal decomposition (A, tau) obtained from the gsl_linalg_hermtd_decomp into the real vectors $diag and $subdiag."
.ie n .IP "gsl_linalg_HH_solve($a, $b, $x) \- This function solves the system $A $x = $b directly using Householder transformations where $A is a matrix, $b and $x vectors. On output the solution is stored in $x and $b is not modified. $A is destroyed by the Householder transformations." 4
.el .IP "gsl_linalg_HH_solve($a, \f(CW$b\fR, \f(CW$x\fR) \- This function solves the system \f(CW$A\fR \f(CW$x\fR = \f(CW$b\fR directly using Householder transformations where \f(CW$A\fR is a matrix, \f(CW$b\fR and \f(CW$x\fR vectors. On output the solution is stored in \f(CW$x\fR and \f(CW$b\fR is not modified. \f(CW$A\fR is destroyed by the Householder transformations." 4
.IX Item "gsl_linalg_HH_solve($a, $b, $x) - This function solves the system $A $x = $b directly using Householder transformations where $A is a matrix, $b and $x vectors. On output the solution is stored in $x and $b is not modified. $A is destroyed by the Householder transformations."
.ie n .IP "gsl_linalg_HH_svx($A, $x) \- This function solves the system $A $x = b in-place using Householder transformations where $A is a matrix, $b is a vector. On input $x should contain the right-hand side b, which is replaced by the solution on output. The matrix $A is destroyed by the Householder transformations." 4
.el .IP "gsl_linalg_HH_svx($A, \f(CW$x\fR) \- This function solves the system \f(CW$A\fR \f(CW$x\fR = b in-place using Householder transformations where \f(CW$A\fR is a matrix, \f(CW$b\fR is a vector. On input \f(CW$x\fR should contain the right-hand side b, which is replaced by the solution on output. The matrix \f(CW$A\fR is destroyed by the Householder transformations." 4
.IX Item "gsl_linalg_HH_svx($A, $x) - This function solves the system $A $x = b in-place using Householder transformations where $A is a matrix, $b is a vector. On input $x should contain the right-hand side b, which is replaced by the solution on output. The matrix $A is destroyed by the Householder transformations."
.IP "gsl_linalg_solve_symm_tridiag" 4
.IX Item "gsl_linalg_solve_symm_tridiag"
.IP "gsl_linalg_solve_tridiag" 4
.IX Item "gsl_linalg_solve_tridiag"
.IP "gsl_linalg_solve_symm_cyc_tridiag" 4
.IX Item "gsl_linalg_solve_symm_cyc_tridiag"
.IP "gsl_linalg_solve_cyc_tridiag" 4
.IX Item "gsl_linalg_solve_cyc_tridiag"
.IP "gsl_linalg_bidiag_decomp" 4
.IX Item "gsl_linalg_bidiag_decomp"
.IP "gsl_linalg_bidiag_unpack" 4
.IX Item "gsl_linalg_bidiag_unpack"
.IP "gsl_linalg_bidiag_unpack2" 4
.IX Item "gsl_linalg_bidiag_unpack2"
.IP "gsl_linalg_bidiag_unpack_B" 4
.IX Item "gsl_linalg_bidiag_unpack_B"
.IP "gsl_linalg_balance_matrix" 4
.IX Item "gsl_linalg_balance_matrix"
.IP "gsl_linalg_balance_accum" 4
.IX Item "gsl_linalg_balance_accum"
.IP "gsl_linalg_balance_columns" 4
.IX Item "gsl_linalg_balance_columns"
.PD
.Vb 1
\& You have to add the functions you want to use inside the qw /put_funtion_here / with spaces between each function. You can also write use Math::GSL::Complex qw/:all/ to use all avaible functions of the module.
.Ve
.Sp
For more informations on the functions, we refer you to the \s-1GSL\s0 offcial documentation: <http://www.gnu.org/software/gsl/manual/html_node/>
.SH "EXAMPLES"
.IX Header "EXAMPLES"
This example shows how to compute the determinant of a matrix with the \s-1LU\s0 decomposition:
.PP
.Vb 3
\& use Math::GSL::Matrix qw/:all/;
\& use Math::GSL::Permutation qw/:all/;
\& use Math::GSL::Linalg qw/:all/;
\& 
\& my $Matrix = gsl_matrix_alloc(4,4);
\& map { gsl_matrix_set($Matrix, 0, $_, $_+1) } (0..3);
\& 
\& gsl_matrix_set($Matrix,1, 0, 2);
\& gsl_matrix_set($Matrix, 1, 1, 3);
\& gsl_matrix_set($Matrix, 1, 2, 4);
\& gsl_matrix_set($Matrix, 1, 3, 1);
\&
\& gsl_matrix_set($Matrix, 2, 0, 3);
\& gsl_matrix_set($Matrix, 2, 1, 4);
\& gsl_matrix_set($Matrix, 2, 2, 1);
\& gsl_matrix_set($Matrix, 2, 3, 2);
\&
\& gsl_matrix_set($Matrix, 3, 0, 4);
\& gsl_matrix_set($Matrix, 3, 1, 1);
\& gsl_matrix_set($Matrix, 3, 2, 2);
\& gsl_matrix_set($Matrix, 3, 3, 3);
\&    
\& my $permutation = gsl_permutation_alloc(4);
\& gsl_permutation_init($permutation);
\& my ($result, $signum) = gsl_linalg_LU_decomp($Matrix, $permutation);
\& my $det = gsl_linalg_LU_det($Matrix, $signum);
\& print "The value of the determinant of the matrix is $det \en";
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
Jonathan \*(L"Duke\*(R" Leto <jonathan@leto.net> and Thierry Moisan <thierry.moisan@gmail.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2008\-2011 Jonathan \*(L"Duke\*(R" Leto and Thierry Moisan
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
